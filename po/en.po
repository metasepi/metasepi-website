# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-08-13 20:27+0900\n"
"PO-Revision-Date: 2014-08-21 15:19+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:1 posts/2013-12-24-jats-ug.md:1
#: posts/2014-05-11-functional_lt.md:1 posts/2013-12-21-yuku-kuru.md:1
#: posts/2014-03-01-osc-tokyo.md:1 posts/2013-01-31-jhc_internal_overview.md:1
#: posts/2014-01-17-11th_wocs2.md:1 posts/2012-12-22-jhc.md:1
#: posts/2013-01-09-design_arafura.md:1 posts/2014-01-18-mbed_fest.md:1
#: posts/2013-07-24-ikamusume-c84.md:1 posts/2013-03-16-found_ajhc.md:1
#: posts/2014-01-05-mbed_fp_0.md:1 posts/2013-02-13-ocamlopt.md:1
#: posts/2013-10-20-osc2013-tokyo.md:1 posts/2013-06-20-forkos_jhc.md:1
#: posts/2013-10-06-osc2013-hi.md:1 posts/2012-08-18-haskell-or-ocaml-os.md:1
#: posts/2013-05-17-jgc_detail.md:1 posts/2013-05-16-jhc_grin_to_c.md:1
#: posts/2013-06-21-impl_mvar.md:1 posts/2012-08-05-start-metasepi.md:1
#: posts/2013-12-17-snatch-droid.md:1 posts/2013-06-20-reentrant_jhc.md:1
#: posts/2013-07-17-detail_of_jhc_parser.md:1
#: posts/2013-08-04-osckansai2013.md:1 posts/2013-11-24-osc-fukuoka-oita.md:1
#: posts/2013-09-16-osc2013-do.md:1
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:1 posts/2013-02-19-jhc_zen.md:1
#: posts/2014-01-10-prosym55.md:1 posts/2013-01-12-jhc_manual_ja.md:1
#: posts/2013-04-22-travel_in_kyoto-u.md:1 posts/2013-11-10-kof2013.md:1
#: posts/2013-02-03-kickoff_meeting.md:1
#, no-wrap
msgid "---\n"
msgstr "---\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:5
#, no-wrap
msgid ""
"title: \"ML programmer's guide to ATS\" 日本語訳\n"
"description: Haskell以外の言語処理系でスナッチ設計してみたいでゲソ!\n"
"tags: ats, translation\n"
"---\n"
msgstr ""
"title: \"ML programmer's guide to ATS\" translated into Japanese\n"
"description: Let's use the other language of Haskell for Snatch-deriven development!\n"
"tags: ats, translation\n"
"---\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:10
msgid ""
"この記事は [Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://"
"qiita.com/advent-calendar/2013/theorem_prover)  の12/23(月曜)分じゃなイカ。"
msgstr "This article is a part of [Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/advent-calendar/2013/theorem_prover)."

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:14
msgid ""
"ATS [http://www.ats-lang.org/](http://www.ats-lang.org/) という言語を知ってい"
"るでゲソ？ 依存型と線形型が使えて、もちろん証明器にもなるでゲソ。 以下のよう"
"なプログラミングパラダイムをサポートしているでゲソ。"
msgstr "Do you know about ATS language [http://www.ats-lang.org/](http://www.ats-lang.org/)? It has both dependent type and linear type, and to be theorem prover also theorem prover. It supports a variety of programming paradigms that include:"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:19
msgid "関数プログラミング"
msgstr "Functional programming"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:19
msgid "命令プログラミング"
msgstr "Imperative programming"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:19
msgid "並列プログラミング"
msgstr "Concurrent programming"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:19
msgid "モジュールシステム"
msgstr "Modular programming"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:21
msgid "ATSのHello Worldの実行バイナリのサイズも23kBと非常に小さいでゲソ。"
msgstr "Additionally, Hello World program binary compiled by ATS is very small as 23kB."

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:37
#, no-wrap
msgid ""
"~~~\n"
"$ cat hello.dats\n"
"val _void_ = print (\"Hello, world!\\n\")\n"
"implement main () = ()\n"
"$ atscc -o hello hello.dats\n"
"$ ./hello\n"
"Hello, world!\n"
"$ ldd hello | wc -l\n"
"3\n"
"$ nm hello | grep -c \" U \"\n"
"24\n"
"$ size hello\n"
"   text    data     bss     dec     hex filename\n"
"  21895     908     200   23003    59db hello\n"
"~~~\n"
msgstr ""
"~~~\n"
"$ cat hello.dats\n"
"val _ = print (\"Hello, world!\\n\")\n"
"implement main () = ()\n"
"$ atscc -o hello hello.dats\n"
"$ ./hello\n"
"Hello, world!\n"
"$ ldd hello | wc -l\n"
"3\n"
"$ nm hello | grep -c \" U \"\n"
"24\n"
"$ size hello\n"
"   text    data     bss     dec     hex filename\n"
"  21895     908     200   23003    59db hello\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:39
msgid "Ajhcの場合は16kBで、より小さいでゲソがATSも優秀じゃなイカ。"
msgstr "One compiled by Ajhc is 16kB, that is smaller than ATS's. However, ATS also has good feature for embedded system."

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:54
#, no-wrap
msgid ""
"~~~\n"
"$ cat Hello.hs\n"
"main = putStrLn \"Hello, world!\"\n"
"$ ajhc Hello.hs -o Hello\n"
"$ ./Hello\n"
"Hello, world!\n"
"$ ldd Hello | wc -l\n"
"3\n"
"$ nm Hello | grep -c \" U \"\n"
"19\n"
"$ size Hello\n"
"   text    data     bss     dec     hex filename\n"
"  14056    1337     528   15921    3e31 Hello\n"
"~~~\n"
msgstr ""
"~~~\n"
"$ cat Hello.hs\n"
"main = putStrLn \"Hello, world!\"\n"
"$ ajhc Hello.hs -o Hello\n"
"$ ./Hello\n"
"Hello, world!\n"
"$ ldd Hello | wc -l\n"
"3\n"
"$ nm Hello | grep -c \" U \"\n"
"19\n"
"$ size Hello\n"
"   text    data     bss     dec     hex filename\n"
"  14056    1337     528   15921    3e31 Hello\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:57
msgid ""
"とか書いてたら作者の [Hongwei Xi](http://www.cs.bu.edu/~hwxi/)  からツッコミ"
"が入ってATS2はもっと効率が良いそうでゲソ。"
msgstr "...While writing this article, [Hongwei Xi](http://www.cs.bu.edu/~hwxi/) said that ATS2 has move effective feature."

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:75
#, no-wrap
msgid ""
"~~~\n"
"$ cat hello.dats\n"
"implement\n"
"main0 () = {\n"
"  val () = println! (\"Hello world!\")\n"
"}\n"
"$ patscc -o hello hello.dats\n"
"$ ./hello\n"
"Hello world!\n"
"$ ldd hello | wc -l\n"
"3\n"
"$ nm hello | grep -c \" U \"\n"
"6\n"
"$ size hello\n"
"   text    data     bss     dec     hex filename\n"
"   3473     724      32    4229    1085 hello\n"
"~~~\n"
msgstr ""
"~~~\n"
"$ cat hello.dats\n"
"implement\n"
"main0 () = {\n"
"  val () = println! (\"Hello world!\")\n"
"}\n"
"$ patscc -o hello hello.dats\n"
"$ ./hello\n"
"Hello world!\n"
"$ ldd hello | wc -l\n"
"3\n"
"$ nm hello | grep -c \" U \"\n"
"6\n"
"$ size hello\n"
"   text    data     bss     dec     hex filename\n"
"   3473     724      32    4229    1085 hello\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:79
msgid ""
"しかも [Computer Language Benchmarks Gameでは最悪でもC言語の2倍程度の遅さ]"
"(http://benchmarksgame.alioth.debian.org/u64/benchmark.php?"
"test=all&lang=ats&lang2=gcc&data=u64)  じゃなイカ。つまり速いってことでゲソ!"
msgstr "Furthermore, [ATS is two times slower than C langugage at worst (on Computer Language Benchmarks Game)](http://benchmarksgame.alioth.debian.org/u64/benchmark.php?test=all&lang=ats&lang2=gcc&data=u64). That is to say ATS is fast!"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:84
msgid ""
"ところがこのATS言語、日本語の情報はほとんど見つからなかったでゲソ。。。 まず"
"は [ML programmer's guide to ATS - liulk @ cs-people](http://cs.likai.org/"
"ats/ml-programmers-guide-to-ats)  を翻訳してATS言語の使い方をマスターするでゲ"
"ソ!"
msgstr "However, any infomation about the ATS lanugage aren't found in Japan... At beginning, let's try to translate [ML programmer's guide to ATS - liulk @ cs-people](http://cs.likai.org/ats/ml-programmers-guide-to-ats) into Japanese, to become ATS kung-fu. De-gesso!"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:85 posts/2013-01-12-jhc_manual_ja.md:34
#, no-wrap
msgid "---------------------------------------\n"
msgstr "---------------------------------------\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:92
msgid ""
"今後はATS言語関連の翻訳をgithubリポジトリに集約します。 そのため、このブログ"
"の翻訳は修正されません。 最新の翻訳結果は [https://github.com/jats-ug/"
"translate/blob/master/Web/cs.likai.org/ats/ml-programmers-guide-to-ats.md]"
"(https://github.com/jats-ug/translate/blob/master/Web/cs.likai.org/ats/ml-"
"programmers-guide-to-ats.md)  を参照してください。"
msgstr "This blog post will not be refreshed, because I decided to put any translation about ATS into github repository. Please see [https://github.com/jats-ug/translate/blob/master/Web/cs.likai.org/ats/ml-programmers-guide-to-ats.md](https://github.com/jats-ug/translate/blob/master/Web/cs.likai.org/ats/ml-programmers-guide-to-ats.md)."

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:94
msgid "# MLプログラマ向けATS言語ガイド"
msgstr "# MLプログラマ向けATS言語ガイド"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:97
msgid ""
"このガイドではATS (Applied Type System) でのプログラミング作法を解説はしませ"
"ん。 それでも、熟練のMLプログラマであればすぐにATSの用語を理解してATSのコード"
"を読み始めることができると思います。"
msgstr "このガイドではATS (Applied Type System) でのプログラミング作法を解説はしません。 それでも、熟練のMLプログラマであればすぐにATSの用語を理解してATSのコードを読み始めることができると思います。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:99
msgid "## ATSのすばらしき世界"
msgstr "## ATSのすばらしき世界"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:101
msgid ""
"ATSでは、3つの世界でプログラミングをすることを覚えておくと良いでしょう。"
msgstr "ATSでは、3つの世界でプログラミングをすることを覚えておくと良いでしょう。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:105
msgid ""
"Dynamics(動的な世界): プログラムを実行した時に評価される部分です。これは既存"
"のプログラミング言語に馴染んだプログラマにとってもっとも親しみ深い部分でしょ"
"う。"
msgstr "Dynamics(動的な世界): プログラムを実行した時に評価される部分です。これは既存のプログラミング言語に馴染んだプログラマにとってもっとも親しみ深い部分でしょう。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:105
msgid ""
"Proofs(証明): 動的な特性を静的な特性に結びつけます。Proofs(証明)はプログラム"
"の動的な部分と考えることができます。しかし証明はコンパイル後では消滅してしま"
"い、実行時には存在しません。コンパイラはあなたが書いた証明を検査し、動作可能"
"なコードを生成する前に削除するのです。"
msgstr "Proofs(証明): 動的な特性を静的な特性に結びつけます。Proofs(証明)はプログラムの動的な部分と考えることができます。しかし証明はコンパイル後では消滅してしまい、実行時には存在しません。コンパイラはあなたが書いた証明を検査し、動作可能なコードを生成する前に削除するのです。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:105
msgid ""
"Statics(静的な世界): 型検査時にコンパイラによって評価される部分です。静的な部"
"分では静的な式の評価は常に終了しなければなりません。そのため型検査は決定可能"
"です。"
msgstr "Statics(静的な世界): 型検査時にコンパイラによって評価される部分です。静的な部分では静的な式の評価は常に終了しなければなりません。そのため型検査は決定可能です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:110
msgid ""
"ATSの前身であるDependent MLでは、静的な世界からは依存型を通して動的な世界を見"
"るしかありませんでした。 動的なそれぞれの式は静的な式によって指定された型を"
"持っています。 静的な制約は静的な式の集合によって形成され、 型検査はそれらの"
"制約が充足可能であるかどうか調べます。"
msgstr "ATSの前身であるDependent MLでは、静的な世界からは依存型を通して動的な世界を見るしかありませんでした。 動的なそれぞれの式は静的な式によって指定された型を持っています。 静的な制約は静的な式の集合によって形成され、 型検査はそれらの制約が充足可能であるかどうか調べます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:117
msgid ""
"ATSは依存型に加えて証明を使うことができ、 静的な世界をより強く動的な世界に関"
"与させることができます。 プログラマが動的な式と対応する証明の項を混じり合って"
"書くことができるのです。 証明はpropと呼ばれるclassical propositions(古典論理)"
"や、 viewと呼ばれるlinear propositions(linear logic)(線形論理)  のどちらかを"
"取ります。"
msgstr "ATSは依存型に加えて証明を使うことができ、 静的な世界をより強く動的な世界に関与させることができます。 プログラマが動的な式と対応する証明の項を混じり合って書くことができるのです。 証明はpropと呼ばれるclassical propositions(古典論理)や、 viewと呼ばれるlinear propositions(linear logic)(線形論理)  のどちらかを取ります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:122
msgid ""
"Prologに馴染んだ人にとっては、propを定義するのはPrologの述語を定義することと"
"よく似ています。 しかし、型検査は自動的にその述語の解決をしてくれません。 プ"
"ログラムを記述するのと同じように、証明も手動で書き下す必要があります。 証明の"
"記述をすることで、ATSを証明器として使うことができます。"
msgstr "Prologに馴染んだ人にとっては、propを定義するのはPrologの述語を定義することとよく似ています。 しかし、型検査は自動的にその述語の解決をしてくれません。 プログラムを記述するのと同じように、証明も手動で書き下す必要があります。 証明の記述をすることで、ATSを証明器として使うことができます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:126
msgid ""
"最後に、動的な世界と静的な世界の分離については 「動的な項の種は静的な種によっ"
"て特徴づけられる」 と考えることもできます。"
msgstr "最後に、動的な世界と静的な世界の分離については 「動的な項の種は静的な種によって特徴づけられる」 と考えることもできます。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:130
msgid "プログラムの項はtypeによって特徴づけられる"
msgstr "プログラムの項はtypeによって特徴づけられる"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:130
msgid "線形論理による証明の項はviewによって特徴づけられる"
msgstr "線形論理による証明の項はviewによって特徴づけられる"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:130
msgid "古典論理による証明の項はpropによって特徴づけられる"
msgstr "古典論理による証明の項はpropによって特徴づけられる"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:132
msgid "### ノート: 線形論理(Linear Logic)について"
msgstr "### ノート: 線形論理(Linear Logic)について"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:137
msgid ""
"線形論理は、弱化規則と縮約規則という構造規則を許可しないという点で古典論理と"
"異なります。 弱化規則は事実(fact)を与えて未使用のままに放置させません。 縮約"
"規則は事実を複数回使用することを許しません。 つまり、事実はきっちり一度だけし"
"か使えないのです。"
msgstr "線形論理は、弱化規則と縮約規則という構造規則を許可しないという点で古典論理と異なります。 弱化規則は事実(fact)を与えて未使用のままに放置させません。 縮約規則は事実を複数回使用することを許しません。 つまり、事実はきっちり一度だけしか使えないのです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:140
msgid ""
"viewはその意味では線形論理です。 一般にviewの証明は、リソースの所有の追跡やリ"
"ソースの状態の更新に使われます。"
msgstr "viewはその意味では線形論理です。 一般にviewの証明は、リソースの所有の追跡やリソースの状態の更新に使われます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:142
msgid "## 拡張子"
msgstr "## 拡張子"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:144
msgid "ATSで用いられるファイルはいくつかの拡張子を持っています。"
msgstr "ATSで用いられるファイルはいくつかの拡張子を持っています。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:149
msgid ""
".datsファイルは動的と静的な宣言を格納します。これはSMLにおけるモジュールシス"
"テムのstructureやOCamlの.mlファイルに似ています。"
msgstr ".datsファイルは動的と静的な宣言を格納します。これはSMLにおけるモジュールシステムのstructureやOCamlの.mlファイルに似ています。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:149
msgid ""
".satsファイルは静的な宣言を格納します。これはSMLにおけるモジュールシステムの"
"signatureやOCamlの.mliファイルに似ています。"
msgstr ".satsファイルは静的な宣言を格納します。これはSMLにおけるモジュールシステムのsignatureやOCamlの.mliファイルに似ています。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:149
msgid ".catsファイルは.satsファイルから使われるC言語コードを格納します。"
msgstr ".catsファイルは.satsファイルから使われるC言語コードを格納します。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:149
msgid ""
".hatsファイルは動的もしくは静的なATSコードを格納します。これらは.satsもしく"
"は.datsファイルからインクルードすることができます。"
msgstr ".hatsファイルは動的もしくは静的なATSコードを格納します。これらは.satsもしくは.datsファイルからインクルードすることができます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:151
msgid ""
".datsファイルと.satsファイルの特筆すべき違いは、関数と値のシグニチャ宣言で"
"す。"
msgstr ".datsファイルと.satsファイルの特筆すべき違いは、関数と値のシグニチャ宣言です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:158
msgid ""
"~~~ {.ocaml} (* .datsファイル *)  extern val c: int extern fun foo (x:int): "
"int fun bar (x: int): int = ...  ~~~"
msgstr "~~~ {.ocaml} (* .datsファイル *)  extern val c: int extern fun foo (x:int): int fun bar (x: int): int = ...  ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:165
msgid ""
"~~~ {.ocaml} (* .satsファイル *)  val c: int fun foo (x:int): int (* foo関数"
"の実体を宣言できません *)  ~~~"
msgstr "~~~ {.ocaml} (* .satsファイル *)  val c: int fun foo (x:int): int (* foo関数の実体を宣言できません *)  ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:168
msgid ""
"けれども典型的には.satsファイルでは関数の型を定義して、.datsファイルに実装を"
"書きます。 そのような場合、.datsファイルの実装には型注釈は不要です。"
msgstr "けれども典型的には.satsファイルでは関数の型を定義して、.datsファイルに実装を書きます。 そのような場合、.datsファイルの実装には型注釈は不要です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:173
msgid "~~~ {.ocaml} (* .datsファイル *)  implement baz (x) = ...  ~~~"
msgstr "~~~ {.ocaml} (* .datsファイル *)  implement baz (x) = ...  ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:178
msgid "~~~ {.ocaml} (* .satsファイル *)  fun baz (x:int): int ~~~"
msgstr "~~~ {.ocaml} (* .satsファイル *)  fun baz (x:int): int ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:182
msgid ""
"重要なことですが、MLと異なり、ATSの型検査器はとても限定された型推論しか行ない"
"ません。 あなたは明示的に十分な型注釈を与える必要があります。 そうすればATSは"
"型の導出できるようになるでしょう。"
msgstr "重要なことですが、MLと異なり、ATSの型検査器はとても限定された型推論しか行ないません。 あなたは明示的に十分な型注釈を与える必要があります。 そうすればATSは型の導出できるようになるでしょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:184
msgid "## めくるめく静"
msgstr "## めくるめく静"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:187
msgid "ATSはMLに少し似ています。 型とデータ型を定義することができます。"
msgstr "ATSはMLに少し似ています。 型とデータ型を定義することができます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:196
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"typedef t = int\n"
"typedef pair (a:type, b:type) = '(a, b)\n"
"datatype option (a:type) =\n"
"  | Some(a) of a\n"
"  | None(a)\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"typedef t = int\n"
"typedef pair (a:type, b:type) = '(a, b)\n"
"datatype option (a:type) =\n"
"  | Some(a) of a\n"
"  | None(a)\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:205
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* SML *)\n"
"type t = int\n"
"type ('a, 'b) pair = 'a * 'b\n"
"datatype 'a option =\n"
"    Some of 'a\n"
"  | None\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* SML *)\n"
"type t = int\n"
"type ('a, 'b) pair = 'a * 'b\n"
"datatype 'a option =\n"
"    Some of 'a\n"
"  | None\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:212
msgid ""
"上記のSMLコードでは、定義済みのint型があったとき、 新しいtという名前の型をint"
"型の別名として定義しています。 また、いくつかの型変数をパラメータとして取るよ"
"うな型を別名として定義できます。 さらに型変数aをパラメータとして取るoptionと"
"いうデータ型も定義しています。 これらの識別子はすべて静的な識別子です。 対し"
"て、動的な識別子というのは実行時の値になります。"
msgstr "上記のSMLコードでは、定義済みのint型があったとき、 新しいtという名前の型をint型の別名として定義しています。 また、いくつかの型変数をパラメータとして取るような型を別名として定義できます。 さらに型変数aをパラメータとして取るoptionというデータ型も定義しています。 これらの識別子はすべて静的な識別子です。 対して、動的な識別子というのは実行時の値になります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:218
msgid ""
"一方ATSでは、データ型のコンストラクタに型変数を明示的に適用してやる必要がある"
"ことに注意してください。 データ型に関する詳細な情報は [Datatypes in the ATS "
"tutorial](http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/datatypes."
"html)  を参照してくだっさい。 しかし、まずはこの章の残りを読んでからでも良い"
"でしょう。"
msgstr "一方ATSでは、データ型のコンストラクタに型変数を明示的に適用してやる必要があることに注意してください。 データ型に関する詳細な情報は [Datatypes in the ATS tutorial](http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/datatypes.html)  を参照してくだっさい。 しかし、まずはこの章の残りを読んでからでも良いでしょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:222
msgid ""
"型宣言は静的な識別子を\"type\"という種の静的な式に割り付けます。 つまり"
"typedefはstadefの特殊形です。 次に示す2つの静的な宣言はほぼ同じです。"
msgstr "型宣言は静的な識別子を\"type\"という種の静的な式に割り付けます。 つまりtypedefはstadefの特殊形です。 次に示す2つの静的な宣言はほぼ同じです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:230
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (1) *)\n"
"(* sta t:type *)\n"
"typedef t = int\n"
"typedef pair (a:type, b:type) =\n"
"  '(a, b)\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (1) *)\n"
"(* sta t:type *)\n"
"typedef t = int\n"
"typedef pair (a:type, b:type) =\n"
"  '(a, b)\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:238
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (2) *)\n"
"(* sta t:_ *)\n"
"stadef t = int\n"
"stadef pair (a:type, b:type) =\n"
"  '(a, b)\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (2) *)\n"
"(* sta t:_ *)\n"
"stadef t = int\n"
"stadef pair (a:type, b:type) =\n"
"  '(a, b)\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:241
msgid ""
"この2つが違うのはtypedefがtが種\"type\"であることを保証するのに対して、 "
"stadefは何も保証しないという点です。"
msgstr "この2つが違うのはtypedefがtが種\"type\"であることを保証するのに対して、 stadefは何も保証しないという点です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:244
msgid ""
"型は、静的な式や静的な識別子が取り得る数多くの種の内の一つです。 他の種として"
"は以下が挙げられます。"
msgstr "型は、静的な式や静的な識別子が取り得る数多くの種の内の一つです。 他の種としては以下が挙げられます。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:249
msgid "Ground種: int, bool, char, addrです。これらは依存型の土台になります。"
msgstr "Ground種: int, bool, char, addrです。これらは依存型の土台になります。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:249
msgid "View種: 線形論理の命題です。"
msgstr "View種: 線形論理の命題です。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:249
msgid "Prop種: 古典論理の命題です。"
msgstr "Prop種: 古典論理の命題です。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:249
msgid ""
"Viewtype種: 線形型です。これはType種とView種が結合したものに見えるかもしれま"
"せん。"
msgstr "Viewtype種: 線形型です。これはType種とView種が結合したものに見えるかもしれません。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:258
msgid ""
"datasortを使うことで新しい種を定義できます。 [sllist.dats](http://www.cs.bu."
"edu/~hwxi/academic/courses/CS520/Fall08/assignments/05/sllst_dats.html)  の最"
"初の数行はリストに似た種を定義する方法を示しています。 またsortdefを使えば種"
"の別名を定義できます。 これはサブセット種と呼ばれる種にpiggy-backな制約をつけ"
"ます。 [prelude/sortdef.sats](https://ats-lang.svn.sourceforge.net/svnroot/"
"ats-lang/trunk/prelude/sortdef.sats)  はその例です。 制約はシンプルなboolean"
"種の式です。"
msgstr "datasortを使うことで新しい種を定義できます。 [sllist.dats](http://www.cs.bu.edu/~hwxi/academic/courses/CS520/Fall08/assignments/05/sllst_dats.html)  の最初の数行はリストに似た種を定義する方法を示しています。 またsortdefを使えば種の別名を定義できます。 これはサブセット種と呼ばれる種にpiggy-backな制約をつけます。 [prelude/sortdef.sats](https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/prelude/sortdef.sats)  はその例です。 制約はシンプルなboolean種の式です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:260
msgid ""
"type, view, propの種について、別名定義、abstract quantityの宣言、代数的データ"
"のコンストラクタの宣言をすることができます。"
msgstr "type, view, propの種について、別名定義、abstract quantityの宣言、代数的データのコンストラクタの宣言をすることができます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:297
msgid ""
"<table border=\"1\" bordercolor=\"#888888\" cellspacing=\"0\" style=\"border-"
"color:rgb(136,136,136);border-width:1px;border-collapse:collapse\"> <tbody> "
"<tr> <td style=\"width:60px\"> </td> <td style=\"width:60px\">Static</td> "
"<td style=\"width:60px\">Type</td> <td style=\"width:60px\">View</td> <td "
"style=\"width:60px\">Prop</td> <td style=\"width:60px\">Viewtype</td> </tr> "
"<tr> <td>別名定義</td> <td>stadef</td> <td style=\"width:60px\">typedef</td> "
"<td>viewdef</td> <td>propdef</td> <td>viewtypedef</td> </tr> <tr> "
"<td>Abstract</td> <td>sta</td> <td>abstype</td> <td>absview</td> "
"<td>absprop</td> <td>absviewtype</td> </tr> <tr> <td style=\"width:60px\">代"
"数的</td> <td style=\"width:60px\">(N/A)</td> <td style=\"width:60px"
"\">datatype</td> <td style=\"width:60px\"><a href=\"http://www.ats-lang.org/"
"htdocs-old/TUTORIAL/contents/dataviews.html\">dataview</a></td> <td style="
"\"width:60px\"><a href=\"http://www.ats-lang.org/htdocs-old/TUTORIAL/"
"contents/dataprops.html\">dataprop</a></td> <td style=\"width:60px\"><a href="
"\"http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataviewtypes.html"
"\">dataviewtype</a></td> </tr> </tbody> </table>"
msgstr "<table border=\"1\" bordercolor=\"#888888\" cellspacing=\"0\" style=\"border-color:rgb(136,136,136);border-width:1px;border-collapse:collapse\"> <tbody> <tr> <td style=\"width:60px\"> </td> <td style=\"width:60px\">Static</td> <td style=\"width:60px\">Type</td> <td style=\"width:60px\">View</td> <td style=\"width:60px\">Prop</td> <td style=\"width:60px\">Viewtype</td> </tr> <tr> <td>別名定義</td> <td>stadef</td> <td style=\"width:60px\">typedef</td> <td>viewdef</td> <td>propdef</td> <td>viewtypedef</td> </tr> <tr> <td>Abstract</td> <td>sta</td> <td>abstype</td> <td>absview</td> <td>absprop</td> <td>absviewtype</td> </tr> <tr> <td style=\"width:60px\">代数的</td> <td style=\"width:60px\">(N/A)</td> <td style=\"width:60px\">datatype</td> <td style=\"width:60px\"><a href=\"http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataviews.html\">dataview</a></td> <td style=\"width:60px\"><a href=\"http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataprops.html\">dataprop</a></td> <td style=\"width:60px\"><a href=\"http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataviewtypes.html\">dataviewtype</a></td> </tr> </tbody> </table>"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:304
msgid ""
"type, view, prop, viewtypeはstatics(静的)の特殊形です。 つまり、typedef, "
"viewdef, propdef, viewtypedefの代わりに単にstadefを使うことができます。 同様"
"にabstractの宣言においてもabstype, absview, absprop, absviewtypeの代わりにsta"
"を使うことができます。 けれどもdatasort, datatype, dataview, dataprop, "
"dataviewtypeの間は交換することができません。 これらは新しい何かに対する代数的"
"なコンストラクタを定義します。 (例: datatypeは新しい型のコンストラクタです。"
"dataviewは新しいviewのコンストラクタです。などなど)"
msgstr "type, view, prop, viewtypeはstatics(静的)の特殊形です。 つまり、typedef, viewdef, propdef, viewtypedefの代わりに単にstadefを使うことができます。 同様にabstractの宣言においてもabstype, absview, absprop, absviewtypeの代わりにstaを使うことができます。 けれどもdatasort, datatype, dataview, dataprop, dataviewtypeの間は交換することができません。 これらは新しい何かに対する代数的なコンストラクタを定義します。 (例: datatypeは新しい型のコンストラクタです。dataviewは新しいviewのコンストラクタです。などなど)"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:307
msgid ""
"view, prop, viewtypeについて、ここでは取り上げません。 ここでは型とシンプルな"
"静的な式について注目しましょう。"
msgstr "view, prop, viewtypeについて、ここでは取り上げません。 ここでは型とシンプルな静的な式について注目しましょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:310
msgid ""
"静的な式は種によって検査される第一級の言語です。 いくつかの例を見てみましょ"
"う。"
msgstr "静的な式は種によって検査される第一級の言語です。 いくつかの例を見てみましょう。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:316
msgid "静的な式として書かれた数値は、種\"int\"の静的な数値になります"
msgstr "静的な式として書かれた数値は、種\"int\"の静的な数値になります"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:316
msgid ""
"ビルトインされた数値比較の述語があります。<, <=, >, >=, ==, <>は静的なシグニ"
"チャ\"(int, int) -> bool\"を持っています"
msgstr "ビルトインされた数値比較の述語があります。<, <=, >, >=, ==, <>は静的なシグニチャ\"(int, int) -> bool\"を持っています"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:316
msgid ""
"ビルトインされた論理積と論理和である&&, ||は静的なシグニチャ\"(bool, bool) -"
"> bool\"を持っています"
msgstr "ビルトインされた論理積と論理和である&&, ||は静的なシグニチャ\"(bool, bool) -> bool\"を持っています"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:316
msgid "0 <= 4 && 4 < 10 は種\"bool\"の静的な式です"
msgstr "0 <= 4 && 4 < 10 は種\"bool\"の静的な式です"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:316
msgid "一般的に、静的なnat_lt関数は次のように定義できます"
msgstr "一般的に、静的なnat_lt関数は次のように定義できます"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:322
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"stadef nat_lt (i: int, limit: int) =\n"
"  0 <= i && i < limit\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"stadef nat_lt (i: int, limit: int) =\n"
"  0 <= i && i < limit\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:325
msgid ""
"静的な関数であるnat_ltは、種boolが要求されればいつでも使うことができます。 例"
"えば、実行時に数値の引数の範囲に制約をつけたい場合を考えましょう。"
msgstr "静的な関数であるnat_ltは、種boolが要求されればいつでも使うことができます。 例えば、実行時に数値の引数の範囲に制約をつけたい場合を考えましょう。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:329
msgid ""
"ビルトインの静的な識別子intはオーバーロードされています。 種\"type\"と種"
"\"int -> type\"の2つの定義を持っています。二次的なintは依存型の数値で静的な式"
"によって指示されています。"
msgstr "ビルトインの静的な識別子intはオーバーロードされています。 種\"type\"と種\"int -> type\"の2つの定義を持っています。二次的なintは依存型の数値で静的な式によって指示されています。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:329
msgid "int(3) は種\"type\"の静的な式です"
msgstr "int(3) は種\"type\"の静的な式です"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:329
msgid ""
"ガードを使った存在記号を用いて、数値型を指定した範囲に制限することができま"
"す。"
msgstr "ガードを使った存在記号を用いて、数値型を指定した範囲に制限することができます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:335
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"typedef NatLt (n: int) =\n"
"  [i: int | nat_lt (i, n)] int(i)\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS *)\n"
"typedef NatLt (n: int) =\n"
"  [i: int | nat_lt (i, n)] int(i)\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:340
msgid ""
"これで静的な関数 NatLt: int -> type を定義できました。 静的な数値nを与えれ"
"ば、NatLtは 0 から n - 1 までの範囲を持つ数値型のサブセットとしての型を返しま"
"す。 NatLtの実装はこう読めるでしょう。 「種intであり、nat_lt(i, n)が真で、"
"int(i)型として生産されるのようなiが存在する。」"
msgstr "これで静的な関数 NatLt: int -> type を定義できました。 静的な数値nを与えれば、NatLtは 0 から n - 1 までの範囲を持つ数値型のサブセットとしての型を返します。 NatLtの実装はこう読めるでしょう。 「種intであり、nat_lt(i, n)が真で、int(i)型として生産されるのようなiが存在する。」"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:342
msgid "NatLt(n)型を使った関数は以下のようになるでしょう。"
msgstr "NatLt(n)型を使った関数は以下のようになるでしょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:347
msgid ""
"~~~ {.ocaml} (* ATS *)  fun digit_of_num (i: NatLt(10)): char = ...  ~~~"
msgstr "~~~ {.ocaml} (* ATS *)  fun digit_of_num (i: NatLt(10)): char = ...  ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:355
msgid ""
"ATS/Anariatsの中にビルトインされた多くの静的な演算子のシグニチャは [prelude/"
"basics_sta.sats](https://svn.code.sf.net/p/ats-lang/code/trunk/prelude/"
"basics_sta.sats)  で見ることができます。 stadefを使ってそのような演算子をオー"
"バーロードできることに注意してください。 中置の二項演算子の結合性は [prelude/"
"fixity.sats](https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/"
"prelude/fixity.ats)  で定義されています。"
msgstr "ATS/Anariatsの中にビルトインされた多くの静的な演算子のシグニチャは [prelude/basics_sta.sats](https://svn.code.sf.net/p/ats-lang/code/trunk/prelude/basics_sta.sats)  で見ることができます。 stadefを使ってそのような演算子をオーバーロードできることに注意してください。 中置の二項演算子の結合性は [prelude/fixity.sats](https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/prelude/fixity.ats)  で定義されています。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:357
msgid "## 異型(Atypical)の複合型"
msgstr "## 異型(Atypical)の複合型"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:365
msgid ""
"最初の区別は、 固定サイズの型はシンプルにtypeで表わされ、 任意サイズの型は"
"t@ypeで表わされるということです。 typeの値はポインタワードと同じサイズを持つ"
"という点でMLの値と似ています。 それはボックス化もしくはアンボックス化されてい"
"ます。 typeのボックス化された値はGCによって管理されたヒープの中に配置されま"
"す。 ボックス化された値のいくつかの例を見てみましょう。"
msgstr "最初の区別は、 固定サイズの型はシンプルにtypeで表わされ、 任意サイズの型はt@ypeで表わされるということです。 typeの値はポインタワードと同じサイズを持つという点でMLの値と似ています。 それはボックス化もしくはアンボックス化されています。 typeのボックス化された値はGCによって管理されたヒープの中に配置されます。 ボックス化された値のいくつかの例を見てみましょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:394
msgid ""
"<table border=\"1\"> <tbody> <tr> <td><font face=\"courier new,monospace"
"\"><b>type</b></font></td> <td>Expression</td> <td>Type </td> </tr> <tr> "
"<td>Tuple</td> <td>'(e<sub>1</sub>, e<sub>2</sub>, ... e<sub>n</sub>)</td> "
"<td>'(t<sub>1</sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> </tr> <tr> "
"<td>Record</td> <td>'{lab<sub>1</sub> = e<sub>1</sub>, lab<sub>2</sub> = "
"e<sub>2</sub>, ... lab<sub>n</sub>= e<sub>n</sub>}</td> <td>'{lab<sub>1</"
"sub> = t<sub>1</sub>, lab<sub>2</sub>= t<sub>2</sub>, ... lab<sub>n</sub>= "
"t<sub>n</sub>}</td> </tr> <tr> <td>List</td> <td>'[e<sub>1</sub>, e<sub>2</"
"sub>, ... e<sub>n</sub>]</td> <td>[n:int | n &gt;= 0] list(t, n)<br /> <br /"
"> (* もしくは以下に相当 *)<br /> List t<br /> </td> </tr> </tbody> </table>"
msgstr "<table border=\"1\"> <tbody> <tr> <td><font face=\"courier new,monospace\"><b>type</b></font></td> <td>Expression</td> <td>Type </td> </tr> <tr> <td>Tuple</td> <td>'(e<sub>1</sub>, e<sub>2</sub>, ... e<sub>n</sub>)</td> <td>'(t<sub>1</sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> </tr> <tr> <td>Record</td> <td>'{lab<sub>1</sub> = e<sub>1</sub>, lab<sub>2</sub> = e<sub>2</sub>, ... lab<sub>n</sub>= e<sub>n</sub>}</td> <td>'{lab<sub>1</sub> = t<sub>1</sub>, lab<sub>2</sub>= t<sub>2</sub>, ... lab<sub>n</sub>= t<sub>n</sub>}</td> </tr> <tr> <td>List</td> <td>'[e<sub>1</sub>, e<sub>2</sub>, ... e<sub>n</sub>]</td> <td>[n:int | n &gt;= 0] list(t, n)<br /> <br /> (* もしくは以下に相当 *)<br /> List t<br /> </td> </tr> </tbody> </table>"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:405
msgid ""
"けれどもMLの型はシステムプログラミングにとってあまりにも非力です。 メモリレイ"
"アウトをフラットな構造でしか表現できないのですから。 ここでt@ypeの値が役に立"
"ちます。 しばしば このようなメモリレイアウトはview(線形論理のリソース)とt@ype"
"を持つことがあります。 つまるところ、これがviewt@ypeと呼ばれます。 t@ypeは"
"viewt@ypeの下位種であることに注意してください。 そのためviewt@ypeと書かれてい"
"るところを単にt@ypeと書いても問題ありません。 それどころか、C言語と同じ意味を"
"持つ静的な関数である sizeof(t) が存在し、 それは以下に示す静的なシグニチャを"
"持っています。"
msgstr "けれどもMLの型はシステムプログラミングにとってあまりにも非力です。 メモリレイアウトをフラットな構造でしか表現できないのですから。 ここでt@ypeの値が役に立ちます。 しばしば このようなメモリレイアウトはview(線形論理のリソース)とt@ypeを持つことがあります。 つまるところ、これがviewt@ypeと呼ばれます。 t@ypeはviewt@ypeの下位種であることに注意してください。 そのためviewt@ypeと書かれているところを単にt@ypeと書いても問題ありません。 それどころか、C言語と同じ意味を持つ静的な関数である sizeof(t) が存在し、 それは以下に示す静的なシグニチャを持っています。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:410
msgid "~~~ {.ocaml} (* ATS *)  sta sizeof: viewt@ype -> int ~~~"
msgstr "~~~ {.ocaml} (* ATS *)  sta sizeof: viewt@ype -> int ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:412
msgid "そしてこのsizeof静的関数はt@ypeにもviewt@ypeにも使えるのです。"
msgstr "そしてこのsizeof静的関数はt@ypeにもviewt@ypeにも使えるのです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:414
msgid "ボックス化タプル, レコード, リストはフラットなtypeとよく似ています。"
msgstr "ボックス化タプル, レコード, リストはフラットなtypeとよく似ています。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:446
msgid ""
"<table border=\"1\"> <tbody> <tr> <td>種<br /> </td> <td><font face="
"\"courier new,monospace\"><b>type</b></font></td> <td><font face=\"courier "
"new,monospace\"><b>t@ype</b></font></td> </tr> <tr> <td>Tuple</td> "
"<td>'(t<sub>1</sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> <td>@(t<sub>1</"
"sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> </tr> <tr> <td>Record</td> "
"<td>'{lab<sub>1</sub> = t<sub>1</sub>, lab<sub>2</sub> = t<sub>2</sub>, ... "
"lab<sub>n</sub>= t<sub>n</sub>}</td> <td>@{lab<sub>1</sub> = t<sub>1</sub>, "
"lab<sub>2</sub>= t<sub>2</sub>, ... lab<sub>n</sub>= t<sub>n</sub>}</td> </"
"tr> <tr> <td>Sequence<br /> (List/Array)<br /> </td> <td>(* list *)<br /> "
"list(t, n)<br /> </td> <td>(* array *)<br /> @[t][n]<br /> </td> </tr> </"
"tbody> </table>"
msgstr "<table border=\"1\"> <tbody> <tr> <td>種<br /> </td> <td><font face=\"courier new,monospace\"><b>type</b></font></td> <td><font face=\"courier new,monospace\"><b>t@ype</b></font></td> </tr> <tr> <td>Tuple</td> <td>'(t<sub>1</sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> <td>@(t<sub>1</sub>, t<sub>2</sub>, ... t<sub>n</sub>)</td> </tr> <tr> <td>Record</td> <td>'{lab<sub>1</sub> = t<sub>1</sub>, lab<sub>2</sub> = t<sub>2</sub>, ... lab<sub>n</sub>= t<sub>n</sub>}</td> <td>@{lab<sub>1</sub> = t<sub>1</sub>, lab<sub>2</sub>= t<sub>2</sub>, ... lab<sub>n</sub>= t<sub>n</sub>}</td> </tr> <tr> <td>Sequence<br /> (List/Array)<br /> </td> <td>(* list *)<br /> list(t, n)<br /> </td> <td>(* array *)<br /> @[t][n]<br /> </td> </tr> </tbody> </table>"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:452
msgid ""
"しかしフラットな値を構築することは少し異なります。 フラットな値はヒープ(ボッ"
"クス化値と同じ)もしくはスタック(MLはスタックにデータ構造を確保しませんが)のど"
"ちらかに確保されます。 これについては別の記事 [Manipulating flat memory]"
"(http://cs.likai.org/ats/manipulating-flat-memory)  でお話しします。"
msgstr "しかしフラットな値を構築することは少し異なります。 フラットな値はヒープ(ボックス化値と同じ)もしくはスタック(MLはスタックにデータ構造を確保しませんが)のどちらかに確保されます。 これについては別の記事 [Manipulating flat memory](http://cs.likai.org/ats/manipulating-flat-memory)  でお話しします。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:459
msgid ""
"フラットなメモリを初期化しないこともできます。 \"t?\"という注釈は未初期化のメ"
"モリの型を表わしています。 そしてそのサイズはt型と同じです。 例えば、未初期化"
"のintは\"int?\"と書きます。(章末のノートを見てください)  しかし、型t1とt2につ"
"いて sizeof(t1) == sizeof(t2) であったとしても、 コンパイラはt1?とt2?を異なる"
"型として扱います。"
msgstr "フラットなメモリを初期化しないこともできます。 \"t?\"という注釈は未初期化のメモリの型を表わしています。 そしてそのサイズはt型と同じです。 例えば、未初期化のintは\"int?\"と書きます。(章末のノートを見てください)  しかし、型t1とt2について sizeof(t1) == sizeof(t2) であったとしても、 コンパイラはt1?とt2?を異なる型として扱います。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:466
msgid ""
"最後に、ときどきtype(およびviewtype)やt@ype(およびviewt@ype)の後ろに "
"'+'と'-'という注釈を目にすることがあるでしょう。 '+'はそのパラメータが共変性"
"であることを意味し、'-'はそのパラメータが反変性であることを意味しています。 "
"注釈がない場合には、パラメータは不変性です。 これは静的な式の型に対して下位種"
"を作るのに役に立ちます。 共変性は良く使われますが、反変性を使うことはまれで"
"す。"
msgstr "最後に、ときどきtype(およびviewtype)やt@ype(およびviewt@ype)の後ろに '+'と'-'という注釈を目にすることがあるでしょう。 '+'はそのパラメータが共変性であることを意味し、'-'はそのパラメータが反変性であることを意味しています。 注釈がない場合には、パラメータは不変性です。 これは静的な式の型に対して下位種を作るのに役に立ちます。 共変性は良く使われますが、反変性を使うことはまれです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:468
msgid "### ノート: intの型はフラット"
msgstr "### ノート: intの型はフラット"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:475
msgid ""
"読者をおどろかせるかもしれませんが、ATSにといてintはt@ypeです。 64ビットマシ"
"ンのC言語型であるintとlongを考えてみると、 intは32ビット、longは64ビット、そ"
"してポインタは64ビットです。 intはポインタと同じサイズではありません。 同様"
"に、ATSではlongもまたt@ypeです。 16ビットマシンの場合、intは16ビット、longは"
"32ビット、ポインタは16ビットであるからです。"
msgstr "読者をおどろかせるかもしれませんが、ATSにといてintはt@ypeです。 64ビットマシンのC言語型であるintとlongを考えてみると、 intは32ビット、longは64ビット、そしてポインタは64ビットです。 intはポインタと同じサイズではありません。 同様に、ATSではlongもまたt@ypeです。 16ビットマシンの場合、intは16ビット、longは32ビット、ポインタは16ビットであるからです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:477
msgid "## 落ち着かない関数たち"
msgstr "## 落ち着かない関数たち"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:480
msgid ""
"ATSでの関数の型の詳細は注意深く調査するべきでしょう。 その簡単な構成はMLと似"
"ていて、シンプルなものです。"
msgstr "ATSでの関数の型の詳細は注意深く調査するべきでしょう。 その簡単な構成はMLと似ていて、シンプルなものです。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:486
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name (x1: t1, ..., xn: tn): t' =\n"
"  \"c_name\"\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name (x1: t1, ..., xn: tn): t' =\n"
"  \"c_name\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:491
msgid ""
"~~~ {.ocaml} (* SML (signature) *)  val function_name: (t1 * ... * tn) -> t' "
"~~~"
msgstr "~~~ {.ocaml} (* SML (signature) *)  val function_name: (t1 * ... * tn) -> t' ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:495
msgid ""
"C言語に変換すると、function_nameはc_nameという名前になることに注意してくださ"
"い。 もっともこれは任意ですが。 これは以下のように使われます。"
msgstr "C言語に変換すると、function_nameはc_nameという名前になることに注意してください。 もっともこれは任意ですが。 これは以下のように使われます。"

#. type: Bullet: '1. '
#: posts/2013-12-23-ml_guide_to_ats.md:498
msgid "既存のC言語関数をATSにインポートして、ATSの型をつける"
msgstr "既存のC言語関数をATSにインポートして、ATSの型をつける"

#. type: Bullet: '2. '
#: posts/2013-12-23-ml_guide_to_ats.md:498
msgid "ATSで実装された関数をC言語側へエクスポートする"
msgstr "ATSで実装された関数をC言語側へエクスポートする"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:500
msgid "これはいくつかの重要な帰結を持ちます。"
msgstr "これはいくつかの重要な帰結を持ちます。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:504
msgid "ATSにおける関数の型はC言語の関数に直接写像されうる"
msgstr "ATSにおける関数の型はC言語の関数に直接写像されうる"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:504
msgid "ATSにおける関数は常にアンカリー化されている"
msgstr "ATSにおける関数は常にアンカリー化されている"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:504
msgid ""
"タグを指定しないかぎり、デフォルトでは関数はクロージャとして使えず、部分適用"
"も使えない (タグについては後に説明します)"
msgstr "タグを指定しないかぎり、デフォルトでは関数はクロージャとして使えず、部分適用も使えない (タグについては後に説明します)"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:506
msgid "依存型にガードとアサートを追加すれば、以下のようになります。"
msgstr "依存型にガードとアサートを追加すれば、以下のようになります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:514
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (x1: t1, ..., xn: tn):\n"
"    [exists quantifiers | asserts] t' =\n"
"  \"c_name\"\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (x1: t1, ..., xn: tn):\n"
"    [exists quantifiers | asserts] t' =\n"
"  \"c_name\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:519
msgid ""
"ガードはforall量化子の項で書くことができる種boolの静的な式です。 アサートは"
"forallとexists量化子の項で書くことができる種boolの静的な式です。 なおかつ、"
"t1 ... tn はforall量化子の項で書くことができる種typeの静的な式です。 そして"
"t'はforallとexists量化子の項で書くことができる種typeの静的な式です。"
msgstr "ガードはforall量化子の項で書くことができる種boolの静的な式です。 アサートはforallとexists量化子の項で書くことができる種boolの静的な式です。 なおかつ、t1 ... tn はforall量化子の項で書くことができる種typeの静的な式です。 そしてt'はforallとexists量化子の項で書くことができる種typeの静的な式です。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:521
msgid "証明の項をさらに追加してみましょう。"
msgstr "証明の項をさらに追加してみましょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:529
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (pf1: prop1, ..., pfp: propp | x1: t1, ..., xn: tn):\n"
"    [exists quantifiers | asserts] (prop'1, ..., prop'q | t') =\n"
"  \"c_name\"\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (pf1: prop1, ..., pfp: propp | x1: t1, ..., xn: tn):\n"
"    [exists quantifiers | asserts] (prop'1, ..., prop'q | t') =\n"
"  \"c_name\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:533
msgid ""
"アンカリー化された引数は、証明の変数とプログラムの変数の2つの部分に分断された"
"ことに注意してください。 証明の変数はコンパイルが完了すると削除されます。 プ"
"ログラムの変数はコンパイルされてもそのまま残ります。"
msgstr "アンカリー化された引数は、証明の変数とプログラムの変数の2つの部分に分断されたことに注意してください。 証明の変数はコンパイルが完了すると削除されます。 プログラムの変数はコンパイルされてもそのまま残ります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:535
msgid ""
"最後になりますが、ATSはタグとして副作用を追跡するためにアロー型を使います。"
msgstr "最後になりますが、ATSはタグとして副作用を追跡するためにアロー型を使います。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:544
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (pf1: prop1, ..., pfp: propp | x1: t1, ..., xn: tn)\n"
"  :<tag1, ..., tagk>\n"
"    [exists quantifiers | asserts] (prop'1, ..., prop'q | t') =\n"
"  \"c_name\"\n"
"~~~\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* ATS (.sats) *)\n"
"fun function_name\n"
"    {forall quantifiers | guards} (pf1: prop1, ..., pfp: propp | x1: t1, ..., xn: tn)\n"
"  :<tag1, ..., tagk>\n"
"    [exists quantifiers | asserts] (prop'1, ..., prop'q | t') =\n"
"  \"c_name\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:548
msgid ""
"もし関数の型を静的な式として書きたければ、 (これまで見てきた関数のシグニチャ"
"に反していますが)  型の表現は以下のようになるでしょう。"
msgstr "もし関数の型を静的な式として書きたければ、 (これまで見てきた関数のシグニチャに反していますが)  型の表現は以下のようになるでしょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:553
msgid ""
"~~~ {.ocaml} (* ATS (static expression) *)  {forall...} (prop1, ..., propp | "
"t1, ..., tn) -<tag1, ..., tagk> [exists...] (prop'1, ..., prop'q | t')  ~~~"
msgstr "~~~ {.ocaml} (* ATS (static expression) *)  {forall...} (prop1, ..., propp | t1, ..., tn) -<tag1, ..., tagk> [exists...] (prop'1, ..., prop'q | t')  ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:555
msgid "## タグ付きのアロー型"
msgstr "## タグ付きのアロー型"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:559
msgid ""
"ATSにおけるアロー型は\"-<>\"のような見た目をしています。 アロー型は -"
"\\<tag1, ..., tagk\\> のような形で装飾されます。 関数の様々な種を区別するため"
"に、現時点でATSは次のようなタグを解釈します。"
msgstr "ATSにおけるアロー型は\"-<>\"のような見た目をしています。 アロー型は -\\<tag1, ..., tagk\\> のような形で装飾されます。 関数の様々な種を区別するために、現時点でATSは次のようなタグを解釈します。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:565
msgid "prf: 証明関数 (型検査が終わると削除れます)"
msgstr "prf: 証明関数 (型検査が終わると削除れます)"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:565
msgid "lin: 確実に一度だけしか呼び出されない関数"
msgstr "lin: 確実に一度だけしか呼び出されない関数"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:565
msgid "fun: 通常の関数 (デフォルト)"
msgstr "fun: 通常の関数 (デフォルト)"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:565
msgid "cloptr: 明示的に解放されるべきクロージャ"
msgstr "cloptr: 明示的に解放されるべきクロージャ"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:565
msgid "cloref: GCされるクロージャ"
msgstr "cloref: GCされるクロージャ"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:567
msgid "同様に次のタグは副作用の追跡に用いられます。"
msgstr "同様に次のタグは副作用の追跡に用いられます。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:573
msgid "exn: 例外を起こす"
msgstr "exn: 例外を起こす"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:573
msgid "ntm: 終了しない可能性がある"
msgstr "ntm: 終了しない可能性がある"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:573
msgid "ref: グローバルメモリへの参照を共有している"
msgstr "ref: グローバルメモリへの参照を共有している"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:573
msgid "0: 副作用なし (純粋)"
msgstr "0: 副作用なし (純粋)"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:573
msgid "1: 副作用あり (判断できない場合も含まれる)"
msgstr "1: 副作用あり (判断できない場合も含まれる)"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:577
msgid ""
"副作用の有無を示すための表現である0や1の接尾辞を、関数の種を区別するタグに加"
"えて付けることができます。 例えば cloref1 は、MLのようにGC対象となるクロー"
"ジャであり、 副作用(例外発生など)を持っているというタグになります。"
msgstr "副作用の有無を示すための表現である0や1の接尾辞を、関数の種を区別するタグに加えて付けることができます。 例えば cloref1 は、MLのようにGC対象となるクロージャであり、 副作用(例外発生など)を持っているというタグになります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:579
msgid "## stdio.h から例を"
msgstr "## stdio.h から例を"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:582
msgid ""
"ATSにおける典型的な関数の宣言はどのような見た目になるのでしょうか？ ここで"
"は、次のプロトタイプ宣言を持つ標準Cライブラリを例に取りましょう。"
msgstr "ATSにおける典型的な関数の宣言はどのような見た目になるのでしょうか？ ここでは、次のプロトタイプ宣言を持つ標準Cライブラリを例に取りましょう。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:586
msgid "~~~ {.c} char *fgets(char *s, int size, FILE *stream); ~~~"
msgstr "~~~ {.c} char *fgets(char *s, int size, FILE *stream); ~~~"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:593
msgid ""
"manページには 「fgets()はstreamから最大で size - 1 個の文字を読み込み、sが指"
"すバッファに格納する。 '\\\\0'が一つバッファの中の最後の文字の後に書き込まれ"
"る。」 とあり、さらに 「fgets()は、成功するとsを返し、エラーや1文字も読み込ん"
"でいないのにファイルの終わりになった場合に NULL を返す。」 とあります。"
msgstr "manページには 「fgets()はstreamから最大で size - 1 個の文字を読み込み、sが指すバッファに格納する。 '\\\\0'が一つバッファの中の最後の文字の後に書き込まれる。」 とあり、さらに 「fgets()は、成功するとsを返し、エラーや1文字も読み込んでいないのにファイルの終わりになった場合に NULL を返す。」 とあります。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:595
msgid "ATSでの宣言を見てみましょう。コメントをたくさん入れてみました。"
msgstr "ATSでの宣言を見てみましょう。コメントをたくさん入れてみました。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:605
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"(* fgets_vはfgetsの結果である成功か失敗を表わします。\n"
" *)\n"
"dataview fgets_v (sz:int, addr, addr) =\n"
"  | (* 成功した場合、lアドレスは長さnの文字列を格納している\n"
"     * サイズszの文字列バッファでしょう。\n"
"     *)\n"
"    {n:nat | n < sz} {l:addr | l <> null}\n"
"      fgets_v_succ(sz, l, l) of strbuf(sz, n) @ l\n"
msgstr ""
"~~~ {.ocaml}\n"
"(* fgets_vはfgetsの結果である成功か失敗を表わします。\n"
" *)\n"
"dataview fgets_v (sz:int, addr, addr) =\n"
"  | (* 成功した場合、lアドレスは長さnの文字列を格納している\n"
"     * サイズszの文字列バッファでしょう。\n"
"     *)\n"
"    {n:nat | n < sz} {l:addr | l <> null}\n"
"      fgets_v_succ(sz, l, l) of strbuf(sz, n) @ l\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:609
#, no-wrap
msgid ""
"  | (* 失敗した場合、lアドレスは単にサイズszの空箱のはずです *)\n"
"    {l:addr}\n"
"      fgets_v_fail(sz, l, null) of bytes(sz) @ l\n"
msgstr ""
"  | (* 失敗した場合、lアドレスは単にサイズszの空箱のはずです *)\n"
"    {l:addr}\n"
"      fgets_v_fail(sz, l, null) of bytes(sz) @ l\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:615
#, no-wrap
msgid ""
"fun fgets\n"
"    (* countは読み込むバイト数です。\n"
"     * それはバッファのサイズであるsz以内でなければなりません。\n"
"     *)\n"
"    {count, sz:int | 0 < count; count <= sz}\n"
msgstr ""
"fun fgets\n"
"    (* countは読み込むバイト数です。\n"
"     * それはバッファのサイズであるsz以内でなければなりません。\n"
"     *)\n"
"    {count, sz:int | 0 < count; count <= sz}\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:618
#, no-wrap
msgid ""
"    (* fmはファイルモードのための静的な種です。 *)\n"
"    {m:fm}\n"
msgstr ""
"    (* fmはファイルモードのための静的な種です。 *)\n"
"    {m:fm}\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:621
#, no-wrap
msgid ""
"    (* lはバッファのアドレスを示す依存型です。 *)\n"
"    {l:addr}\n"
msgstr ""
"    (* lはバッファのアドレスを示す依存型です。 *)\n"
"    {l:addr}\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:636
#, no-wrap
msgid ""
"    ( (* ファイルモードが読み出しアクセスを含んでいることの証明。 *)\n"
"      pf_mod: file_mode_lte(m, r),\n"
"      (* szバイトの列がlに存在することに対する線形論理の証明。 *)\n"
"      pf_buf: bytes(sz) @ l\n"
"    | (* lアドレスによって指示されるポインタを引数に取る。 *)\n"
"      s: ptr(l),\n"
"      (* 読み込む最大のバイト数を引数に取る。  *)\n"
"      size: int(count),\n"
"      (* モードmによってオープンされたFILE構造体への参照を引数に取る。 *)\n"
"      stream: &FILE(m)\n"
"    )\n"
"  :<>\n"
"    (* l'は返値のポインタを指示します。 *)\n"
"    [l':addr]\n"
msgstr ""
"    ( (* ファイルモードが読み出しアクセスを含んでいることの証明。 *)\n"
"      pf_mod: file_mode_lte(m, r),\n"
"      (* szバイトの列がlに存在することに対する線形論理の証明。 *)\n"
"      pf_buf: bytes(sz) @ l\n"
"    | (* lアドレスによって指示されるポインタを引数に取る。 *)\n"
"      s: ptr(l),\n"
"      (* 読み込む最大のバイト数を引数に取る。  *)\n"
"      size: int(count),\n"
"      (* モードmによってオープンされたFILE構造体への参照を引数に取る。 *)\n"
"      stream: &FILE(m)\n"
"    )\n"
"  :<>\n"
"    (* l'は返値のポインタを指示します。 *)\n"
"    [l':addr]\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:647
#, no-wrap
msgid ""
"    ( (* pf_bufは消費され、ここでl'に一致する変化を形成します。 *)\n"
"      (* pf_buf is consumed, and this determines what it turns into\n"
"       * according to l'.\n"
"       *)\n"
"      fgets_v(sz, l, l')\n"
"    | (* l'で示すポインタを返します。 *)\n"
"      ptr(l')\n"
"    ) =\n"
"  \"fgets\"\n"
"~~~\n"
msgstr ""
"    ( (* pf_bufは消費され、ここでl'に一致する変化を形成します。 *)\n"
"      (* pf_buf is consumed, and this determines what it turns into\n"
"       * according to l'.\n"
"       *)\n"
"      fgets_v(sz, l, l')\n"
"    | (* l'で示すポインタを返します。 *)\n"
"      ptr(l')\n"
"    ) =\n"
"  \"fgets\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:654
msgid ""
"この例はATS/Anariatsの [libc/SATS/stdio.sats](https://svn.code.sf.net/p/ats-"
"lang/code/trunk/libc/SATS/stdio.sats)  を元にしています。 わずかな修正と多く"
"のコメントによる注釈が加えてあります。 はじめて見る人には明確には思えないかも"
"しれません。 いくつかポイントがあります。"
msgstr "この例はATS/Anariatsの [libc/SATS/stdio.sats](https://svn.code.sf.net/p/ats-lang/code/trunk/libc/SATS/stdio.sats)  を元にしています。 わずかな修正と多くのコメントによる注釈が加えてあります。 はじめて見る人には明確には思えないかもしれません。 いくつかポイントがあります。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:657
msgid ""
"実際のバッファサイズ(静的な変数sz)がfgets()が使用するサイズ(静的な変数count)"
"よりも大きいことを許可しています。これはlibc/SATS/stdio.satsにおけるfgetsで定"
"式化されています。しかしfgets()にバッファを全て使わないようには強制しません。"
msgstr "実際のバッファサイズ(静的な変数sz)がfgets()が使用するサイズ(静的な変数count)よりも大きいことを許可しています。これはlibc/SATS/stdio.satsにおけるfgetsで定式化されています。しかしfgets()にバッファを全て使わないようには強制しません。"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:657
msgid ""
"fgets()がNULLではない値を返す場合、以前と同じポインタを返さなければなりませ"
"ん。しかもそのポインタはstrbufによって解釈を与えれていて、文字列バッファはゼ"
"ロ終端されています。そうでない場合、同じく bytes(sz) @ l が返ります。fgets()"
"の結果の種別を見分ける唯一の方法は、if式でそのポインタがNULLであるのかチェッ"
"クすることです。もしあなたがチェックを見逃したら、型エラーになります。しかし"
"エラーのチェックに飽き飽きすることもあるでしょう。そんな時はlibc/SATS/stdio."
"satsで定義されている例外を使うバージョンであるfgets_exn()を使うこともできま"
"す。"
msgstr "fgets()がNULLではない値を返す場合、以前と同じポインタを返さなければなりません。しかもそのポインタはstrbufによって解釈を与えれていて、文字列バッファはゼロ終端されています。そうでない場合、同じく bytes(sz) @ l が返ります。fgets()の結果の種別を見分ける唯一の方法は、if式でそのポインタがNULLであるのかチェックすることです。もしあなたがチェックを見逃したら、型エラーになります。しかしエラーのチェックに飽き飽きすることもあるでしょう。そんな時はlibc/SATS/stdio.satsで定義されている例外を使うバージョンであるfgets_exn()を使うこともできます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:659
msgid "参考のために、上記のコードからコメントを削除したものを載せておきます。"
msgstr "参考のために、上記のコードからコメントを削除したものを載せておきます。"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:666
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"dataview fgets_v (sz:int, addr, addr) =\n"
"  | {n:nat | n < sz} {l:addr | l <> null}\n"
"      fgets_v_succ(sz, l, l) of strbuf(sz, n) @ l\n"
"  | {l:addr}\n"
"      fgets_v_fail(sz, l, null) of bytes(sz) @ l\n"
msgstr ""
"~~~ {.ocaml}\n"
"dataview fgets_v (sz:int, addr, addr) =\n"
"  | {n:nat | n < sz} {l:addr | l <> null}\n"
"      fgets_v_succ(sz, l, l) of strbuf(sz, n) @ l\n"
"  | {l:addr}\n"
"      fgets_v_fail(sz, l, null) of bytes(sz) @ l\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:675
#, no-wrap
msgid ""
"fun fgets\n"
"    {n, sz:int | 0 < n; n <= sz} {m:fm} {l:addr} (\n"
"      pf_mod: file_mode_lte(m, r), pf_buf: bytes(sz) @ l\n"
"    | s: ptr(l), size: int(n), stream: &FILE(m))\n"
"  :<>\n"
"    [l':addr] (fgets_v(sz, l, l') | ptr(l')) =\n"
"  \"fgets\"\n"
"~~~\n"
msgstr ""
"fun fgets\n"
"    {n, sz:int | 0 < n; n <= sz} {m:fm} {l:addr} (\n"
"      pf_mod: file_mode_lte(m, r), pf_buf: bytes(sz) @ l\n"
"    | s: ptr(l), size: int(n), stream: &FILE(m))\n"
"  :<>\n"
"    [l':addr] (fgets_v(sz, l, l') | ptr(l')) =\n"
"  \"fgets\"\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-23-ml_guide_to_ats.md:677
msgid "## この文書のTODO"
msgstr "## この文書のTODO"

#. type: Bullet: '* '
#: posts/2013-12-23-ml_guide_to_ats.md:678
msgid "fn (再帰なし) と fun (再帰あり) の比較との終端の計測"
msgstr "fn (再帰なし) と fun (再帰あり) の比較との終端の計測"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:5
#, no-wrap
msgid ""
"title: Japan ATS User Group (JATS-UG)の発足とAjhcの今後について\n"
"description: ATSの日本語情報をまとめるポータルサイトを作ったでゲソ\n"
"tags: ats, translation, haskell, ajhc, jhc, netbsd\n"
"---\n"
msgstr ""
"title: Kickoff Japan ATS User Group (JATS-UG) and Ajhc's future plan\n"
"description: Build a portal site to pool infomation about ATS lanugage in Japanese\n"
"tags: ats, translation, haskell, ajhc, jhc, netbsd\n"
"---\n"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:10
msgid ""
"この記事は [Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://"
"qiita.com/advent-calendar/2013/theorem_prover)  の12/24(火曜)分じゃなイカ。"
msgstr "This article is a part of [Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/advent-calendar/2013/theorem_prover)."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:12
msgid "## Japan ATS User Group (JATS-UG) について"
msgstr "## What is Japan ATS User Group (JATS-UG)?"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:18
msgid ""
"突然でゲソが、[ATS言語](http://www.ats-lang.org/)に関しての日本語情報を集約す"
"る組織である、 \"Japan ATS User Group\" 略して \"JATS-UG\" ^[名前が [JAWS-UG "
"– AWS User Group – Japan](http://jaws-ug.jp/) のモロパクりですね。。。] を発"
"足することをここに宣言するでゲソ! このユーザグループのホームページは [http://"
"jats-ug.metasepi.org/](http://jats-ug.metasepi.org/) でゲソ。"
msgstr "We declare to build \"Japan ATS User Group (JATS-UG)\", to pool and discuss ATS infomation in Japanese! The web site is found at [http://jats-ug.metasepi.org/](http://jats-ug.metasepi.org/)."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:20
msgid "[![](/img/20131224_jats-ug_website.png)](http://jats-ug.metasepi.org/)"
msgstr "[![](/img/20131224_jats-ug_website.png)](http://jats-ug.metasepi.org/)"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:25
msgid ""
"現在このページではATS言語の概要説明と [翻訳ドキュメント置き場](https://"
"github.com/jats-ug/translate/blob/master/index.md)  へのリンクぐらいしかない"
"でゲソ。 とりあえず年内はドキュメント翻訳に力を入れたいと思っているでゲソ。"
msgstr "Today, the web page only has the summary of ATS language and the link to [translated documents](https://github.com/jats-ug/translate/blob/master/README.md). We will focus translating ATS documents into Japanese, through the end of this year."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:27
msgid "## なんでいきなりユーザーグループ？"
msgstr "## Why need the user group?"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:33
msgid ""
"最近ワシがATSを調べているのには理由があるのでゲソ。 現在我々がいるイテレー"
"ションは [Arafura](2013-01-09-design_arafura.html)  でゲソ。 このArafuraイテ"
"レーションで採用しているデザインは"
msgstr ""
"I have a motive to research around ATS language recently.\n"
"We are in [Arafura](2013-01-09-design_arafura.html) as the first iteration.\n"
"The Arafura design is:"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:35
msgid "「NetBSD kernelをAjhc Haskellコンパイラを用いてスナッチ設計する」"
msgstr "\"Rewrite NetBSD kernel using Ajhc Haskell compiler, with Snatch-driven development stype.\""

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:42
msgid ""
"だったでゲソ。 NetBSD kernelのデバイスドライバをAjhcでスナッチする環境がとと"
"のった今、 次のイテレーションの計画をオーバーラップして行なうべきでゲソ。 技"
"術探索は賭け事と似ていて分散投資した方が成功率が上がるため、 イテレーションは"
"短かくまわした方が効果的じゃなイカ？ 本当はまっとうなKPTなどをした方がいいで"
"ゲソが、現状の問題点は明らかでゲソ。"
msgstr "The next iteration should be planned in parallel, because we have the method to rewrite NetBSD kernel device drivers using Ajhc now. Research is similar to betting that has good result using diversified investment. Arafura iteration's problem is clear without any KPT (keep, problem, try) framework."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:49
msgid ""
"それはAjhcの開発に工数を取られすぎているという問題でゲソ。 Haskellを組み込み"
"応用するということ自体が既に挑戦であり、 その挑戦がある程度成功しないと製品化"
"のスタート地点に立てないのでゲソ。 しかもこのAjhcの開発にアップストリームであ"
"るJohnはほとんど工数を払えていないでゲソ。 さらにAjhcには組み込み応用するため"
"の技術的課題が山積しているじゃなイカ。 つまりProblemでゲソ。"
msgstr ""
"It's caused by much time to develop Ajhc.\n"
"Haskell for embedded is a big challenge in itself.\n"
"We need the challenge's success to attain the starting post to write kernel.\n"
"Furthermore, John as upstream author of jhc doesn't develop jhc actively.\n"
"There is many technical puzzles on ATS domain.\n"
"It's the \"Problem\"."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:56
msgid ""
"一方、スナッチ設計という手法については比較的うまくいっているでゲソ。 NetBSD "
"kernelに適用した結果はこのイテレーションでも完全に判明することはないでゲソ"
"が、 今のところ根本的欠陥は見つかっていないでゲソ。 NetBSD kernelの採用につい"
"てはまだなにもわからないでゲソが、 おそらく最初のイテレーションではどんな"
"kernelを使っても似たようなもんだと思うでゲソ。 つまり、この2つは明らかにKeep"
"じゃなイカ？"
msgstr ""
"On the other hand, Snatch-driven development method is relatively doing good.\n"
"Result fully-applying the method to NetBSD kernel will not be obtained in the first iteration.\n"
"However, We have found no underlying faults.\n"
"And we can't perfectly decide that using NetBSD kernel as base platform is good.\n"
"We think it causes same result while the other monolithic kernel is used.\n"
"That is to say that these are clearly \"Keep\"."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:66
msgid ""
"じゃあTryはなんでゲソ？ [昨日の記事](2013-12-23-ml_guide_to_ats.html)  に書い"
"たでゲソがATSはjhcと似たような特性を持っていて、 組み込み開発に適用することが"
"できそうでゲソ。 ところがこのATS、日本語の情報がまったくなく、さらには日本に"
"はコミュニティさえないようだったでゲソ。。。 埋もれておくにはもったいないコン"
"パイラなのにでゲソ! これはマズイじゃないか。 そこで、ワシがATSを勉強するつい"
"でに各種文書を翻訳して日本にATSコミュニティを築こうと思うのでゲソ。 これが次"
"のイテレーションを開始するために必要な最初のTryでゲソ。"
msgstr ""
"What is \"Try\"?\n"
"I wrote [the article](2013-12-23-ml_guide_to_ats.html), about ATS language has good behavior for embedded such like jhc.\n"
"However, there are no Japanese infomation about ATS, and no communities about ATS in Japan...\n"
"Things can't remain as they are.\n"
"Then, I would like to construct an ATS community in Japan, while I learn ATS language.\n"
"It's first \"Try\" to start our next iteration."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:68
msgid "## 一通のメール"
msgstr "## An E-mail"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:71
msgid ""
"そこーしているとATSの作者からメールが届いたじゃなイカ。 なになに？でゲソ。"
msgstr "While thinking such things, I got an E-mail from ATS language author."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:74
msgid "~~~ Date: Mon Dec 23 11:40 JST 2013"
msgstr ""
"~~~\n"
"Date: Mon Dec 23 11:40 JST 2013"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:76
msgid "Hi Metasepi-chan,"
msgstr "Hi Metasepi-chan,"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:78
msgid "I spent quite some time today browsing metasepi.org."
msgstr "I spent quite some time today browsing metasepi.org."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:85
msgid ""
"I am really interested in your Metasepi project, partly because I myself "
"wanted to implement NetBSD in ATS about 5 years ago. Unfortunately, I never "
"had time to get the project started as I needed to spend so much time on "
"ATS2. By the way, I had planned to use the very same approach which you call "
"\"Snatch\". I had also considered Minix but I chose NetBSD because it was a "
"real OS."
msgstr "I am really interested in your Metasepi project, partly because I myself wanted to implement NetBSD in ATS about 5 years ago. Unfortunately, I never had time to get the project started as I needed to spend so much time on ATS2. By the way, I had planned to use the very same approach which you call \"Snatch\". I had also considered Minix but I chose NetBSD because it was a real OS."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:91
msgid ""
"I think I know first-handedly the dilemma you are currently in.  On one "
"hand, you want to be able to fully focus on writing the kernel.  On the "
"other hand, you also need to add features to Ajhc constantly to address all "
"kinds of issues that keep popping up, which undoubtedly makes it very "
"difficult for you to focus."
msgstr "I think I know first-handedly the dilemma you are currently in.  On one hand, you want to be able to fully focus on writing the kernel.  On the other hand, you also need to add features to Ajhc constantly to address all kinds of issues that keep popping up, which undoubtedly makes it very difficult for you to focus."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:99
msgid ""
"I would highly recommend that you use ATS to implement NetBSD kernel.  "
"Unlike jhc, there is no semantics gap between ATS and C. In particular, they "
"both use the same native unboxed data representation.  Once you become "
"familiar with ATS, you can readily visualize the C code that your ATS source "
"is to be compiled into. ATS is truly an ideal language for the kind of "
"\"Snatch\" approach you want to take to re-write NetBSD. If you take the "
"lead, then I will be happy to \"chip in\" :)"
msgstr "I would highly recommend that you use ATS to implement NetBSD kernel.  Unlike jhc, there is no semantics gap between ATS and C. In particular, they both use the same native unboxed data representation.  Once you become familiar with ATS, you can readily visualize the C code that your ATS source is to be compiled into. ATS is truly an ideal language for the kind of \"Snatch\" approach you want to take to re-write NetBSD. If you take the lead, then I will be happy to \"chip in\" :)"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:104
msgid ""
"I also spent some time reading documentation on jhc. Personally, I feel that "
"there is simply too much uncertainty to use it in real kernel "
"implementation. Features like GC could make the kernel highly unpredictable, "
"scaring away potential users."
msgstr "I also spent some time reading documentation on jhc. Personally, I feel that there is simply too much uncertainty to use it in real kernel implementation. Features like GC could make the kernel highly unpredictable, scaring away potential users."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:111
msgid ""
"I think that we both believe C is the right language for systems "
"programming. The problem with C is that it is too difficult to write correct "
"C programs. ATS is designed to allow the programmer to correctly write the "
"kind of C programs he or she wanted to write in the first place. While jhc "
"generates C code, the kind of C code it generates may not be suited for "
"kernel. This is what I call a semantics gap."
msgstr "I think that we both believe C is the right language for systems programming. The problem with C is that it is too difficult to write correct C programs. ATS is designed to allow the programmer to correctly write the kind of C programs he or she wanted to write in the first place. While jhc generates C code, the kind of C code it generates may not be suited for kernel. This is what I call a semantics gap."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:116
msgid ""
"I write this message in the hope that we could join effort in doing "
"something that has not been done up to now: Writing a real kernel in "
"(largely) functional style that can truly deliever safety-wise as well as "
"performance-wise."
msgstr "I write this message in the hope that we could join effort in doing something that has not been done up to now: Writing a real kernel in (largely) functional style that can truly deliever safety-wise as well as performance-wise."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:118
msgid "Cheers,"
msgstr "Cheers,"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:121
msgid "--Hongwei ~~~"
msgstr ""
"--Hongwei\n"
"~~~"

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:124
msgid ""
"なんかワシが言いたいことを全部先取りされてしまったでゲソ。 これも中国四千年の"
"重みという奴かもしれないじゃなイカ。"
msgstr ""
"Umm... What I want to say is preoccupied by him.\n"
"This may be caused by weight of long china history."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:141
msgid ""
"しかし、それでもjhcの先に未来がないということにはならないでゲソ。 ATSの型表現"
"は安全ではあっても、Haskellのように豊かではないでゲソ。 決定的なのは型クラス"
"の不在でゲソ。 Haskellの上でくりひろげられている非常に高階なプログラミング"
"は、 ATSを使っても実現できるとは思えないでゲソ。 つまり、高階な記述を使ったア"
"プリケーションにはATSはおそらく向いていないということじゃなイカ。 Haskellの問"
"題点は、その高階な表現を完全にGHCの実装に依存してしまっていることでゲソ。 GHC"
"が組み込みドメインで使えるようになる見込みはほぼゼロでゲソ。 じゃぁjhcはどー"
"なのカ？ というと今度はGHCの豊かな表現力の多くが通用しないのでゲソ。 つまり"
"jhcはATSのような記述をプログラマに強いるHaskell実装に現状なってしまっているの"
"でゲソ。 もしjhcの持つこの問題をいくばくかでも軽減できれば、Haskellの応用範囲"
"は劇的に広がることになるはずじゃなイカ。 問題は、誰がその膨大な工数を払うこと"
"ができるのか、ということでゲソ。 Johnのような天才でさえ擦り切れてしまう、この"
"あまりにも挑戦的な課題に誰が立ち向かうことができるのか。 言い方をかえれば、誰"
"がJohnの心をささえることができるのか。 それがHaskellの組み込み応用という分野"
"に高くそびえたつ冷たい壁なんじゃなイカ？"
msgstr ""
"Jhc Haskell compiler also has a good future.\n"
"ATS's type is safe, but not rich such like Haskell's.\n"
"Haskell has type class.\n"
"I think that ATS can't write code that has higher order representation such like Haskell.\n"
"That is to say, ATS may not be good to write application that use the representation.\n"
"Haskell's issue is that the representation strongly depends on GHC language implementation.\n"
"There is no future on GHC growing to be good for system programming.\n"
"On the other hand, how about jhc?\n"
"No, it's good for system programming, but can't use most of the representation.\n"
"So, jhc is currently Haskell implementation that imposes writing a code such like ATS's on programmer.\n"
"If the issue is relieved, we can dramatically expand Haskell language's application range.\n"
"Problem is who can pay huge man-hours to be needed for research/design/develop/debug them.\n"
"While even genius such as John gets tired, who can try to solve the challenging problem?\n"
"In another way, who can support John's mind?\n"
"That is, the [high-solid wall](http://www.haaretz.com/life/arts-leisure/always-on-the-side-of-the-egg-1.270371) on Haskell for embedded."

#. type: Plain text
#: posts/2013-12-24-jats-ug.md:145
msgid ""
"でもこれも前進に他ならないのでゲソ。 [のぼった日は沈み](http://www.youtube."
"com/watch?v=60tEEOWCdv8)、 [そして願わくばまた日の出の時刻に光が見えることを"
"信じて](http://www.utamap.com/showkasi.php?surl=B11852)。 メリークリスマス! "
"でゲソ。"
msgstr ""
"However, this should be a positive step.\n"
"[While seeing the sunset](https://www.youtube.com/watch?v=ZTe_jhynoCE),\n"
"[I belive having new sunlight tomorrow.](http://lyrics.wikia.com/%E6%9D%B1%E4%BA%AC%E4%BA%8B%E5%A4%89_%28Tokyo_Jihen%29:%E8%90%BD%E6%97%A5)\n"
"And, Merry Christmas! De-gesso."

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:5
#, no-wrap
msgid ""
"title: スタート! ATSプログラミング\n"
"description: マイコンATSプログラミングのお披露目でゲッソ\n"
"tags: meeting, ats, arduino\n"
"---\n"
msgstr ""
"title: Start! ATS programming\n"
"description: First try to run ATS code on tiny MCU\n"
"tags: meeting, ats, arduino\n"
"---\n"

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:13
msgid ""
"マイコンATSプログラミングのデモを [関数型LT大会](http://connpass.com/"
"event/5795/)  で披露したでゲソ。 今回はATSプログラミングの練習として、8ビット"
"のハーバード・アーキテクチャである [Arduino Mega 2560](http://arduino.cc/en/"
"Main/ArduinoBoardMega2560)  上で動くLチカデモをATS言語で書いてみたでゲソ。"
msgstr ""
"I demonstrated ATS code running on tiny MCU at [Functional lightning talk](http://connpass.com/event/5795/).\n"
"The demo blinks LED as my first ATS training, and runs on\n"
"[Arduino Mega 2560](http://arduino.cc/en/Main/ArduinoBoardMega2560)\n"
"that is 8-bit Harvard architecture."

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:19
msgid ""
"[発表スライドの7ページ目](http://www.slideshare.net/master_q/20140511-start-"
"ats/7)  でATS言語の位置付けをさっくり解説してみたのでゲソが、「ここは違うだ"
"ろ!」という意見もあるかもしれないじゃなイカ。 改善案があったらその理由と一緒"
"に [ワシまで連絡](https://twitter.com/masterq_mogumog)  してほしいでゲソー。"
msgstr ""
"[7th page of the slide](http://www.slideshare.net/master_q/20140511-start-ats/7)\n"
"explains where ATS language is positioned in functional languages.\n"
"I think someone has the other opinion.\n"
"If you have better idea, please [teach me](https://twitter.com/masterq_mogumog). De-gesso."

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:21 posts/2014-03-01-osc-tokyo.md:42
#: posts/2014-01-17-11th_wocs2.md:28 posts/2014-01-18-mbed_fest.md:48
#: posts/2014-01-05-mbed_fp_0.md:54 posts/2013-10-20-osc2013-tokyo.md:25
#: posts/2013-10-06-osc2013-hi.md:18 posts/2013-08-04-osckansai2013.md:16
#: posts/2013-11-24-osc-fukuoka-oita.md:22 posts/2013-09-16-osc2013-do.md:29
#: posts/2013-04-22-travel_in_kyoto-u.md:29 posts/2013-11-10-kof2013.md:19
msgid "## 発表資料"
msgstr "## Slide"

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:23
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/34529495\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-"
"width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </"
"iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www."
"slideshare.net/master_q/20140511-start-ats\" title=\"Start! ATS programming"
"\" target=\"_blank\">Start! ATS programming</a> </strong> from <strong><a "
"href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</"
"a></strong> </div>"
msgstr "<iframe src=\"http://www.slideshare.net/slideshow/embed_code/34529495\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/master_q/20140511-start-ats\" title=\"Start! ATS programming\" target=\"_blank\">Start! ATS programming</a> </strong> from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"

#. type: Plain text
#: posts/2014-05-11-functional_lt.md:25 posts/2014-03-01-osc-tokyo.md:56
msgid "## デモソースコード"
msgstr "## Demo source code"

#. type: Bullet: '* '
#: posts/2014-05-11-functional_lt.md:27
msgid ""
"[ATS programing on Arduino](https://github.com/fpiot/arduino-mega2560-ats)"
msgstr "[ATS programing on Arduino](https://github.com/fpiot/arduino-mega2560-ats)"

#. type: Bullet: '* '
#: posts/2014-05-11-functional_lt.md:27
msgid "[ATS programing on ChibiOS/RT](https://github.com/fpiot/chibios-ats)"
msgstr "[ATS programing on ChibiOS/RT](https://github.com/fpiot/chibios-ats)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:5
#, no-wrap
msgid ""
"title: めたせぴ2013☆ゆく年くる年\n"
"description: めたせぴ☆の今年一年を振り返って、来年の願望や妄想をするでゲソー\n"
"tags: haskell, ajhc, project\n"
"---\n"
msgstr ""
"title: Metasepi 2013: going year and comming year\n"
"description: Debrief Metasepi movement this year, and envision next year.\n"
"tags: haskell, ajhc, project\n"
"---\n"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:10
msgid ""
"この記事は [Haskell Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/"
"advent-calendar/2013/haskell)  の12/21(土曜)分じゃなイカ。"
msgstr "This article is a part of [Haskell Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/advent-calendar/2013/haskell)."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:17
msgid ""
"今年はワシにとって激動の年だったでゲソ。 Metasepiプロジェクトが本格的に稼動し"
"て、 [Ajhc Haskellコンパイラ](http://ajhc.metasepi.org/)  という最初の製品を"
"出荷できたでゲソ。 今年一年を振り返って、ついでに来年の願望や妄想をしてみなイ"
"カ？ また何をするのにどれぐらい工数がかかったのか覚えておくと後で役に立つかも"
"しれないでゲソ。"
msgstr ""
"This year is tumultuous one for us.\n"
"We started Metasepi project, and publish the first product as [Ajhc Haskell compiler](http://ajhc.metasepi.org/).\n"
"Let's debrief this year, and envision next year.\n"
"Also, it will be useful later remembering man-hour what is needed to do something."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:19
msgid "## 2012年12月"
msgstr "## December 2012"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:29
msgid ""
"去年何をしていたかというとGHCのランタイムの調査をしていたんじゃなイカ。 つま"
"り[C83 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c83.html)の記事の執筆で"
"ゲソ。 この調査の中でワシは組み込みドメインへのGHCの応用に深く絶望したんでゲ"
"ソ。。。 当時のワシの頭の中には関数型言語と言えばHaskellで、その処理系はGHCし"
"か読んだことがなかったのでゲソ。 型推論を持つ言語のランタイムがGHCの様なあり"
"さまでは、POSIXの外に出ることは不可能、、、 と思っていたとき偶然試した [Jhc "
"Haskell Compiler](http://repetae.net/computer/jhc/)  がとても小さなランタイム"
"を持つことを知ったのでゲソ。 これはいいじゃなイカ! とC83 λカ娘にはその希望だ"
"けにおわせておいたでゲソ。"
msgstr ""
"Last year, I surveyed GHC runtime internal.\n"
"That is, I write article for [Functional Ikamusume Book C83](http://www.paraiso-lang.org/ikmsm/books/c83.html).\n"
"I was deeply despairing of GHC application for embedded system, in this survey.\n"
"At the time, my experience reading language internal source code was only GHC.\n"
"If every language implementation having type inference was such like GHC,\n"
"I think it cannot be used out of POSIX.\n"
"However, I found [Jhc Haskell Compiler](http://repetae.net/computer/jhc/) by accident,\n"
"and knew the runtime is very small.\n"
"This is a good language implementation, isn't it?\n"
"I wrote some about jhc on Functional Ikamusume Book C83 article."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:33
msgid ""
"と、C83 λカ娘の記事が完成したその夜、突然 [めたせぴ☆ふぁうんでーしょんの序章]"
"(http://www.paraiso-lang.org/ikmsm/books/c84-sample.pdf)  の文章が頭に舞い降"
"りたんでゲソ。"
msgstr ""
"In the night worked up C83 article,\n"
"my head got [prologue of the article \"Measepi Foundation\"](http://www.paraiso-lang.org/ikmsm/books/c84-sample.pdf), like a shot."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:42
#, no-wrap
msgid ""
"~~~\n"
"$ pwd\n"
"/home/kiwamu/doc/IKMSM/C84\n"
"$ git log -p\n"
"--snip--\n"
"commit 7e43651b93631caa192bb7097126f9ce4735f060\n"
"Author: Kiwamu Okabe <kiwamu@debian.or.jp>\n"
"Date:   Mon Dec 24 18:37:54 2012 +0900\n"
msgstr ""
"~~~\n"
"$ pwd\n"
"/home/kiwamu/doc/IKMSM/C84\n"
"$ git log -p\n"
"--snip--\n"
"commit 7e43651b93631caa192bb7097126f9ce4735f060\n"
"Author: Kiwamu Okabe <kiwamu@debian.or.jp>\n"
"Date:   Mon Dec 24 18:37:54 2012 +0900\n"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:45
#, no-wrap
msgid ""
"    About metasepi.\n"
"~~~\n"
msgstr ""
"    About metasepi.\n"
"~~~\n"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:48
msgid ""
"すぐに記事の序章と結末だけ書いて、その間の文章を埋めるべくMetasepiの開発はス"
"タートしたんでゲソ。 まさしくDDD(同人誌 - ドリブン - デベロップメント)じゃな"
"イカ!"
msgstr ""
"I wrote prologue and epilogue of the article at once,\n"
"so Metasepi development was started to fill body of it.\n"
"It's exactly the DDD (Doujinshi Driven Development)."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:50 posts/2013-12-21-yuku-kuru.md:78
#: posts/2013-12-21-yuku-kuru.md:105 posts/2013-12-21-yuku-kuru.md:138
#: posts/2013-12-21-yuku-kuru.md:165 posts/2013-12-21-yuku-kuru.md:180
#: posts/2013-12-21-yuku-kuru.md:195 posts/2013-12-21-yuku-kuru.md:208
#: posts/2013-12-21-yuku-kuru.md:227 posts/2013-12-21-yuku-kuru.md:252
#: posts/2013-12-21-yuku-kuru.md:271 posts/2013-12-21-yuku-kuru.md:288
#: posts/2013-12-21-yuku-kuru.md:305
msgid "_やったことリスト_"
msgstr "_List of things done"

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:54
msgid ""
"[C84 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c84.html) の原稿作成開始"
msgstr "Start to write article for [Functional Ikamusume Book C84](http://www.paraiso-lang.org/ikmsm/books/c84.html)"

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:54
msgid "jhcのソースコード読み開始"
msgstr "Start to read source code of the jhc internal"

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:54
msgid ""
"[NetBSD bootloaderの一部をHaskell化](https://gitorious.org/metasepi/netbsd-"
"arafura/activities)できた"
msgstr "[Rewrite a part of NetBSD bootloader with Haskell](https://gitorious.org/metasepi/netbsd-arafura/activities)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:56
msgid ""
"[![若いころの John Meacham](http://repetae.net/pictures/me_tree_small.jpg)]"
"(http://repetae.net/)"
msgstr "[![John Meacham during his youth](http://repetae.net/pictures/me_tree_small.jpg)](http://repetae.net/)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:58
msgid "## 2013年1月"
msgstr "## January 2013"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:69
msgid ""
"ひたすらjhcをコネコネしているとなんとなくソースコードツリー詳細が見えてきたの"
"がこの頃でゲソ。 ドキュメントを全く読まずにこれ以上ソースを読んでも身にならな"
"いと気がついて [\\@dif_engine](https://twitter.com/dif_engine)さんに協力して"
"もらって [Jhc User's Manual](http://repetae.net/computer/jhc/manual.html)  を"
"日本語訳したでゲソ。 はっきり言ってこのドキュメントはコンパイラの利用者が読む"
"ものではなかったでゲソ! 後半にいくと型システムの説明になり、今でもワシは完全"
"には理解できていないでゲソ。。。 この日本語訳は今では [Ajhcのホームページの中"
"に置かれている](http://ajhc.metasepi.org/manual_ja.html)  でゲソ。"
msgstr ""
"In these days, I did nothing but touched jhc source code, and knew the design a little.\n"
"But I also understood it's not good to read the code without any documents,\n"
"and translated [Jhc User's Manual](http://repetae.net/computer/jhc/manual.html) into Japanese with \n"
"[\\@dif_engine](https://twitter.com/dif_engine)'s help.\n"
"Clearly, this document is not for jhc compiler user!\n"
"It explains the type system on latter half, and isn't perfectly understood by me today.\n"
"Today, the translated manual is found at [Ajhc website](http://ajhc.metasepi.org/manual_ja.html)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:76
msgid ""
"また、このころ「Haskell言語で少しずつC言語の設計を置換する」という設計手法を"
"思いつくでゲソ。 もちろん、OSの書かれたC言語のソースコードをHaskellで設計置換"
"するのに少しずつでうまくいく訳がないのでゲソ。 最も大きな問題はほとんどのコン"
"パイラがコンパイラの利用者が意図しても再入可能かコードを吐き出せない、つまり"
"割込みハンドラをHaskellによって記述できないからじゃなイカ。 しかしとにかくこ"
"こではjhcを成長させて再入可能にすることでC言語の設計置換に使えるコンパイラに"
"仕立て上げようということになったのでゲソ。 これ以降、この設計置換の手法を\"ス"
"ナッチ\"と呼び、Ajhcを使ったスナッチをNetBSDに対して適用するデザインを"
"\"Arafura\"と呼ばれることになるでゲソ。 Arafuraを実現するためのjhcの拡張、つ"
"まりarafura-jhcという名前にその後変遷することになるでゲソ。"
msgstr ""
"Also in these days, I got a idea to rewrite C language implementation using Haskell language little by little.\n"
"Of course, it's hardly possible that the kernel partly rewrited with Haskell can't run.\n"
"There is a big problem that most compiler of functional language can't handle reentrant code,\n"
"and can't write hardware interrupt handler with Haskell.\n"
"However, we decided to anyway build jhc into reentrant compiler,\n"
"as used to rewrite C language implementation.\n"
"After that, the design method is called \"Snatch\",\n"
"and the design that apply Snatch method with Ajhc to NetBSD kernel is called \"Arafura\".\n"
"An extension of jhc to make Arafura come true is called \"arafura-jhc\"."

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:81
msgid ""
"[Arafuraイテレーション](http://metasepi.org/posts/2013-01-09-design_arafura."
"html)開始"
msgstr "Start [Arafura iteration](http://metasepi.org/posts/2013-01-09-design_arafura.html)"

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:81
msgid ""
"[jhcユーザーズマニュアル日本語訳](http://metasepi.org/posts/2013-01-12-"
"jhc_manual_ja.html)"
msgstr "[Jhc User's Manual translated into Japanese](http://metasepi.org/posts/2013-01-12-jhc_manual_ja.html)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:83
msgid ""
"[![デザインArafura](/draw/2012-12-27-arafura_design.png)](http://metasepi."
"org/posts/2013-01-09-design_arafura.html)"
msgstr "[![Arafura design](/draw/2012-12-27-arafura_design.png)](http://metasepi.org/posts/2013-01-09-design_arafura.html)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:85
msgid "## 2013年2月"
msgstr "## February 2013"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:91
msgid ""
"この頃はフラストーレションがたまっていたでゲソ。 その原因は2つあったでゲソ。 "
"1つ目はMetasepiプロジェクトに関する説明会を開催したはよかったのでゲソが、 そ"
"の効果はほとんどなかったということでゲソ。 2つ目はjhcの作者であるJohnのメール"
"やpatchに対する反応が悪かったことでゲソ。"
msgstr ""
"In these days, I felt frustration.\n"
"There were two causes of it.\n"
"First, there were not any feedback,\n"
"while we had a briefing session about the Metasepi project.\n"
"Second, John Meacham didn't actively reply our mail and patch."

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:99
msgid ""
"しかし、そもそも他人に期待するのは間違っていたのでゲソ。 何に使えるかもわから"
"ないコンパイラとOSに興味を持つ訳がないのでゲソ。しかも、ワシの説明は絵空事に"
"しか見えないじゃなイカ。 そこでこの月以降はメモリが数百kB程度しかないマイコン"
"をターゲットにして、デモをひたすら作成することにしたでゲソ。 マイコンをター"
"ゲットにする理由はいくつかあるのでゲソが最も大きいかったのが 「他のHaskellコ"
"ンパイラでは絶対できない実現できない領域に安定した足場を築き、 そこから他の領"
"域に攻撃を仕掛ける」 という短期的な戦略でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:103
msgid ""
"またこの頃 [\\@dec9ue](https://twitter.com/dec9ue)  さんがjhcのGCを調査してく"
"れて、後々楽ができたでゲソ!"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:108
msgid ""
"[Metasepi作戦会議 第1回](http://metasepi.org/posts/2013-02-03-"
"kickoff_meeting.html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:108
msgid "[STBee Miniマイコンデモ](https://github.com/ajhc/demo-cortex-m3)作成"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:110
msgid ""
"[![STBee Miniマイコンボード](https://raw.github.com/ajhc/demo-cortex-m3/"
"master/img/stbee-mini-v2.jpg)](http://strawberry-linux.com/catalog/items?"
"code=32105)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:112
msgid "## 2013年3月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:118
msgid ""
"この月、ついに来るべきときが来たでゲソ。 あまりにもJohnの動きが遅いことにイラ"
"イラしていたワシはjhcをforkすることにしたでゲソ。 [[jhc] ANNOUNCE: Start "
"Ajhc project with forking jhc.](http://www.haskell.org/pipermail/jhc/2013-"
"March/001007.html)  という挑戦状のようなメールをたたきつけたじゃなイカ。 た"
"だ、後に判明することなのでゲソが、この時Johnが動けなかった理由の一つに会社の"
"法務から個人プロジェクトへ貢献をしらばれていたことがあったようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:126
msgid ""
"forkをしてまずはじめにやったことは[githubにリポジトリ](https://github.com/"
"ajhc/ajhc)を作ったことでゲソ。 なにを当たり前なと思うかもしれないでゲソがワシ"
"は強いGNU信者なので、 [Savannah](http://savannah.gnu.org/)  でリポジトリを管"
"理することを真剣に考えていたでゲソ。 しかしjhcの悪い点の一つに他人とのコラボ"
"レーションをしにくい開発体制があるでゲソ。 そこでgithubでのpull requestを受け"
"付けられるようにし、 さらに[できるだけカジュアルに見えるホームページ](http://"
"ajhc.metasepi.org/)をでっちあげたのでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:136
msgid ""
"Ajhcプロジェクトによってコンパイラ側にも大規模な修正ができるようになったの"
"で、 もうすこし凝ったマイコンのデモであるモールス信号のアプリをでっちあげるこ"
"とにしたでゲソ。 このアプリを書く時にAjhcのGCに様々な問題が見つかり、その修正"
"をしたでゲソ。 特に [GCの空間効率を最大化するオプション群](http://ajhc."
"metasepi.org/manual_ja.html#cflagsで指定できる特殊なdefine)  を作れたのは収穫"
"だったじゃなイカ。 もっとも、これらのオプションは1MB以下のメモリしか持たない"
"ようなアーキティクチャでのみ有効で、 おそらくUNIXモドキkernelでは使わない可能"
"性が高いでゲソが。。。 それでもこれからはIoTの時代らしいので、そんな要求には"
"有効でゲソ!"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:143
msgid "jhcをforkしてAjhcリポジトリを作った"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:143
msgid ""
"Ajhc 0.8.0.1, [0.8.0.2](http://www.haskell.org/pipermail/jhc/2013-"
"March/001028.html) リリース"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:143
msgid "Ajhcをcabalで管理しようと思いたつ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:143
msgid ""
"[マイコン用モールス信号アプリ](https://github.com/ajhc/demo-cortex-m3/blob/"
"master/stm32f3-discovery/hs_src/MainMorseCode.hs)作成"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:145
msgid ""
"[![stm32f3-discoveryマイコンボード](https://raw.github.com/ajhc/demo-cortex-"
"m3/master/img/stm32f3-discovery.jpg)](http://www.st.com/web/en/catalog/tools/"
"FM116/SC959/SS1532/PF254044)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:147
msgid "## 2013年4月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:155
msgid ""
"cabalを使ってAjhcをインストールできるようにしたでゲソ。 Johnはたいそう[cabal"
"が嫌い](http://www.haskell.org/pipermail/jhc/2013-March/001036.html)  で(気持"
"ちはわかるでゲソ)、GNU makeで何も問題がないと思っていたようでゲソが、 ワシと"
"してはAjhcというプロジェクトの宣伝目的のためだけにcabal対応をする価値はあるの"
"ではなイカと考えたでゲソ。 githubを使ってカジュアルな開発をするのと同じ理由、"
"つまり参入障壁を下げたかったんじゃなイカ。 本当はAjhc上で使うHaskellライブラ"
"リそのものもcabalで管理したかったんでゲソが、 GHCとAjhcでプリミティブの型や"
"baseライブラリの構造があまりにも異なるため、断念して今にいたるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:163
msgid ""
"また、この頃からMetasepiとAjhcを使って生計を立てられないか真剣に考えはじめた"
"でゲソ。 なにしろあまりにもゴールが巨大で遠くにあるため、継続的にフルタイムの"
"工数を投入できないと達成できる気がしなかったからでゲソ。。。 そこで、京都大学"
"に某申請を出したのでゲソが、残念ながら落選してしまったでゲソ。 しかしその時作"
"成した申請書は [Metasepiプロジェクトの5ヶ年計画](http://metasepi.org/"
"doc/20130508_5year_plan.pdf)  としてひきつがれることになるでゲソ。 しかもなん"
"とその計画の多くの部分を1年で達成することができたでゲソ。少し申請書の計画の見"
"積りが控え目すぎたんじゃなイカ？"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:169
msgid ""
"[Metasepi作戦会議 第2回](http://metasepi.org/posts/2013-04-22-"
"travel_in_kyoto-u.html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:169
msgid ""
"Ajhc [0.8.0.3](http://www.haskell.org/pipermail/jhc/2013-April/001047.html), "
"[0.8.0.4](https://github.com/ajhc/ajhc/blob/arafura/docs/announce_ajhc/"
"announce-0.8.0.4.md) リリース"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:169
msgid "[5ヶ年計画](http://metasepi.org/doc/20130508_5year_plan.pdf)を立てる"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:171
msgid "![](http://farm9.staticflickr.com/8545/8673977464_3207ce4538_m.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:173
msgid "## 2013年5月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:178
msgid ""
"[Jhc compile pipeline: Grin => C (code example) - Metasepi](http://metasepi."
"org/posts/2013-05-16-jhc_grin_to_c.html)  こんなドキュメントを書きながらコン"
"パイラパイプラインの調査をひたすらやっていた時期でゲソ。 また、Johnが作ってい"
"たリグレッションテストを掘りおこして、 [Travis-CI上でテスト](https://travis-"
"ci.org/ajhc/ajhc)するようにしたのもこのころでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:182
msgid "Travis-CI環境の改善"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:184
msgid ""
"[![](http://about.travis-ci.org/images/travis-mascot-200px.png)](http://"
"travis-ci.org/)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:186
msgid "## 2013年6月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:193
msgid ""
"この月、革新的な機能がAjhcに追加されたでゲソ! それは [\"再入可能\"](http://"
"metasepi.org/posts/2013-06-20-reentrant_jhc.html)  なバイナリを作成する機能で"
"ゲソ。 また、pthreadを使ったスレッドもAjhcにこのころ実装されたでゲソ。 これで"
"Ajhcの応用範囲はぐっと広がったじゃなイカ!"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:197
msgid ""
"Ajhc [0.8.0.5](http://www.haskell.org/pipermail/jhc/2013-June/001061.html), "
"[0.8.0.6](http://www.haskell.org/pipermail/jhc/2013-June/001062.html) リリー"
"ス"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:199
#, fuzzy
#| msgid "![](/draw/2012-12-27-arafura_design.png)"
msgid "![](/draw/20132013-12-21_arenalife.png)"
msgstr "![](/draw/2012-12-27-arafura_design.png)"

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:201
msgid "## 2013年7月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:206
msgid ""
"半年の間執筆していた[C84 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c84."
"html) の原稿がついに完成したでゲソ! 書き始めた当初はマイコンボードでHaskellが"
"動作すれば記事ができると思っていたでゲソ。 ところが半年がんばってみたらなんと"
"再入可能ヒープまで作ることができたでゲソ! これはもしかするとご飯作れるんじゃ"
"なイカ？と思い翌月から営業に出ることになるでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:212
msgid ""
"[C84 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c84.html) の原稿が完成"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:212
msgid ""
"[ChibiOS/RT上のアプリをHaskellで](https://github.com/metasepi/chibios-"
"arafura)書いてみようと思いたつ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:212
msgid ""
"Ajhc [0.8.0.7](http://www.haskell.org/pipermail/jhc/2013-July/001063.html) リ"
"リース"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:214
msgid ""
"[![簡約!? λカ娘 Go!](http://www.paraiso-lang.org/ikmsm/images/c84-cover-s."
"jpg)](http://www.paraiso-lang.org/ikmsm/books/c84.html)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:216
msgid "## 2013年8月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:221
msgid ""
"[NetBSDのエラい人](https://twitter.com/ebijun)からの入れ知恵で [オープンソー"
"スカンファレンス2013 Kansai@Kyoto](https://www.ospn.jp/osc2013-kyoto/)  には"
"じめてMetasepiプロジェクトとして展示してみたでゲソ。 この時にはマイコン上での"
"デモは安定して動いていたのでその展示をしてAjhcのことをみんなに知ってほしかっ"
"たんじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:225
msgid ""
"それから[\\@mzp](https://twitter.com/mzp)さんから[pull requestをもらった]"
"(https://github.com/ajhc/ajhc/pull/32)でゲソ! たいへん恥しいバグばかりを修正"
"してもらったでゲソが大助かり。 しかも短時間にワシが今まで読んだjhcの知識に"
"あっさり追い付いてくるとは、、、さすがは\"なごやこわい\"じゃなイカ？"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:231
msgid ""
"[Metasepi作戦会議 第3回](http://metasepi.org/posts/2013-08-04-osckansai2013."
"html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:231
msgid ""
"[mbedマイコンを使ったRSSリーダデモ](https://github.com/ajhc/demo-cortex-m3/"
"tree/master/mbed-nxp-lpc1768)作成開始"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:231
msgid ""
"[Android NDKサンプルアプリのスナッチ](https://github.com/ajhc/demo-android-"
"ndk)開始"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:233
msgid "![](http://farm8.staticflickr.com/7408/9432077241_5dc08517a7_n.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:235
msgid "## 2013年9月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:247
msgid ""
"いくらマイコンとはいえ、Lチカだけのデモでは寂しすぎるので、なにか実用っぽいデ"
"モを作ろうと思うじゃなイカ。 ワシとしては猫も杓子もネットワークにむらがってい"
"るのが好きになれないのでゲソが、ウケを狙ってTCP/IPプロトコルスタックを使った"
"デモを作ってみたでゲソ。 [reddit.com](http://www.reddit.com/)のRSSを取得して"
"LCDパネルに電光表示するRSSリーダアプリでゲソ。 このデモはmbedマイコンを使って"
"作成したでゲソ。 どーかんがえてもstm32マイコンを使った方が価格優位にあるので"
"ゲソが、mbedの方がブランド力が高いと判断して、ここではmbedを使ってみたでゲ"
"ソ。 たまたま[mbed祭り](http://atnd.org/events/41585)と[オープンソースカン"
"ファレンス2013 Hokkaido](http://www.ospn.jp/osc2013-do/)  が同時期に開催され"
"ていたので、このデモの展示をしてきたでゲソ。 ARM社のmbedの中の人である "
"[Simon Ford](http://mbed.org/users/simon/)  にも興味を持ってもらえてよかった"
"でゲソ。 お金にはなりそうもなかったでゲソが。。。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:250
msgid ""
"また、この月に裏で作業していたAndroid NDKのサンプルアプリのスナッチが完了した"
"でゲソ。 これでAndroid NDKアプリをHaskellで書く下地ができたじゃなイカ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:257
msgid ""
"[Metasepi作戦会議 第4回](http://metasepi.org/posts/2013-09-16-osc2013-do."
"html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:257
msgid ""
"[mbedマイコンを使ったRSSリーダデモ](https://github.com/ajhc/demo-cortex-m3/"
"tree/master/mbed-nxp-lpc1768)作成完成"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:257
msgid ""
"Ajhc [0.8.0.8](http://www.haskell.org/pipermail/jhc/2013-September/001065."
"html) リリース"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:257
msgid ""
"[Android NDKサンプルアプリのスナッチ](https://github.com/ajhc/demo-android-"
"ndk)完了"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:259
msgid ""
"[![](https://raw.github.com/ajhc/demo-cortex-m3/master/img/mbed-nxp-lpc1768."
"jpg)](https://mbed.org/handbook/mbed-NXP-LPC1768)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:261
msgid "## 2013年10月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:269
msgid ""
"Android上でHaskellアプリをこねこね書いていたら、タッチパネルで回転できる立方"
"体を表示するアプリ [Cube](https://play.google.com/store/apps/details?id=org."
"metasepi.ajhc.android.cube)  ができたでゲソ。 このアプリをredditに投稿したと"
"ころ大変良い反応で嬉しかったでゲソ。 もっとも、やっていることは簡単で、マイコ"
"ン上で再入可能を実現したことの方がはるかに困難で意義深いものだったでゲソ。 し"
"かし、ユーザは見た目の派手さに注目するのだ、ということを再認識できたじゃなイ"
"カ。 実装は地味に堅実に、デモは派手に作るのがコツということかもしれないでゲ"
"ソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:276
msgid ""
"[Metasepi作戦会議 第5回](http://metasepi.org/posts/2013-10-06-osc2013-hi."
"html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:276
msgid ""
"[Metasepi作戦会議 第6回](http://metasepi.org/posts/2013-10-20-osc2013-tokyo."
"html)開催"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:276
msgid ""
"Ajhc [0.8.0.9](http://www.haskell.org/pipermail/jhc/2013-October/001069."
"html) リリース"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:276
msgid ""
"[Android Cubeデモ](https://play.google.com/store/apps/details?id=org."
"metasepi.ajhc.android.cube)完成"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:278
msgid ""
"[![Cubeデモアプリロゴ](https://raw.github.com/ajhc/demo-android-ndk/master/"
"cube/res/drawable-xhdpi/ic_launcher.png)](https://play.google.com/store/apps/"
"details?id=org.metasepi.ajhc.android.cube)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:280
msgid "## 2013年11月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:286
msgid ""
"[ChibiOS/RT](http://www.chibios.org/)というRTOS上でHaskellのforkOSスレッドが"
"使えるようになったでゲソ。 もっと前に使えるようになっていたはずなのでゲソが、"
"gitのログからだとどうもこの月のようでゲソ。 Ajhcには-fcustomthreadというコン"
"パイルオプションがあり、このオプションを使うとHaskellスレッドの下まわりのOSス"
"レッドを選択的に実装できるようになっているでゲソ。 その機構がRTOS上でもうまく"
"動作することが実証できたでゲソ。 mbedマイコンのサポートに本腰を入れる時が来た"
"ら、この機能を使ってmbed-rtos上にHaskellスレッドを構築することも可能なはず"
"じゃなイカ？"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:292
msgid ""
"[Metasepi作戦会議 第7回](http://metasepi.org/posts/2013-11-10-kof2013.html)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:292
msgid ""
"[Metasepi作戦会議 第8回](http://metasepi.org/posts/2013-11-24-osc-fukuoka-"
"oita.html)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:292
msgid ""
"ChibiOS/RT上で[forkOS](http://hackage.haskell.org/package/base-4.6.0.1/docs/"
"Control-Concurrent.html#v:forkOS)を使ったスレッドが動作するようになる"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:294
msgid ""
"[![](https://raw.github.com/metasepi/chibios-arafura/metasepi-arafura/docs/"
"rsc/logo.png)](http://www.chibios.org/)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:296
msgid "## 2013年12月"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:303
msgid ""
"[C85 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c85.html) の記事を書き上"
"げたでゲソ。 この記事はAndroidを題材にしたスナッチ設計の手引きでゲソ。 これま"
"でAjhcを使って様々なドメインに対してスナッチ設計を試してみていたので、 その手"
"法をワシ以外の人間も使えるように文書にまとめておきたかったのでゲソ。 実はC85"
"の同人誌には別の記事を考えていたのでゲソが、記事を書く工数ではなく実装工数が"
"不足していて無理だったでゲソ。 そのお蔵入りになった記事はC86、、、に掲載でき"
"るとうれしいかもでゲソー。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:308
msgid ""
"[C85 λカ娘](http://www.paraiso-lang.org/ikmsm/books/c85.html) の原稿完成"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:308
msgid ""
"Ajhc [0.8.0.10](http://www.haskell.org/pipermail/jhc/2013-December/001072."
"html) リリース"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:310
msgid ""
"[![簡約!? λカ娘 Rock!](http://www.paraiso-lang.org/ikmsm/images/c85-cover-s."
"jpg)](http://www.paraiso-lang.org/ikmsm/books/c85.html)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:312
msgid "## 2013年まとめ"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:316
msgid ""
"今年AjhcリポジトリにMetasepiプロジェクトとして加えた変更は1.5万行程度だったで"
"ゲソ。 コンパイラパイプラインについては5千行。 ランタイムは1.5千行程度変更を"
"加えたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:327
msgid ""
"~~~ $ pwd /home/kiwamu/src/ajhc $ git diff -r "
"d0d55fd5d7de2d642ea921b1c5efeeb6e3aa1d85 | wc -l 14692 $ git diff -r "
"d0d55fd5d7de2d642ea921b1c5efeeb6e3aa1d85 src | wc -l 4624 $ git diff -r "
"d0d55fd5d7de2d642ea921b1c5efeeb6e3aa1d85 rts/rts | wc -l 1401 ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:331
msgid ""
"やみくもに変更すれば良いというものではないし、 元にしたjhcがあまりにもメンテ"
"ナンスされていなかったせいもあるでゲソが、 Haskellコンパイラのド素人にしては"
"よくやった方なんじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:333
msgid "[![](/img/ajhc_logo_beta1.png)](http://ajhc.metasepi.org/)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:335
msgid "## 2014年はどんな年？"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:337
msgid "現時点でやってみたい/やらなければならないことはイカの通りでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "MVarのようなコンテキスト間の状態共有"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "ユーザ空間スレッド"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "C言語のポインタを局所的に降下するポインタコンビネータ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "GHCでしか使えないライブラリ群の移植"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "NetBSD/Linux kernelドライバをHaskellで書いてみる"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid ""
"[Native Client](https://developers.google.com/native-client/dev/)を使ったブラ"
"ウザ上実行"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid ""
"Haskell以外の言語処理系を使ったスナッチ設計 (例:[ATS Programming Language]"
"(http://www.ats-lang.org/))"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "よりよいARMマイコンサポート"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "よりよいAndroid NDKサポート"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "8bitマイコンに限定的に適用できないか検討"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "jhcによる最適化後のバイナリに対するよりよいデバッグ手法"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "Haskell+マイコンをIoTビジネスにする"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "速度/空間効率ベンチマーク"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "GCの一部だけでもFPGAを使ってハードマクロ化できないか"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid "英語論文を書いて研究者に宣伝"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-21-yuku-kuru.md:354
msgid ""
"[バグなおせ](https://github.com/ajhc/ajhc/issues?"
"labels=bug&page=1&state=open)"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:364
msgid ""
"でも、、、未来のことは誰にもわからないんじゃなイカ？ Metasepiが本格的に立ち上"
"がってまだ一年たらず。 内容はともかくとして、 これからもこの活動を継続できる"
"かどうか、 成果を出し続けられるかどうかが大事なんでゲソ。 どんなに良い技術で"
"も途中で燃え尽きてしまっては [過去の試み](http://metasepi.org/"
"posts/2012-08-18-haskell-or-ocaml-os.html)  と同じ結果が待つのみでゲソ。 あせ"
"らず、ゆっくり、確実にやることでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-12-21-yuku-kuru.md:365
msgid "[![](/img/metasepi_logo_v1_200x200.png)](http://metasepi.org/)"
msgstr ""

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第13回 議事録\n"
"description: Arafuraイテレーションの結果報告会でゲソー\n"
"tags: meeting, ajhc, ats, haskell, netbsd\n"
"---\n"
msgstr ""
"title: Metasepi team meeting #13\n"
"description: A debrief meeting of Arafura iteration\n"
"tags: meeting, ajhc, ats, haskell, netbsd\n"
"---\n"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:14
msgid ""
"Metasepi作戦会議 第13回を [オープンソースカンファレンス2014 Tokyo/Spring]"
"(http://www.ospn.jp/osc2014-spring/)  で開催したでゲソ。 今回はNetBSDのサウン"
"ドドライバをAjhcコンパイラとHaskell言語で設計置換する話をしてみたでゲソ。 ま"
"た、Metasepiプロジェクトの最初のイテレーションである [Arafura](2013-01-09-"
"design_arafura.html)  が終わったので、イテレーションの振り返りと次のイテレー"
"ションへの展望をざっくざっくとまとめたでゲッソ。"
msgstr ""
"We had \"Metasepi team meeting #13\" at\n"
"[Open Source Conference 2014 Tokyo/Spring](http://www.ospn.jp/osc2014-spring/).\n"
"At this meeting, I talked about rewriting NetBSD's sound driver with Haskell language and Ajhc compiler.\n"
"Also, we looked back on the iteration and had future plan of our next iteration,\n"
"because [Arafura](2013-01-09-design_arafura.html) as Metasepi's first itelation is done."

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:28
msgid ""
"今回のデモはNetBSD kernelのHD Audioドライバの割り込みハンドラだけをHaskell化"
"してみて、 実際に音源を再生するものでゲソ。 AjhcにおけるHaskellヒープアロケー"
"タであるs_alloc()関数が断続的に呼び出されていることがデモからわかるでゲソ。 "
"ヒープアロケーションは頻繁に行なっているのでゲソが、GCはほとんど発生していな"
"いじゃなイカ。 これはどうことなのでゲソ？ Ajhcはコンテキスト単位に分割して"
"Haskellヒープを管理しているでゲソ。 つまりHD Audioからのハードウェア割り込み"
"が発生すると、 バージンなHaskellヒープがハードウェア割り込みに対応するHaskell"
"コンテキストに割り当てられるでゲソ。 割り込み処理はあまり負荷なく終了するため"
"Haskellヒープはあまり使われないまま、当該コンテキストは終了するでゲソ。 この"
"割り込みHaskellコンテキストが終了するタイミングで、 汚れたHaskellヒープはバー"
"ジンな状態になってヒーププールに戻されるのでゲソ。 ということは次のハードウェ"
"ア割り込みの時にはまたバージンなHaskellヒープがいつも取り出せるということじゃ"
"なイカ! このAjhcの\"コンテキストローカルヒープ\"によってNetBSD kernel中のGCの"
"発生頻度は極端に抑えられるのでゲソ。"
msgstr ""
"The demo kernel's HD Audio driver is partly rewritten using Haskell,\n"
"i.e. the interrupt handler is rewritten using Haskell and the others are using C.\n"
"Of course, the kernel can play sound on real hardware.\n"
"You can see that s_alloc() function as Hasskell heap allocator is called continuously,\n"
"on the demo video.\n"
"GC occurs little, while the heap allocation occurs many many times.\n"
"What does this mean?\n"
"Ajhc maintains Haskell heap isolated by Haskell contexts.\n"
"So, when hardware interrupt occurs on HD Audio,\n"
"a Haskell context associated with the interrupt is assigned with new virgin heap.\n"
"The heap isn't hardly used, while the interrupt handler does easy action.\n"
"Then, the context done.\n"
"At the context ending,\n"
"the dirty heap is restored to virgin condition and returned to heap pool of Ajhc runtime.\n"
"This means that Haskell context always takes Haskell heap as virgin condition when next interrupt occurs!\n"
"The trick is called \"Context-Local Heaps (CLHs)\",\n"
"and decreases GC frequency in NetBSD kernel in the extreme."

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:31
msgid ""
"さて、 [以前にも説明した](2013-12-24-jats-ug.html) 通りArafuraイテレーション"
"は終わろうとしているでゲソ。 次のイテレーションでのkernelデザインは"
msgstr ""
"Now, Arafura iteration is closing [as explained in past](2013-12-24-jats-ug.html).\n"
"Kernel design is in our next iteration:"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:33
msgid "「NetBSD kernelをATSコンパイラを用いてスナッチ設計する」"
msgstr "\"Rewrite NetBSD kernel using ATS2 compiler, with Snatch-driven development stype.\""

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:40
msgid ""
"となる予定でゲソ。 この新しいイテレーションの名前を [Bohai](http://en."
"wikipedia.org/wiki/Bohai_Sea)  と名付けることにしようと思うでゲソ。 Bohai(渤"
"海)は中国は北京に近い内海なのでゲソが、今は海洋汚染がすすんでいると聞くでゲ"
"ソ。 さっそく型の力できれいな海を取り戻そうじゃなイカ! そしてもちろんBohaiは"
"ATSの作者である [Hongwei](http://www.cs.bu.edu/~hwxi/) の故郷でゲソー。"
msgstr ""
"We decide to name the new iteration as [Bohai](http://en.wikipedia.org/wiki/Bohai_Sea).\n"
"Bohai (渤海) is the innermost gulf of the Yellow Sea on the coast of Northeastern and North China.\n"
"However I hear that marine pollution occurs in the sea today.\n"
"Let's immediately clean up it with strong typed power!\n"
"And you know the sea is home of [Hongwei](http://www.cs.bu.edu/~hwxi/) as ATS language author.\n"
"De-gesso."

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:44
msgid ""
"### Metasepi team meeting #13: NetBSD driver using Haskell - @masterq_teokure"
msgstr "### Metasepi team meeting #13: NetBSD driver using Haskell - masterq_teokure"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:46
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/31790906\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-"
"width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </"
"iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www."
"slideshare.net/master_q/metasepi-team-meeting-13-netbsd-driver-using-haskell"
"\" title=\"Metasepi team meeting #13: NetBSD driver using Haskell\" target="
"\"_blank\">Metasepi team meeting #13: NetBSD driver using Haskell</a> </"
"strong> from <strong><a href=\"http://www.slideshare.net/master_q\" target="
"\"_blank\">Kiwamu Okabe</a></strong> </div>"
msgstr "<iframe src=\"http://www.slideshare.net/slideshow/embed_code/31790906\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;\" allowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/master_q/metasepi-team-meeting-13-netbsd-driver-using-haskell\" title=\"Metasepi team meeting #13: NetBSD driver using Haskell\" target=\"_blank\">Metasepi team meeting #13: NetBSD driver using Haskell</a> </strong> from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:48 posts/2014-01-18-mbed_fest.md:52
#: posts/2013-11-10-kof2013.md:29
msgid "## 発表動画"
msgstr "## Presentation Video"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:50
msgid ""
"<iframe width=\"560\" height=\"350\" src=\"//www.youtube.com/embed/"
"Nt-4XIL1J1c\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr "<iframe width=\"560\" height=\"350\" src=\"//www.youtube.com/embed/Nt-4XIL1J1c\" frameborder=\"0\" allowfullscreen></iframe>"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:52 posts/2013-10-20-osc2013-tokyo.md:35
msgid "## デモ動画"
msgstr "## Demo Video"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:54
msgid ""
"<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/"
"XEYcR5RG5cA\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr "<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/XEYcR5RG5cA\" frameborder=\"0\" allowfullscreen></iframe>"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:58
msgid ""
"[https://github.com/metasepi/netbsd-arafura-s1](https://github.com/metasepi/"
"netbsd-arafura-s1)"
msgstr "[https://github.com/metasepi/netbsd-arafura-s1](https://github.com/metasepi/netbsd-arafura-s1)"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:60 posts/2014-01-17-11th_wocs2.md:32
#: posts/2014-01-18-mbed_fest.md:56 posts/2014-01-05-mbed_fp_0.md:112
#: posts/2013-10-20-osc2013-tokyo.md:41 posts/2013-10-06-osc2013-hi.md:29
#: posts/2013-08-04-osckansai2013.md:26
#: posts/2013-11-24-osc-fukuoka-oita.md:46 posts/2013-09-16-osc2013-do.md:72
#: posts/2014-01-10-prosym55.md:25 posts/2013-11-10-kof2013.md:35
#: posts/2013-02-03-kickoff_meeting.md:68
msgid "## 会議の雰囲気"
msgstr "## Scene Photographs"

#. type: Plain text
#: posts/2014-03-01-osc-tokyo.md:63
msgid ""
"![](/img/20140301_R1098839.jpg)  ![](/img/20140301_R1098837.jpg)  ![](/"
"img/20140301_R1098840.jpg)"
msgstr "![](/img/20140301_R1098839.jpg)  ![](/img/20140301_R1098837.jpg)  ![](/img/20140301_R1098840.jpg)"

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:5
#, no-wrap
msgid ""
"title: jhcコンパイルパイプラインの全体像\n"
"description: jhc内部の概要を掴むでゲッソ!\n"
"tags: haskell, jhc, internal, compiler\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:12
msgid ""
"jhcコンパイルパイプラインの図は [An informal graph of the internal code "
"motion in jhc (pdf)](http://repetae.net/computer/jhc/big-picture.pdf)  にある"
"んでゲソがどうにも概念寄りで、実際にソースコードのどの箇所で処理を行なってい"
"るのか分かり難いでゲソ。 そこで、上記の図よりも実装寄りの図を描いてみたでゲ"
"ソ。 だいたいさっきのbig-picture.pdfと対応が取れているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:14
#, fuzzy
#| msgid "![](/draw/2012-12-27-compile.png)"
msgid "![](/draw/2013-01-25-jhc_compile_flow.png)"
msgstr "![](/draw/2012-12-27-compile.png)"

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:18
msgid ""
"これで地図が手にはいったので、気になる部分を読もうじゃなイカ。 この図の中で最"
"適化を行なっていそうな3つの関数ソースコードから、 最適化してそうな部分をイカ"
"に抜き出してみたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:20
msgid "## processDecls関数"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:62
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"processDecls :: CollectedHo -> Ho -> TiData -> IO (CollectedHo,Ho)\n"
"processDecls cho ho' tiData = do\n"
"    let prog = program {\n"
"            progDataTable = fullDataTable,\n"
"            progExternalNames = choExternalNames cho,\n"
"            progModule = head (fsts $ tiDataModules tiData)\n"
"            }\n"
"    prog <- return prog { progSeasoning = seasoning }\n"
"    Identity prog <- return $ programMapDs (\\ (t,e) -> return (shouldBeExported (getExports $ hoTcInfo ho') t,e)) $ atomizeApps False (programSetDs ds prog)\n"
"    prog <- return $ progCombinators_u (map addRule) prog\n"
"    prog <- return $ runIdentity $ annotateProgram (choVarMap cho) (idann theProps) letann lamann prog\n"
"    prog <- return $ prog { progEntry = entryPoints `mappend` progSeasoning prog }\n"
"    prog <- programPrune prog\n"
"    prog <- transformProgram tparms {\n"
"        transformCategory = \"FloatInward\",\n"
"        transformOperation = programFloatInward\n"
"        } prog\n"
"    prog <- programMapProgGroups mempty fint prog\n"
"    prog <- etaExpandProg \"Init-Big-One\" prog { progStats = mempty }\n"
"    prog <- transformProgram tparms {\n"
"        transformPass = \"Init-Big-One\",\n"
"        transformCategory = \"FloatInward\",\n"
"        transformOperation = programFloatInward\n"
"        } prog\n"
"    prog <- Demand.analyzeProgram prog\n"
"    prog <- simplifyProgram' sopt \"Init-Big-One\" verbose (IterateMax 4) prog\n"
"    prog <- evalStateT (programMapProgGroups mempty optWW prog { progStats = mempty }) (SS.so_boundVars sopt)\n"
"    prog <- programPrune prog\n"
"    let newHoBuild = (hoBuild ho') {\n"
"        hoDataTable = dataTable,\n"
"        hoEs = programDs prog,\n"
"        hoRules = hoRules (hoBuild ho') `mappend` rules\n"
"        }\n"
"        newMap = fmap (\\c -> Just (EVar $ combHead c)) $ progCombMap prog\n"
"    return (updateChoHo $ mempty {\n"
"        choHoMap = Map.singleton (hoModuleGroup ho') ho' { hoBuild = newHoBuild},\n"
"        choCombinators = fromList $ [ (combIdent c,c) | c <- progCombinators prog ],\n"
"        choExternalNames = idMapToIdSet newMap\n"
"        } `mappend` cho,ho' { hoBuild = newHoBuild })\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:64
msgid "## compileWholeProgram関数"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:117
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"    prog <- return $ programUpdate prog {\n"
"        progMain   = tvrIdent main,\n"
"        progEntry = fromList $ map tvrIdent (main:ffiExportNames),\n"
"        progCombinators = emptyComb { combHead = main, combBody = mainv }:map (unsetProperty prop_EXPORTED) (progCombinators prog)\n"
"        }\n"
"    prog <- transformProgram transformParms {\n"
"        transformCategory = \"PruneUnreachable\",\n"
"        transformOperation = evaluate . programPruneUnreachable\n"
"        } prog\n"
"    prog <- programPrune prog\n"
"    prog <- evaluate $ progCombinators_s ([ p | p <- progCombinators prog,\n"
"        combHead p `notElem` map combHead cmethods] ++ cmethods) prog\n"
"    prog <- annotateProgram mempty (\\_ nfo -> return $ unsetProperty prop_INSTANCE nfo)\n"
"        letann (\\_ nfo -> return nfo) prog\n"
"    prog <- transformProgram transTypeAnalyze {\n"
"        transformPass = \"Main-AfterMethod\",\n"
"        transformDumpProgress = verbose } prog\n"
"    prog <- simplifyProgram SS.emptySimplifyOpts \"Main-One\" verbose prog\n"
"    prog <- etaExpandProg \"Main-AfterOne\" prog\n"
"    prog <- transformProgram transTypeAnalyze {\n"
"        transformPass = \"Main-AfterSimp\", transformDumpProgress = verbose } prog\n"
"    prog <- simplifyProgram SS.emptySimplifyOpts \"Main-Two\" verbose prog\n"
"    prog <- return $ runIdentity $ annotateProgram mempty (\\_ nfo -> return $\n"
"        modifyProperties (flip (foldr S.delete) [prop_HASRULE,prop_WORKER]) nfo)\n"
"        letann (\\_ -> return) prog\n"
"    prog <- simplifyProgram SS.emptySimplifyOpts { SS.so_finalPhase = True }\n"
"        \"SuperSimplify no rules\" verbose prog\n"
"    prog <- transformProgram transformParms {\n"
"        transformCategory = \"BoxifyProgram\",\n"
"        transformDumpProgress = dump FD.Progress,\n"
"        transformOperation = boxifyProgram } prog\n"
"    prog <- programPrune prog\n"
"    prog <- Demand.analyzeProgram prog\n"
"    prog <- return $ E.CPR.cprAnalyzeProgram prog\n"
"    prog <- transformProgram transformParms {\n"
"        transformCategory = \"Boxy WorkWrap\",\n"
"        transformDumpProgress = dump FD.Progress,\n"
"        transformOperation = evaluate . workWrapProgram } prog\n"
"    prog <- simplifyProgram SS.emptySimplifyOpts { SS.so_finalPhase = True }\n"
"        \"SuperSimplify after Boxy WorkWrap\" verbose prog\n"
"    prog <- return $ runIdentity $ programMapBodies (return . cleanupE) prog\n"
"    prog <- transformProgram transformParms {\n"
"        transformCategory = \"LambdaLift\",\n"
"        transformDumpProgress = dump FD.Progress,\n"
"        transformOperation = lambdaLift } prog\n"
"    prog <- Demand.analyzeProgram prog\n"
"    prog <- return $ E.CPR.cprAnalyzeProgram prog\n"
"    prog <- simplifyProgram SS.emptySimplifyOpts {\n"
"        SS.so_postLift = True, SS.so_finalPhase = True } \"PostLiftSimplify\" verbose prog\n"
"    prog <- return $ atomizeApps True prog\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:119
msgid "## compileToGrin関数"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:146
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"    x <- Grin.FromE.compile prog\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- explicitRecurse x\n"
"    lintCheckGrin x\n"
"    x <- transformGrin deadCodeParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- transformGrin pushParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- grinSpeculate x\n"
"    lintCheckGrin x\n"
"    x <- transformGrin deadCodeParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- transformGrin pushParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- transformGrin nodeAnalyzeParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- transformGrin nodeAnalyzeParms x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- createEvalApply x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- transformGrin devolveTransform x\n"
"    x <- transformGrin simplifyParms x\n"
"    x <- return $ twiddleGrin x\n"
"    x <- storeAnalyze x\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:148
msgid "## コールグラフ"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:151
msgid ""
"この調査のために一旦コールグラフを書いたので、念の為はりつけておくでゲッソ。 "
"ひょっとすると後日使うかもしれないじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:208
#, no-wrap
msgid ""
"~~~\n"
"main\n"
"=> processFiles\n"
"   => (_, cho) <- parseFiles\n"
"      => loadModules\n"
"      => processCug\n"
"      => typeCheckGraph\n"
"         => parseHsSource\n"
"            => preprocessHs\n"
"            => runParserWithMode\n"
"         => doModules\n"
"            => determineExports\n"
"            => tiModules # xxx 要調査\n"
"               => processModule\n"
"                  => renameModule\n"
"                     => FrontEnd.Rename.runRename\n"
"                        => desugarHsModule\n"
"                           => desugarDecl\n"
"                        => FrontEnd.Rename.renameDecls\n"
"                        => driftDerive\n"
"      => compileCompNode\n"
"         => processInitialHo\n"
"         => processDecls # Program型をこねこねする\n"
"         => recordHoFile\n"
"   => processCollectedHo cho\n"
"      => dataTable = choDataTable cho\n"
"      => combinators = values $ choCombinators cho\n"
"      => Control.Exception.evaluate dataTable / evaluate combinators\n"
"      => prog = programUpdate E.Program.program {\n"
"            progCombinators = combinators,\n"
"            progDataTable = dataTable\n"
"            }\n"
"      => compileWholeProgram prog\n"
"      => compileToGrin prog\n"
"         => Grin.FromE.compile\n"
"            => progEntryPoints\n"
"            => constantCaf\n"
"            => compile'\n"
"            => grin = setGrinFunctions theFuncs emptyGrin {\n"
"                  grinEntryPoints = minsert funcMain (FfiExport \"_amain\" Safe CCall [] \"void\") $\n"
"                                fromList epv,\n"
"                  grinPhase = PhaseInit,\n"
"                  grinTypeEnv = newTyEnv,\n"
"                  grinCafs = [ (x,node) | (x,node) <- cafs]\n"
"                  }\n"
"         => transformGrin # 色々な種類の変換があるみたい\n"
"         => explicitRecurse\n"
"         => lintCheckGrin\n"
"         => grinSpeculate\n"
"         => createEvalApply\n"
"         => twiddleGrin\n"
"         => storeAnalyze\n"
"         => compileGrinToC\n"
"            => compileGrin\n"
"            => System.system comm # gccでコンパイル\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:210
msgid "## 主要な関数の型"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:214
msgid ""
"さらにこの調査のために関数の型を調べる必要があったでゲソ。 どうもjhcの作者の"
"Johnさんはトップレベルの関数に型シグニチャをつけない傾向があるでゲソ...イカン"
"でげゲソ! 主要な関数の型はイカの通りでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-01-31-jhc_internal_overview.md:257
msgid ""
"~~~ {.haskell} parseFiles :: Opt -> [FilePath] -> [String] -> [Either Module "
"FilePath] -> (CollectedHo -> Ho -> IO CollectedHo) -> (CollectedHo -> Ho -> "
"TiData -> IO (CollectedHo,Ho)) -> IO (CompNode,CollectedHo)  loadModules :: "
"Opt -> [FilePath] -> [String] -> SrcLoc -> [Either Module FilePath] -> IO "
"(Map.Map SourceHash (Module,[(Module,SrcLoc)]),HoHash,CompUnitGraph)  "
"processCug :: CompUnitGraph -> HoHash -> IO CompNode typeCheckGraph :: Opt -"
"> CompNode -> IO ()  parseHsSource :: Opt -> FilePath -> LBS.ByteString -> "
"IO (HsModule,LBS.ByteString)  preprocessHs :: Opt -> FilePath -> LBS."
"ByteString -> IO LBS.ByteString runParserWithMode :: ParseMode -> P a -> "
"String -> ([Warning],ParseResult a)  doModules :: HoTcInfo -> [HsModule] -> "
"IO (HoTcInfo,Tc.TiData)  determineExports :: [(Name,SrcLoc,[Name])] -> "
"[(Module,[Name])] -> [ModInfo] -> IO [ModInfo] tiModules :: HoTcInfo -> "
"[ModInfo] -> IO (HoTcInfo,TiData)  processModule :: FieldMap -> ModInfo -> "
"IO (ModInfo,[Warning])  renameModule :: MonadWarn m => Opt -> FieldMap -> "
"[(Name,[Name])] -> HsModule -> m ((HsModule,[HsDecl]),Map.Map Name Name)  "
"FrontEnd.Rename.runRename :: MonadWarn m => (a -> RM b) -> Opt -> Module -> "
"FieldMap -> [(Name,[Name])] -> a -> m (b,Map.Map Name Name)  "
"desugarHsModule :: HsModule -> HsModule desugarDecl :: HsDecl -> PatSM "
"[HsDecl] FrontEnd.Rename.hs.renameDecls :: HsModule -> RM HsModule "
"driftDerive :: HsModule -> [HsDecl] compileCompNode :: (CollectedHo -> Ho -> "
"IO CollectedHo) -> (CollectedHo -> Ho -> TiData -> IO (CollectedHo,Ho)) -> "
"Map.Map SourceHash (Module,[(Module,SrcLoc)]) -> CompNode -> IO CollectedHo "
"processInitialHo :: CollectedHo -> Ho -> IO CollectedHo processDecls :: "
"CollectedHo -> Ho -> TiData -> IO (CollectedHo,Ho)  recordHoFile :: Ho -> "
"HoIDeps -> [FilePath] -> HoHeader -> IO ()  processCollectedHo :: "
"CollectedHo -> IO ()  choDataTable :: CollectedHo -> DataTable "
"choCombinators :: CollectedHo -> IdMap Comb Control.Exception.evaluate :: a -"
"> IO a programUpdate :: Program -> Program compileWholeProgram :: Program -> "
"IO Program compileToGrin :: Program -> IO ()  Grin.FromE.compile :: Program -"
"> IO Grin progEntryPoints :: Program -> [TVr] constantCaf :: Program -> "
"([(TVr,Var,Val)],[Var],[(TVr,Var,Val)])  compile' :: CEnv -> (TVr,[TVr],E) -"
"> C (Atom,Lam)  transformGrin :: TransformParms Grin -> Grin -> IO Grin "
"explicitRecurse :: Grin -> IO Grin lintCheckGrin :: Grin -> IO ()  "
"grinSpeculate :: Grin -> IO Grin createEvalApply :: Grin -> IO Grin "
"twiddleGrin :: Grin -> Grin storeAnalyze :: Grin -> IO Grin "
"compileGrinToC :: Grin -> IO ()  compileGrin :: Grin -> (LBS.ByteString,"
"Requires)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第11回 議事録\n"
"description: 企業の研究者は何を考えているのか、視察に行くでゲソー\n"
"tags: meeting, ajhc, mbed, haskell\n"
"---\n"
msgstr ""
"title: Metasepi team meeting #11\n"
"description: Let's set out on a tour of what's on corporate researcher's mind\n"
"tags: meeting, ajhc, mbed, haskell\n"
"---\n"

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:10
msgid ""
"Metasepi作戦会議 第11回を [「第11回クリティカルソフトウェアワークショップ」]"
"(http://stage.tksc.jaxa.jp/jedi/event/20140115.html)  にて開催したでゲソ。"
msgstr ""
"We had \"Metasepi team meeting #11\" at\n"
"[\"11th Workshop of Critical Software Systems(11thWOCS2)\"](http://stage.tksc.jaxa.jp/jedi/en/event/20140115.html)."

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:16
msgid ""
"第10回の会議では主に大学関連の研究者に宣伝をしたので、 企業の研究者や開発者に"
"宣伝をしたくなったのでゲソ。 ただ、、、この研究会では主に設計プロセスの方を取"
"り扱っていて、 ワシのような言語による設計手法のサポートのような提案はほとんど"
"見られなかったでゲソ。 それだけ現場で即使えるような手法が求められている、とい"
"うことのようでゲソ。"
msgstr ""
"At Metasepi team meeting #10, we promoted Metasepi for university researcher.\n"
"This time, I would like to promote it for corporate researcher.\n"
"However, people at this workshop mainly discuss pure software-design process,\n"
"and nobody discuss programming language as us.\n"
"I think they need method that is ready-to-use on their job site."

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:21
msgid ""
"しかしここにもワシの改善したい点があるのでゲソ。 これまで「C言語 + サポートす"
"る設計手法」という安直な解しか取ることができなかったために現在のエンジニアの"
"不幸があるのでゲソ。 これを改善するにはアセンブラからC言語に発展した時のよう"
"に適切な言語をシステム記述に用いることができるようにしなければならないでゲ"
"ソ。 「マイコンボードで動かしました」レベルではなく、どこかのドメインで実用に"
"なるような技術をMetasepiは早く産み出す必要があるんじゃなイカ？"
msgstr ""
"But there is also a problem that is solved by us.\n"
"Because we have only chosen \"C language + design method to support the language\"\n"
"as facile solution in the past, software engineer is luckless today.\n"
"To fix it, we should choose some fitting languages to be good for system programming, \n"
"as chose C language instead of assembler\n"
"Also Metasepi project should produce some practical technologies for some real domains,\n"
"as soon as possible.\n"
"\"It can run on MCU\" still isn't enough to do it."

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:26
msgid ""
"また、企業の開発者だと「強い型」というと [Ada](http://ja.wikipedia.org/wiki/"
"Ada)  を思いうかべるようで、型推論を持つ言語の「型」とAdaのような言語の持つ"
"「型」の差異について、 明確に説明できるようになっておくべきだということが学習"
"できたでゲソ。"
msgstr ""
"By the way, many corporate researchers associate [Ada](http://en.wikipedia.org/wiki/Ada_(programming_language)) with \"strongly typed language\".\n"
"I know we should clearly explain difference between \"type \" of languages having type inference and of such like Ada."

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:30
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29107727\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20140117-11th-wocs2\" title=\"How to rewrite the OS using C by "
"strong type\" target=\"_blank\">How to rewrite the OS using C by strong "
"type</a> </strong> from <strong><a href=\"http://www.slideshare.net/master_q"
"\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"
msgstr "<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29107727\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/master_q/20140117-11th-wocs2\" title=\"How to rewrite the OS using C by strong type\" target=\"_blank\">How to rewrite the OS using C by strong type</a> </strong> from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"

#. type: Plain text
#: posts/2014-01-17-11th_wocs2.md:34
msgid ""
"![](/img/20140117_11th_wocs2_1.png)  ![](/img/20140117_11th_wocs2_2.png)"
msgstr "![](/img/20140117_11th_wocs2_1.png)  ![](/img/20140117_11th_wocs2_2.png)"

#. type: Plain text
#: posts/2012-12-22-jhc.md:5
#, no-wrap
msgid ""
"title: 簡約!λカ娘(4)の紹介とjhcのすゝめ\n"
"description: かわいい(小さい)バイナリは正義でゲソ!\n"
"tags: haskell, book, compiler\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:12
msgid ""
"この記事は [Debian/Ubuntu JP Advent Calendar 2012 : ATND](http://atnd.org/"
"events/34386)  と [Haskell Advent Calendar 2012](http://partake.in/"
"events/45a01d39-af5e-42f1-91c7-e8fcc91db244)  の12/22(土曜)分でゲソー。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:18
msgid ""
"またもや [関数型プログラミングの本](http://www.paraiso-lang.org/ikmsm/books/"
"c83.html)  が出るでゲソ。コミックマーケット83 [3日目 東地区 Y-02a](http://"
"twitcmap.jp/?id=0083-3-YYa-02-a)  で頒布予定なので、みんな買ってほしいでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:20
msgid "![](http://www.paraiso-lang.org/ikmsm/images/c83-cover-s.jpg)"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第1章 インターフェース"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第2章 Lighter than Light # <= コレ書いた"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第3章 類は友を呼ぶ?"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第4章 OCaml で printf じゃなイカ?"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第5章 Haskell でも printf じゃなイカ?!"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-12-22-jhc.md:27
msgid "第6章 けいさん! highschool"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:36
msgid ""
"がもくじで、 [\\@master_q](https://twitter.com/master_q)  は第2章を書いたらし"
"いでゲソ。 この章ではHaskellで書かれたフィボナッチ数列のみを表示する プログラ"
"ムをどこまで小さくできるか、GHCを改造することで挑戦しているゲソ。 記事が気に"
"なったら是非 [サンプル版pdf](http://www.paraiso-lang.org/ikmsm/books/c83-"
"sample.pdf)  を読んでみてほしいでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:39
msgid "## Haskellコンパイラjhc"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:48
msgid ""
"GHCの話はこの本に力いっぱい書いたので、 今日はまた別のHaskellコンパイラの話を"
"しようと思うでゲソ。 HaskellのコンパイラにはGHC以外にも [実装がある](http://"
"www.haskell.org/haskellwiki/Implementations)  んでゲソ。 その中でもワシが注目"
"しているのは [jhc](http://repetae.net/computer/jhc/)  でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:50
msgid "### インストール"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:53
msgid ""
"まずはインストールしてみるでゲソ。 この記事での想定環境はDebian GNU/Linux "
"sid amd64 2012年12月22日時点でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:68
#, no-wrap
msgid ""
"~~~\n"
"$ sudo apt-get install autotools-dev autoconf libwww-perl drift ghc libghc-readline-dev libghc-utf8-string-dev libghc-hssyck-dev libghc-fgl-dev libghc-zlib-dev libghc-regex-compat-dev libghc-random-dev libreadline-dev libncurses5-dev darcs\n"
"$ darcs get http://repetae.net/repos/jhc\n"
"$ darcs log|head -2 \n"
"Wed Mar 14 07:58:54 UTC 2012  John Meacham <john@repetae.net>\n"
"  * fix 'distcheck', include compat/ in tarball\n"
"$ autoreconf -i\n"
"$ ./configure\n"
"$ make\n"
"$ sudo make install\n"
"$ jhc --version\n"
"jhc 0.8.1 (0.8.0-59)\n"
"compiled by ghc-7.4 on a x86_64 running linux\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:70
msgid "簡単にインストールできたじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:72
msgid "### jhcの威力を見よ!"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:74
msgid ""
"ためしに簡単なプログラムをコンパイルして、GHCとjhcの比較をしてみなイカ？"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:103
#, no-wrap
msgid ""
"~~~\n"
"$ cat Fib.hs\n"
"fibonacci :: [Int]\n"
"fibonacci = 1:1:zipWith (+) fibonacci (tail fibonacci)\n"
"main :: IO ()\n"
"main = print $ take 40 fibonacci\n"
"$ ghc -o Fib_ghc Fib.hs\n"
"$ jhc -o Fib_jhc Fib.hs\n"
"$ size Fib_ghc Fib_jhc\n"
"   text    data     bss     dec     hex filename\n"
" 705068   38536   46776  790380   c0f6c Fib_ghc\n"
"  15808    1300     744   17852    45bc Fib_jhc\n"
"$ ldd Fib_ghc Fib_jhc\n"
"Fib_ghc:\n"
"        linux-vdso.so.1 (0x00007fffaadff000)\n"
"        libgmp.so.10 => /usr/lib/x86_64-linux-gnu/libgmp.so.10 (0x00007f671ef83000)\n"
"        libffi.so.5 => /usr/lib/x86_64-linux-gnu/libffi.so.5 (0x00007f671ed76000)\n"
"        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f671ea7b000)\n"
"        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f671e873000)\n"
"        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f671e66f000)\n"
"        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f671e2c6000)\n"
"        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f671e0aa000)\n"
"        /lib64/ld-linux-x86-64.so.2 (0x00007f671f22a000)\n"
"Fib_jhc:\n"
"        linux-vdso.so.1 (0x00007fff1ef3b000)\n"
"        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f39020b3000)\n"
"        /lib64/ld-linux-x86-64.so.2 (0x00007f3902493000)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:109
msgid ""
"なんと! 同じソースコードをコンパイルしたのに、 jhcの吐き出す実行バイナリはGHC"
"の1/40のサイズでゲソ。 しかも依存ライブラリはlibcのみ。 これはどんな魔法なん"
"でゲソ？"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:111
msgid "### jhcのしくみ"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:113
msgid ""
"イカの図はjhc本体のコンパイルとjhcによるHaskellコードのコンパイルの関係を表わ"
"しているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:115
#, fuzzy
#| msgid "![](/draw/2012-12-27-compile.png)"
msgid "![](/draw/2012-12-22-jhc_compile.png)"
msgstr "![](/draw/2012-12-27-compile.png)"

#. type: Plain text
#: posts/2012-12-22-jhc.md:119
msgid ""
"まずjhcはGHCによってコンパイルされるGHCの一アプリケーションでゲソ。 jhcがGHC"
"によってコンパイルされるということはjhcはGHCのRTSで動くでゲソ。 このjhcが"
"Haskellのソースコードをコンパイルする際はイカの段階をふむでゲソ。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2012-12-22-jhc.md:127
msgid "HaskellのソースコードをパースしてCoreに変換"
msgstr ""

#. type: Bullet: '2. '
#: posts/2012-12-22-jhc.md:127
msgid "依存するhlファイルを読み込む"
msgstr ""

#. type: Bullet: '3. '
#: posts/2012-12-22-jhc.md:127
msgid "1と2を混ぜて最適化"
msgstr ""

#. type: Bullet: '4. '
#: posts/2012-12-22-jhc.md:127
msgid "C言語ソースコード出力"
msgstr ""

#. type: Bullet: '5. '
#: posts/2012-12-22-jhc.md:127
msgid "4をGCCなどのC言語コンパイラにかける"
msgstr ""

#. type: Bullet: '6. '
#: posts/2012-12-22-jhc.md:127
msgid "jhcのRTSをコンパイル"
msgstr ""

#. type: Bullet: '7. '
#: posts/2012-12-22-jhc.md:127
msgid "5と6をリンクして実行バイナリ作成"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:133
msgid ""
"hlファイルというのは、GHCで言うところの静的リンクオブジェクト(hoge.a)  とイン"
"ターフェイスファイル(hoge.hi)を合わせたモノと機能としてはだいたい同じでゲ"
"ソ。 その実体はCoreまで変換されたHaskellのソースコードの寄せ集めでゲソ。 GHC"
"とは異なりjhcはhlファイルの中に完全な実コードを持たせてより強力な最適化を行え"
"るようにしているんでゲソ。 ^[2012/12/23修正: [\\@shelarcyさんからの指摘]"
"(https://twitter.com/shelarcy/status/282711258300567552)を受けて修正]"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:136
msgid ""
"GHCと比較して、このコンパイル方式の特徴としてはイカが挙げれるでゲッソ。 特にc"
"が効いているためにGHCと比較してバイナリサイズが小さくなるんじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:140
msgid ""
"a. 全ての要素はC言語を経由してバイナリになる b. jhcのRTSはC言語で記述され、"
"3000行程度ととても小さい c. 全ての要素を混ぜてから最適化をかけるため、実行バ"
"イナリから不要な部品は削除される"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:144
msgid ""
"jhcのコンパイプパイプラインについては [An informal graph of the internal "
"code motion in jhc (pdf)](http://repetae.net/computer/jhc/big-picture.pdf)  "
"が詳しいでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:146
msgid "### jhcの持つ可能性"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:154
msgid ""
"このjhcはどんな用途に使えるんでゲソ？ まず思いつくのは移植性でゲソ。 C言語化"
"にしてしまった後クロスコンパイラにかければ簡単にクロスコンパイル対応Haskellコ"
"ンパイラの完成じゃなイカ! 実際、jhcには [targets.ini](http://repetae.net/"
"computer/jhc/manual.html#crosscompilation)  というクロスコンパイルのための設"
"定があって、 C言語をどのコンパイラでどんなフラグをつけてコンパイルするのか仕"
"向け設定ができるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:162
msgid ""
"さらに [-Cオプション](http://repetae.net/computer/jhc/manual.html#options)  "
"を使うとコンパイルパイプラインをC言語を吐いた段階で停止させることができるでゲ"
"ソ。 一見あまり使い道がなさそうなこのオプション、実は様々な用途に使えるんでゲ"
"ソ! 一例としてはjhcを使ってコンパイルしたHaskellプログラムと自分で作ったカス"
"タムRTS(もしくはjhcのRTSを改造)  と組み合わせてlibcのないような特殊な環境下で"
"Haskellプログラムを動作させるでゲソ。 ...実感しにくいので、もっと具体的に話す"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:174
#, no-wrap
msgid ""
"~~~\n"
"$ jhc -C -o Fib_jhc.c Fib.hs\n"
"$ gcc -I/home/kiwamu/src/jhc-arafura/rts -std=gnu99 -D_GNU_SOURCE -falign-functions=4 -ffast-math -Wextra -Wall -Wno-unused-parameter -fno-strict-aliasing -DNDEBUG -D_JHC_GC=_JHC_GC_JGC -c Fib_jhc.c\n"
"$ nm Fib_jhc.o | grep \"U \"\n"
"                 U arena\n"
"                 U eval\n"
"                 U find_cache\n"
"                 U putchar_unlocked\n"
"                 U s_alloc\n"
"                 U saved_gc\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:185
msgid ""
"上記のようにjhcのコンパイルパイプラインを-Cオプションを使って C言語ソースコー"
"ドで生成直後で止めるでゲソ。 さらに生成されたC言語ソースコードをGCCを使ってオ"
"ブジェクトファイルにすると たった6つのシンボルにしか依存していないことがわか"
"るでゲソ。 この6つの未解決シンボルは通常jhcのRTSによって解決されるのでゲソ"
"が、 もちろん自作しても問題ないのでゲソ。 GHCと異なり、このシンボルはイカのよ"
"うに単純な機能しか持っていないので、 自作するのも現実的な貝なんでゲッソ! もち"
"ろん自作RTSから直接ハードをさわるのも面白いかもしれないでゲソ。 これでどんな"
"場所へもHaskell潜水艦でスイスイーじゃなイカー。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:187
#, fuzzy
#| msgid "![](/draw/2012-12-27-compile.png)"
msgid "![](/draw/2012-12-22-jhc_custom_rts.png)"
msgstr "![](/draw/2012-12-27-compile.png)"

#. type: Plain text
#: posts/2012-12-22-jhc.md:189
msgid ""
"なんだか上の図をぼーっと見ていると、自作RTSがkernelのように見えてきたでゲッ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:191
msgid "## Debianパッケージ化"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:197
msgid ""
"こんなにjhcが便利なら、ありとあらゆるマシンに手軽にインストールしたくなイ"
"カ？ 2012年12月22日(土)時点ではまだDebian本家には登録完了していないでゲソ"
"が、 [anonscm.debian.org Git - collab-maint/jhc.git](http://anonscm.debian."
"org/gitweb/?p=collab-maint/jhc.git)  からjhcのソースパッケージを取得できるよ"
"うでゲソ。 ソースパッケージからバイナリパッケージをビルドしてみるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:208
msgid ""
"~~~ $ git clone git://anonscm.debian.org/collab-maint/jhc.git $ cd jhc $ "
"debuild -i -us -uc -b $ ls ../*.deb ../jhc-doc_0.8.0~darcs20120314-1_all."
"deb ../jhc_0.8.0~darcs20120314-1_amd64.deb $ sudo dpkg -i ../"
"jhc_0.8.0\\~darcs20120314-1_amd64.deb $ which jhc /usr/bin/jhc ~~~"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:212
msgid ""
"ドキュメントと実行ファイルを別パッケージに分割してくれるようでゲソ。 自然言語"
"を読まないワシにはjhc-docパッケージなぞ不要でゲッソ! パッケージでインストール"
"すると、何が何処にインストールされたかわかって便利でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:251
msgid ""
"~~~ $ cat /var/lib/dpkg/info/jhc.list --snip-- /usr/share/doc/jhc/copyright /"
"usr/share/doc/jhc/changelog.gz /usr/share/doc/jhc/changelog.Debian.gz /usr/"
"share/jhc-0.8 /usr/share/jhc-0.8/containers-0.3.0.0.hl /usr/share/jhc-0.8/"
"safe-0.2.hl --snip-- /usr/share/jhc-0.8/jhc-prim-1.0.hl /usr/share/jhc-0.8/"
"html-1.0.1.2.hl /usr/share/man /usr/share/man/man1 /usr/share/man/man1/jhc.1."
"gz /usr/bin/jhci $ cat /var/lib/dpkg/info/jhc-doc.list --snip-- /usr/share/"
"doc/jhc-doc/building.shtml /usr/share/doc/jhc-doc/development.shtml /usr/"
"share/doc/jhc-doc/jhc-vs-ghc-assembly.txt.gz /usr/share/doc/jhc-doc/"
"copyright /usr/share/doc/jhc-doc/conventions.txt /usr/share/doc/jhc-doc/"
"manual.html /usr/share/doc/jhc-doc/manual.css /usr/share/doc/jhc-doc/c-minus-"
"monad.txt.gz /usr/share/doc/jhc-doc/type-classes.txt.gz /usr/share/doc/jhc-"
"doc/changelog.gz /usr/share/doc/jhc-doc/big-picture.pdf.gz /usr/share/doc/"
"jhc-doc/announce /usr/share/doc/jhc-doc/announce/announce-0.7.4.txt --"
"snip-- /usr/share/doc/jhc-doc/announce/announce-0.7.7.txt /usr/share/doc/jhc-"
"doc/changelog.Debian.gz /usr/share/doc/jhc-doc/index.shtml /usr/share/doc-"
"base /usr/share/doc-base/jhc ~~~"
msgstr ""

#. type: Plain text
#: posts/2012-12-22-jhc.md:252
msgid "んーパッケージ化してプログラムを管理するっていい気持ちでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:5
#, no-wrap
msgid ""
"title: デザインArafura\n"
"description: Metasepiの最初のアーキティクチャを決めるでゲソ!\n"
"tags: haskell, design, specification, bootloader\n"
"---\n"
msgstr ""
"title: Arafura Design\n"
"description: Get first design for Metasepi kernel.\n"
"tags: haskell, design, specification, bootloader\n"
"---\n"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:11
msgid ""
"調査を繰り返していても、設計は進まないでゲソ。 まずは第一歩、なにか作ってみれ"
"ばわかることもあるんじゃなイカ？ まずコードを書く前におおざっぱな設計を決める"
"でゲソ。 このエントリは何度も書き直すかもしれないでゲソ。"
msgstr ""
"Can't get design, even repeating the research. It might be a good idea to "
"make something at first step? Let's decide a rough sketch before writing the "
"code. This blog entry will be rewritten some times."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:13
msgid "## 最初のデザイン"
msgstr "## First design"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:19
msgid ""
"[Haskell/OCaml製のOSって何があるんでゲソ？](2012-08-18-haskell-or-ocaml-os."
"html)  でも書いたでゲソが、短時間でドッグフード可能 ^[開発対象のkernelの上で"
"当該kernelの開発/コンパイルができるようになること] なkernelを得るには、関数型"
"言語としてキレイな設計を考えている時間はないでゲソ。 むしろ純朴な実装で良いか"
"ら、モノリシックkernelを関数型言語の設計に写像してしまった方が良いのではなイ"
"カ？"
msgstr ""
"We discuss \"[Are there OS designed with Haskell/OCaml?](2012-08-18-haskell-"
"or-ocaml-os.html)\" already.\n"
"The person living in real world has no time to get clean design of "
"Functional OS,\n"
"that be eaten as dog food.\n"
"^[[Eating your own dog food - Wikipedia](http://en.wikipedia.org/wiki/"
"Eating_your_own_dog_food)]\n"
"It may be better than it to rewrite a just monolithic kernel with functional "
"language."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:22
msgid ""
"ここでは写像するモノリシックkernelとしてNetBSDを選定するでゲソ。 ソースコード"
"が読みやすい、などの理由があるでゲソが、単にワシの趣味でゲソ。"
msgstr ""
"We selected the NetBSD as a monolithic kernel for rewriting. There is my "
"hobby simply reasons, such as easy-to-read source code."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:28
msgid ""
"このC言語で書かれたNetBSD kernelをいきなり型付き言語でスクラッチから書き直す"
"のもやはりシンドイでゲソ。 もう少し楽できなイカ？ そこでいきなり全部ではな"
"く、コンパイル可能/実行可能な状態を保ちながら少しずつ型付き言語で同じ機能を再"
"実装するでゲソ。 少しずつ型をつけていけば、 いつかは全てのコードが型付き言語"
"で動くようになるんじゃなイカ？"
msgstr ""
"The rewrite from scratch in typed language suddenly the NetBSD kernel "
"written in the C language also is still severe. I want a little more "
"comfortable? So but not all suddenly, and re-implement the same "
"functionality in the typed language a little bit at a time while keeping a "
"compilable / executable state. If you go with the type little by little, all "
"the code I might be to work with typed language one day?"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:30
msgid "![](/draw/2012-12-27-arafura_design.png)"
msgstr "![](/draw/2012-12-27-arafura_design.png)"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:42
msgid ""
"この「NetBSD kernelを型付き言語で少しずつ [スナッチ](http://ja.wikipedia.org/"
"wiki/%E3%82%B9%E3%83%8A%E3%83%83%E3%83%81%E3%83%A3%E3%83%BC)  する」というデ"
"ザインを [アラフラ](http://ja.wikipedia.org/wiki/"
"%E3%82%A2%E3%83%A9%E3%83%95%E3%83%A9%E6%B5%B7)  ([Arafura](http://en."
"wikipedia.org/wiki/Arafura_Sea))と呼ぼうと思うでゲソ。 \"A\"からはじまる海の"
"名前、最初の船出にはぴったりじゃなイカ! ^[また、コウイカの一種で色を変える小"
"さなイカ [Metasepia pfefferi](http://en.wikipedia.org/wiki/"
"Metasepia_pfefferi)  が住んでいて、アラフラは「自由人」を意味するポルトガル語"
"の古語に由来そうでゲソ。 でも\"珊瑚礁からなる浅瀬が多く、航行の障害となる箇所"
"も多数ある\"そうでゲソ...] もしこの海で航海に失敗しても、今度は\"B\"で始まる"
"海(デザイン)を選べばいいんでゲソ。 合言葉は\"ネバーギブアップ\"でゲッソ!!!"
msgstr ""
"I think it tries to call the Arafura this design of \"snatch little by "
"little in the typed language NetBSD kernel\". That's good to sail the name "
"of the sea starting from \"A\", the first! (Also, small squid to change the "
"color is a type of cuttlefish, Metasepia pfefferi is lived, Arafura of the "
"Portuguese, which means \"free man\" But. is the origin so the archaic word "
"\"shallow consisting of a coral reef in many cases, where a failure of "
"navigation also have a large number\" when you fail to sail in this sea "
"if ...) Yes, the sea that begins with \"B\" this time it's okay if you "
"choose (design). I'm \"Never give up\" the watchword!"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:44
msgid "## やってみよう!"
msgstr "## Just do it!"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:49
msgid ""
"これまでの調査でjhcがMetasepiの設計に使えそうなことが判明したでゲソ。 NetBSD "
"kernelは割り込みハンドラを作ったりしなければならないので、 もっと簡単な"
"NetBSD bootloaderを手始めにjhcを使ってスナッチしてみるでゲソ。 何事もトレーニ"
"ングでゲッソ。"
msgstr ""
"We have known jhc may be useful to develop Metasepi kernel.\n"
"If snatch NetBSD kernel, we should write interrupt handler with Haskell "
"language.\n"
"It's so difficult for us, today.\n"
"Then, let's snatch bootloader that has more easy design than NetBSD kernel.\n"
"Everything starts at training."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:51
msgid "![](/draw/2012-12-27-loader.png)"
msgstr "![](/draw/2012-12-27-loader.png)"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:55
msgid ""
"NetBSD bootloaderのモジュールの構造は上図のようになっているでゲソ。 とりあえ"
"ずboot2.cの中にあるコマンドラインループをjhcを使って書いてみたでゲソ。 ^[[元"
"ソース](https://gitorious.org/metasepi/netbsd-arafura/"
"blobs/52c9e9c31425bdf983d0850b4e503c899a511edc/metasepi-arafura/sys/arch/"
"i386/stand/boot/Boot2Ara.hs)]"
msgstr ""
"Structure of the module of NetBSD bootloader is as shown in the above "
"figure.\n"
"Following code is the boot2.c command line loop rewrited with jhc and "
"Haskell language.\n"
"^[[Source code](https://gitorious.org/metasepi/netbsd-arafura/"
"blobs/52c9e9c31425bdf983d0850b4e503c899a511edc/metasepi-arafura/sys/arch/"
"i386/stand/boot/Boot2Ara.hs)]"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:63
msgid ""
"~~~ {.haskell} import Control.Monad import Data.Maybe import Data.Map (Map)  "
"import qualified Data.Map as Map import Foreign.C.Types import Foreign.Ptr"
msgstr ""
"~~~ {.haskell}\n"
"import Control.Monad\n"
"import Data.Maybe\n"
"import Data.Map (Map)\n"
"import qualified Data.Map as Map\n"
"import Foreign.C.Types\n"
"import Foreign.Ptr"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:65
msgid ""
"foreign import ccall \"glue_netbsdstand.h command_boot\" c_command_boot :: "
"Ptr a -> IO ()"
msgstr ""
"foreign import ccall \"glue_netbsdstand.h command_boot\" c_command_boot :: "
"Ptr a -> IO ()"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:70
#, no-wrap
msgid ""
"commands :: Map String (IO ())\n"
"commands = Map.fromList [(\"help\", command_help),\n"
"                         (\"?\", command_help),\n"
"                         (\"boot\", c_command_boot nullPtr)]\n"
msgstr ""
"commands :: Map String (IO ())\n"
"commands = Map.fromList [(\"help\", command_help),\n"
"                         (\"?\", command_help),\n"
"                         (\"boot\", c_command_boot nullPtr)]\n"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:79
#, no-wrap
msgid ""
"command_help :: IO ()\n"
"command_help = putStr $ \"\\\n"
"\\commands are:\\n\\\n"
"\\boot [xdNx:][filename] [-12acdqsvxz]\\n\\\n"
"\\     (ex. \\\"hd0a:netbsd.old -s\\\"\\n\\\n"
"--snip--\n"
"\\help|?\\n\\\n"
"\\quit\\n\"\n"
msgstr ""
"command_help :: IO ()\n"
"command_help = putStr $ \"\\\n"
"\\commands are:\\n\\\n"
"\\boot [xdNx:][filename] [-12acdqsvxz]\\n\\\n"
"\\     (ex. \\\"hd0a:netbsd.old -s\\\"\\n\\\n"
"--snip--\n"
"\\help|?\\n\\\n"
"\\quit\\n\"\n"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:88
#, no-wrap
msgid ""
"main :: IO ()\n"
"main = do\n"
"  putStrLn \"Haskell bootmenu\"\n"
"  forever $ do\n"
"    putStr \"> \"\n"
"    s <- getLine\n"
"    fromMaybe (putStr s) $ Map.lookup s commands\n"
"~~~\n"
msgstr ""
"main :: IO ()\n"
"main = do\n"
"  putStrLn \"Haskell bootmenu\"\n"
"  forever $ do\n"
"    putStr \"> \"\n"
"    s <- getLine\n"
"    fromMaybe (putStr s) $ Map.lookup s commands\n"
"~~~\n"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:92
msgid ""
"helpの表示はまぁいいとして、 kernelの読み込み+起動は既存コードにFFIで丸投げで"
"ゲソ。 このソースコードをイカのような方法でコンパイルしてみるでゲソ。"
msgstr ""
"Display of help is as good Well, I'm throwing circle at FFI to existing code "
"reads + boot kernel. Let's compiled in such a way of utilizing these source "
"code."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:94
msgid "![](/draw/2012-12-27-compile.png)"
msgstr "![](/draw/2012-12-27-compile.png)"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:97
msgid ""
"ほいでもってコンパイルして生成されたbootloaderバイナリをqemuで動かしてみるで"
"ゲッソ! (動画だと2:15ぐらいからMetasepi arafura版bootloaderをqemu上で起動して"
"いるでゲソ。)"
msgstr ""
"Let's run Metasepi arafura version of bootloader on qemu (2:15 at following "
"video)!"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:99
msgid ""
"<script type=\"text/javascript\" src=\"http://ext.nicovideo.jp/thumb_watch/"
"sm19788831\"></script><noscript><a href=\"http://www.nicovideo.jp/watch/"
"sm19788831\">【ニコニコ動画】Metasepi arafura first boot.</a></noscript>"
msgstr ""
"<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/"
"embed/0DPA7GC0_-0\" frameborder=\"0\" allowfullscreen></iframe>"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:104
msgid ""
"うん、helpの表示とkernelの起動はできているようでゲソ。まずは実験成功でゲソ! "
"ところでくれぐれも勘違いしてほしくないのは、 今回作ったbootloaderの99%はまだC"
"言語製だということでゲソ。 このbootloaderの動きをシーケンス図で描いてみるとイ"
"カのようになるでゲソ。"
msgstr ""
"Starting the kernel and display of help seems to be. First I do not want to "
"misunderstand earnestly by the way!'s Successful experiment, 99% of the "
"bootloader that I made this time but that it's still made ​​by C language. It "
"is as shown in the figure below and try to draw a sequence diagram the "
"movement of this bootloader."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:106
msgid "![](/draw/2013-01-09-sequence_diagram.png)"
msgstr "![](/draw/2013-01-09-sequence_diagram.png)"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:110
msgid ""
"なんと残念!かんじんの部分は既存のC言語ソースコードのままでゲソ。 でもこれから"
"少しずつスナッチを繰り返すことで、 上図のシーケンスの多くの部分をHaskellのよ"
"うな型付き言語で記述することも夢ではないんじゃなイカ？"
msgstr ""
"Part sorry! Bottom line remains the C language source code of existing what. "
"But by repeating snatch little by little from now, be described in typed "
"language like Haskell many parts of the sequence shown above and not "
"something a dream?"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:112
msgid "## 今見えている課題"
msgstr "## Known problems"

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:115
msgid ""
"まだbootloaderのスナッチははじまったばかりでゲソ。 kernelのことはまぁ置いとい"
"て、こんな小さなモジュールをスナッチしてみるだけでも色々な課題が見えてくるで"
"ゲソ。"
msgstr ""
"Snatch of bootloader has just begun.\n"
"Not yet snatch kernel, we can find many problems with snatching the small "
"module such as bootloader."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:120
msgid ""
"a. コマンドライン引数を扱えるように b. カスタムRTSに起因する問題が頻発してい"
"る。ユーザ空間でカスタムRTSをデバッグできた方がいい c. GCの使うヒープをalloc"
"で確保するのをやめて固定値に^[最悪1MB以降のメモリをヒープのために使っても良い"
"が、他への応用を考えるとコンベンショナルメモリだけで挑戦する価値はある] d. "
"bootloaderのヒープをRTSのヒープと共用すると、RTSがヒープを圧迫する。分割管理"
"すべき"
msgstr ""
"a. Be able to handle command-line arguments.\n"
"b. Should be able to debug custom RTS in user space. We have found problems "
"at custom RTS side frequently.\n"
"c. Use the fixed memory area for GC heap allocator. ^[We can use extended "
"memory (more than 1 MB) on Intel arch. But it's useful running in "
"conventional memory (less than 1 MB) for the other use case]\n"
"d. Isolate malloc's heap and Haskell's heap. Haskell's heap press malloc's "
"heap with the RTS implementation in this article."

#. type: Plain text
#: posts/2013-01-09-design_arafura.md:122
msgid ""
"今年いっぱいはjhc本体の調査と平行して、 このbootloaderのスナッチは継続して"
"やってみると色々な問題を洗い出せて面白いかもしれないでゲソ。"
msgstr ""
"Next action item is surveying more detail of jhc internel.\n"
"But, more snatching this bootloader may be also good idea to understand more "
"problems."

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第12回 議事録\n"
"description: mbed祭で関数型マイコンプログラミングの布教でゲッソ!\n"
"tags: meeting, ajhc, mbed, haskell\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:12
msgid ""
"Metasepi作戦会議 第12回を [mbed祭り 2014@冬の横浜](http://atnd.org/"
"events/46135#comments)  にて開催したでゲソ。 [こないだ名古屋で開催した関数型"
"マイコンプログラミング講習会](2014-01-05-mbed_fp_0.html)  の紹介とCMSIS-DAP対"
"応gdbserverの現状について発表してきたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:26
msgid ""
"ARMは最近 [mbed](http://mbed.org/handbook/)  というボード/チップ/開発環境を"
"ひっくるめた開発ブランドを立ち上げているでゲソ。 いままではArduino,STM32,"
"MSP430のようにメーカー単体でこのような開発ブランドを作ることはあったでゲソ"
"が、 ARM本体が手掛けることは稀だったじゃなイカ。 またこのmbedは [mbed-rtos]"
"(https://github.com/mbedmicro/mbed)  という基盤となる簡単なOSを配布していて、"
"異なるボードでも移植が済んでいればこのmbed-rtos上でほぼ同じC++コードが走るで"
"ゲソ。 さらに [CMSIS-DAP](https://github.com/mbedmicro/CMSIS-DAP) というデ"
"バッグチップの中のファームウェアも公開されたでゲソ! これでARMのチップをター"
"ゲットするかぎりにおいては、gdbserverに応答するボードを自作できるじゃなイ"
"カ。 このCMSIS-DAPに対応したgdbserverには [pyOCD](https://github.com/"
"mbedmicro/pyOCD) と [OpenOCD](http://openocd.sourceforge.net/) の二種類があ"
"り、 現状いろいろ難点があるでゲソが今後CMSIS-DAPの規格をベースに整備が進んで"
"いくことは間違いなさそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:33
msgid ""
"これまでこのようなARMの小規模マイコンは [STM32](http://www.st.com/web/jp/jp/"
"catalog/mmc/FM141/SC1169)  の独占市場だったと言っても過言ではないでゲソ。 し"
"かしそのSTも [\"STマイクロ、STM32マイコンでARM mbedプロジェクトに参加 ～mbed"
"対応の開発ボードを2月に提供\"](http://pc.watch.impress.co.jp/docs/"
"news/20131224_628778.html)  なのだそうで、ARM Cortex-Mシリーズに限っては一気"
"にmbedが持っていく可能性がいよいよ高まってきたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:39
msgid ""
"これによって割を食うのは誰でゲソ？ [FreeRTOS](http://www.freertos.org/)、 "
"[ChibiOS/RT](http://www.chibios.org/dokuwiki/doku.php)、 [ST-LINK/V2](http://"
"www.st-japan.co.jp/web/jp/catalog/tools/PF251168)、 ボードの価格が落ちてくれ"
"ばArduinoブランドにも影響を与えそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:46
msgid ""
"残念ながら今はCMSIS-DAPに対するOSSのgdbserverが不安定なので、 ST-LINK/V2を"
"使って安定したデバッグ環境を整えた方が良さそうでゲソ。 ただし、安定したらmbed"
"を使った方がユーザが獲得できるかもしれないので、 暫定的な開発環境だと割り切っ"
"た方がいいかもしれないでゲソ。 またOSもSTM32F4であればmbed-rtosが対応している"
"ので、 フットプリントに問題がなければFreeRTOSやChibiOS/RTではなくmbed-rtosを"
"全面的に採用してみるのも良いかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:50
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/30152773\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20140118-mbed-fest2014yokohama\" title=\"Functional MCU programming"
"\" target=\"_blank\">Functional MCU programming</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:54
msgid ""
"<iframe width=\"560\" height=\"315\" src=\"//www.youtube.com/embed/"
"XGlKlDtpOs0\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr ""

#. type: Plain text
#: posts/2014-01-18-mbed_fest.md:59
msgid ""
"![](/img/20140118_mbed_fest_1.png)  ![](/img/20140118_mbed_fest_2.png)  ![](/"
"img/20140118_mbed_fest_4.png)"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:5
#, no-wrap
msgid ""
"title: \"簡約!? λカ娘 Go!\"の紹介とAjhcプロジェクト近況\n"
"description: 半年にわたるAjhcの開発をまとめたでゲソー\n"
"tags: haskell, book, compiler, jhc, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:13
msgid ""
"またこの季節がやってきたでゲソ。 いつもの [関数型プログラミングの本](http://"
"www.paraiso-lang.org/ikmsm/books/c84.html)  が出るでゲソ!コミックマーケット"
"84 [3日目 東地区 ペ-06 a](http://twitcmap.jp/?id=0084-3-PEk-06-a)  で頒布予定"
"なので、みんな買ってほしいでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:15
msgid ""
"[![](http://www.paraiso-lang.org/ikmsm/images/c84-cover-s.jpg)](http://www."
"paraiso-lang.org/ikmsm/books/c84.html)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第1章 めたせぴ☆ふぁうんでーしょん # <= コレ書いた"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第2章 jhcコピペ # <= コレ書いた"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第3章 侵略者と転校生とアイドルとイカが再帰を学ぶそうですよ!"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第4章 殺物語"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第5章 λカ娘探索？"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第6章 ロマンティック・パージング"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:23
msgid "第7章 HaskEll Shaddai"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:30
msgid ""
"がもくじで、 [\\@master_q](https://twitter.com/master_q)  は1章と2章を書いた"
"らしいでゲソ。 記事が気になったら是非 [サンプル版pdf](http://www.paraiso-"
"lang.org/ikmsm/books/c84-sample.pdf)  を読んでみてほしいでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:34
msgid ""
"2章は完全ジョーク記事なので説明はとばすでゲソが、 1章はAjhcの記事で40ページも"
"のボリュームがあるでゲソ。 ここで少し中身を紹介したいと思うでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:36
msgid "## 記事のストーリー"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:38
msgid ""
"この\"めたせぴ☆ふぁうんでーしょん\"という記事はAjhcの半年にわたる開発をセミ"
"フィクションのストーリーで描いているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:42
msgid ""
"主人公の\"ぼく\"は組み込み開発に疲れ、遠くインドネシアで休養をしているでゲ"
"ソ。 そんなおり、\"ぼく\"はHaskellやOCamlのような強い型を持つ言語でOSのkernel"
"を再設計する一つのアイデアを思いつくでゲソ。 不安ながらもワシの予言に導かれて"
"3つのスケッチに挑戦することになるでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:46
msgid "NetBSD bootloaderの一部をHaskellで書いてみる"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:46
msgid "Cortex-M4マイコンデモプログラムの一部をHaskellで書いてみる"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:46
msgid ""
"Cortex-M4マイコンデモのどこまでHaskellで再設計できるのかその限界に挑戦する"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:48
msgid ""
"はたしてこの3つのスケッチ、つまり挑戦が成功するのか、その挑戦が終わった後に見"
"えてきた世界とはなんだったのか？というのが記事の流れでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:50
msgid "## 最近のAjhc開発状況"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:52
msgid ""
"このごろはAjhcの開発は一旦おやすみして、Ajhcの内部設計を解説する本を書いてい"
"るでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-07-24-ikamusume-c84.md:54
msgid ""
"Book: Ajhc Hacking Guide [https://github.com/ajhc/ajhc-hacking-guide]"
"(https://github.com/ajhc/ajhc-hacking-guide)"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:56
msgid ""
"コンパイラパイプラインの上段から順に調べて文章を書いているため、まだパーサの"
"途中...先は長いでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:60
msgid ""
"ワシの考えとしては、ワシ以外の人間がAjhcの中身を弄れるようにすることで開発を"
"加速したいと考えているんでゲソ。 また、HaskellライブラリをGHCから移植してくる"
"ためにはAjhcコンパイラ全体に手を入れる必要があるじゃなイカ。 一旦ここであらい"
"ざらい調べておかないと、いらぬミスをすることになるかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-07-24-ikamusume-c84.md:63
msgid ""
"本を書きおわった後の展望としてはいろいろ考えがあるでゲソがまだ [ヒ](https://"
"github.com/ajhc/ajhc/issues/29)[ミ](https://github.com/ajhc/demo-android-ndk)"
"[ツ](https://github.com/metasepi/chibios-arafura)[！](https://github.com/"
"ajhc/ajhc/issues/25)  でゲソー!"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:5
#, no-wrap
msgid ""
"title: Ajhcプロジェクトはじめよう\n"
"description: リポジトリを用意してjhcを改造しまくるでゲッソ!\n"
"tags: haskell, compiler, jhc, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:17
msgid ""
"これまで [jhc](http://repetae.net/computer/jhc/)  のソースコードを読みながら"
"少しずつ改造をして遊んでいたでゲソが、 そろそろpatchが増えてきてまっとうなリ"
"ポジトリを用意しないと破綻しそうでゲソ。 できればpatchをjhc本家に取り込んでも"
"らいたいところでゲソ。 ところが原作者の[John](http://repetae.net/pictures/"
"pirate1.jpg)がどうも忙しいらしく、なかなかmergeしてくれないでゲソ...  ^[[Ajhc"
"のファーストリリース](http://www.haskell.org/pipermail/haskell-cafe/2013-"
"March/107013.html)  をしたら [全部merge](http://repetae.net/dw/darcsweb.cgi?"
"r=jhc)してくれたでゲソ。 [Johnはやる気になればデキる男](http://repetae.net/"
"pictures/cso/john_cso2_small.jpg)なんでゲソ!]"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:24
msgid ""
"あまりプロジェクトのforkをしたくないところでゲソが、 このままでは作業が進まな"
"いのでjhc向けpatchを貯めるだけのプロジェクトを作ったでゲソ。 その名も [Ajhc "
"- arafura-jhc](http://ajhc.masterq.net/)  ^[もしくは単に\"A fork of jhc\"を略"
"して\"Ajhc\"] でゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:26
msgid "## まず最初の改造は？"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:34
msgid ""
"とはいえ改造にあたって何かテーマを決めたいでゲソ。 jhcは小さなバイナリを吐け"
"るのだから、小さなマイコンでHaskellコードを動かすとかどうでゲソ？ 例えば以下"
"のようなマイコンであればある程度メモリもあるのでなんとなるんじゃなイカ？JTAG"
"も付いてるのでgdbでデバッグもできるでゲソ。 しかも秋月価格で[￥950(税込)]"
"(http://akizukidenshi.com/catalog/g/gM-06268/)  と無茶苦茶安いでゲソ。 ところ"
"でこの挑発的な価格はいったいなんなんでゲソ...  ST、怒らせると怖い子でゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:36
msgid ""
"[![](https://raw.github.com/ajhc/demo-cortex-m3/master/img/stm32f3-discovery."
"jpg)](http://www.st.com/web/en/catalog/tools/FM116/SC959/SS1532/PF254044)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-03-16-found_ajhc.md:41
msgid ""
"Name: [STM32F3DISCOVERY](http://www.st.com/web/en/catalog/tools/FM116/SC959/"
"SS1532/PF254044)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-03-16-found_ajhc.md:41
msgid "CPU: STM32F303VCT6"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-03-16-found_ajhc.md:41
msgid "ROM: 256kB"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-03-16-found_ajhc.md:41
msgid "RAM: 48kB"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:46
msgid ""
"ぐぬぬぬ...ということで [移植できたでゲソ](https://github.com/ajhc/demo-"
"cortex-m3)! ちゃんとHaskellヒープも使えてGCも動くでゲソ。 RAMは28kBしか使って"
"いないでゲッソ!!!"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:53
#, no-wrap
msgid ""
"    $ pwd\n"
"    /home/kiwamu/src/demo-cortex-m3/stm32f3-discovery\n"
"    $ make\n"
"    $ arm-none-eabi-size main.elf\n"
"       text    data     bss     dec     hex filename\n"
"      15796    1160   26876   43832    ab38 main.elf\n"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:55
#, fuzzy
#| msgid ""
#| "<script type=\"text/javascript\" src=\"http://ext.nicovideo.jp/"
#| "thumb_watch/sm19788831\"></script><noscript><a href=\"http://www."
#| "nicovideo.jp/watch/sm19788831\">【ニコニコ動画】Metasepi arafura first "
#| "boot.</a></noscript>"
msgid ""
"<script type=\"text/javascript\" src=\"http://ext.nicovideo.jp/thumb_watch/"
"sm20336813\"></script><noscript><a href=\"http://www.nicovideo.jp/watch/"
"sm20336813\">【ニコニコ動画】STM32の上でモールス信号をパタパタしてみた。もち"
"ろんHaskellで</a></noscript>"
msgstr ""
"<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/"
"embed/0DPA7GC0_-0\" frameborder=\"0\" allowfullscreen></iframe>"

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:57
msgid "## どこらへんを修正したの？"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:62
msgid ""
"Ajhcへの変更は [このpatch](https://github.com/ajhc/ajhc/"
"commit/3167551530b0576cf1f42f928865868ce9aa0b50)  だけでゲソ。 修正内容を解説"
"するでゲソー。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-03-16-found_ajhc.md:69
msgid "BLOCK_SIZEとMEGABLOCK_SIZEをMakefileから調整できるように"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-03-16-found_ajhc.md:69
msgid "MEGABLOCKを唯一1つだけ使い、動的確保しないように"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-03-16-found_ajhc.md:69
msgid ""
"Cortex-M3では関数ポインタジャンプのアドレスbit0を1立てる ([詳細](http://"
"communities.mentor.com/community/cs/archives/arm-gnu/msg01904.html))"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-03-16-found_ajhc.md:69
msgid "BLOCKが不足したら即時GCするNaive GCフラグ"
msgstr ""

#. type: Bullet: '5. '
#: posts/2013-03-16-found_ajhc.md:69
msgid "GCスタックの成長幅をMakefileから調整できるように"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:75
msgid ""
"このpatchのあたったAjhcを使って、 [いろいろこねくりまわせ](https://github."
"com/ajhc/demo-cortex-m3#porting-the-demo-to-a-new-platform)  ば [こんなの]"
"(https://github.com/ajhc/demo-cortex-m3/tree/master/stm32f3-discovery)  がで"
"きるんでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:77
msgid "## Ajhcプロジェクトはどこへ向かうの？"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:88
msgid ""
"完全にjhcをforkして一人歩きする予定はAjhcプロジェクトにはないでゲソ。 Ajhcは"
"あくまでjhcにmergeされていないpatchをためておくための器にすぎないのでゲソ。 "
"そのため有用なpatchは [jhcメーリングリスト](http://www.haskell.org/mailman/"
"listinfo/jhc)  にて協議の上 [jhcにmerge](https://github.com/ajhc/ajhc#for-"
"developing)  してもらわなければならないでゲソ。 在りし日の [EGCS "
"(Experimental/Enhanced GNU Compiler System)](http://ja.wikipedia.org/wiki/GNU"
"%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%82%B3%E3%83%AC%E3%82%AF"
"%E3%82%B7%E3%83%A7%E3%83%B3#EGCS)  のように、jhc本体の活動が活発になったら"
"Ajhcは消滅すべきプロジェクトでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-03-16-found_ajhc.md:91
msgid ""
"Ajhcプロジェクトの [ロードマップ的なにか](https://github.com/ajhc/"
"ajhc#future-plan)  を書いてみたでゲソが、予定は未定。どーなるかわからないでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第9回 議事録\n"
"description: 「モノのインターネット」(IoT：Internet of Things)を関数型言語で先取りでゲソ!\n"
"tags: meeting, ajhc, ats, rust, mbed\n"
"---\n"
msgstr ""
"title: Metasepi team meeting #9\n"
"description: Let's prefetch Internet of Things (IoT) using functional language!\n"
"tags: meeting, ajhc, ats, rust, mbed\n"
"---\n"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:10
msgid ""
"Metasepi作戦会議 第9回を [mbedではじめる関数型マイコンプログラミング講習会β]"
"(http://partake.in/events/ab56454b-c305-4f3b-b8ce-872871ab7da9)  というのを"
"やってみたでゲソ。"
msgstr ""
"We had [Functional MCU programming training using mbedβ](http://partake.in/events/ab56454b-c305-4f3b-b8ce-872871ab7da9)\n"
"as \"Metasepi team meeting #9\"."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:26
msgid ""
"みんなは [「モノのインターネット」(IoT：Internet of Things)](http://ja."
"wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF"
"%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88)  という言葉を聞いたことがあるでゲソ？ "
"古くはユビキタス社会と呼ばれていたでゲソが、それの別名が最近付けられたのでゲ"
"ソ。 バスケットボールのようなこれまでなんの変哲もない物体にもマイコンを搭載し"
"て、 データー収集をしたりインテリジェントな応答を返させたりしようというのでゲ"
"ソ。 [「モノのインターネット」製造業への経済効果は2850億ドル――ガートナー]"
"(http://monoist.atmarkit.co.jp/mn/articles/1310/15/news009.html)  なのだそう"
"で、金額はともかくとしても注目されている分野であることには違いないでゲソ。 こ"
"のIoTのデバイスはコスト重視になるはずなので、LinuxのようなリッチなOSは搭載で"
"きないと思うでゲソ。 さらにネットワークに接続することが必須となるために"
"BluetoothやWifiをしゃべれなければならないはずじゃなイカ。 そのような複雑な機"
"器にもかかわらず出荷後に製品をデバッグすることは困難、つまりランタイムエラー"
"をなんらかの方法で削減しなければならないのでゲソ。 そこで昨年ワシが調べていた"
"ように強い型を使った言語を設計に使うことで設計工数を押さえつつランタイムエ"
"ラーを削減できるはずじゃなイカ。 Ajhcがその解決策になるかどうかは不透明でゲソ"
"が、とにかく「関数型言語 + マイコン」という分野のコミュニティを作ることは有益"
"だと思ったのでゲソ。 そのような講習会のコースを作るために、まずは関数型言語"
"ユーザの多い名古屋でβ版を開催しようということになったのでゲソ。 この講習会は"
"続けて開催する予定で、今回はその準備編ということになるんじゃなイカ。"
msgstr ""
"Do you know [Internet of Things (IoT)](http://en.wikipedia.org/wiki/Internet_of_Things)?\n"
"People advocating IoT would like to let non-descriptive things collect data on the location or behave more intelligentially, with injecting MCU into the things such like basketball.\n"
"Gartner Says [\"the Internet of Things Installed Base Will Grow to 26 Billion Units By 2020\"](http://www.gartner.com/newsroom/id/2636073),\n"
"then IoT is a big market while dollar amount may be inaccurate.\n"
"However, rich OS such like Linux can't run on IoT device,\n"
"because the device should be very inexpensive.\n"
"Furthermore, it talks Bluetooth and Wifi to connect the internet.\n"
"We need to get less runtime errors on the complex device,\n"
"because it's hard to debug after published.\n"
"I think we satisfy both of less man-hours and less runtime errors,\n"
"as my research that design it using strongly typed language.\n"
"Then, how about launch \"Functional language + MCU programming\" community,\n"
"while Ajhc has unknown to solve the claim.\n"
"To build Functional MCU programming training course for the community,\n"
"we held beta version the course at [Nagoya](http://en.wikipedia.org/wiki/Nagoya)\n"
"in where many functional programmer live.\n"
"There is a plan to hold the courses continuously."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:29
msgid ""
"ところで、昨年の検討結果からマイコンプログラミングが可能な静的型付け関数型言"
"語の選択肢はイカのようでゲソ。 今年はそれぞれの言語処理系の評価をして、"
"Arafuraより後のイテレーションに何れを採用するか見当をつけたいでゲソ。"
msgstr ""
"By the way, There is following choice to be statically typed functional programming language can do MCU programming.\n"
"This year, we would like to survey each languages,\n"
"and decide to employ which language after Arafura iteration."

#. type: Bullet: '* '
#: posts/2014-01-05-mbed_fp_0.md:33
msgid "[Ajhc](http://ajhc.metasepi.org/)"
msgstr "[Ajhc](http://ajhc.metasepi.org/)"

#. type: Bullet: '* '
#: posts/2014-01-05-mbed_fp_0.md:33
msgid "[ATS](http://www.ats-lang.org/)"
msgstr "[ATS](http://www.ats-lang.org/)"

#. type: Bullet: '* '
#: posts/2014-01-05-mbed_fp_0.md:33
msgid "[Rust](http://www.rust-lang.org/)"
msgstr "[Rust](http://www.rust-lang.org/)"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:43
msgid ""
"Ajhcはこれまでワシが技術探索してきた成果でゲソ。 ATSはこないだ [ユーザーグ"
"ループを作って](2013-12-24-jats-ug.html) 詳細調査中。 またRustは大変開発が活"
"発なので [Rust 'n Stuffs](http://cmr.github.io/)  をRSS購読しておくと良いと "
"[\\@pirapira](https://twitter.com/pirapira)  殿におそわったでゲソ。ありがとう"
"でゲソー! それにしてもAjhcをはじめた時はjhcしか処理系の候補がなかったのに、 "
"今は3つも選択肢があるとは嬉しい悲鳴という奴じゃなイカ。"
msgstr ""
"Ajhc is the result of our own research.\n"
"ATS is under survey on [the user group launched the other day](2013-12-24-jats-ug.html).\n"
"For Rust, [\\@pirapira](https://twitter.com/pirapira) has a idea reading RSS of [Rust 'n Stuffs](http://cmr.github.io/), because developing speed of the Rust is very fast.\n"
"Thank's a lot!\n"
"Anyway, we have three choices today, while Ajhc is only hope when Ajhc project was started\n"
"How shriek of joy!"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:52
msgid ""
"今回の会場は [コワーキングスペース「ベースキャンプ名古屋」](http://basecamp-"
"nagoya.jp/)  さんをお借りしたでゲソ。 [スタッフブログにこの講習会が掲載され]"
"(http://basecamp-nagoya.jp/blog/entry-794.html)  ているでゲソ。 またこの講習"
"会参加者のコワーキングスペース利用料金を [ITプランニング](http://www.itpl.co."
"jp/)  殿に援助してもらったでゲソ。うれしいじゃなイカー。ありがとうでゲッソ!"
msgstr ""
"We took on the [basecamp NAGOYA](http://basecamp-nagoya.jp/) for this meeting.\n"
"[The stuff blog posts about this meeting.](http://basecamp-nagoya.jp/blog/entry-794.html)\n"
"Also, usage fee on this meeting is paid by [IT Planning, Inc.](http://www.itpl.co.jp/en/)\n"
"So happy and thank's!"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:56
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29698577\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/functional-mcu-programming-0-development-environment\" title="
"\"Functional MCU programming #0: Development environment\" target=\"_blank"
"\">Functional MCU programming #0: Development environment</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr "<iframe src=\"http://www.slideshare.net/slideshow/embed_code/29698577\" width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/master_q/functional-mcu-programming-0-development-environment\" title=\"Functional MCU programming #0: Development environment\" target=\"_blank\">Functional MCU programming #0: Development environment</a> </strong> from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:58
msgid "## 発表音声"
msgstr "## Sound recording at the meeting"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:60
msgid ""
"<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" "
"src=\"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/"
"tracks/128115689&amp;color=ff6600&amp;auto_play=false&amp;show_artwork=true"
"\"></iframe>"
msgstr "<iframe width=\"100%\" height=\"166\" scrolling=\"no\" frameborder=\"no\" src=\"https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/128115689&amp;color=ff6600&amp;auto_play=false&amp;show_artwork=true\"></iframe>"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:62
msgid "## 旅の情報 (名古屋)"
msgstr "## Travel Guide (Nagoya)"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:64
msgid ""
"この講習会は名古屋で続けて開催する予定なので、詳しく旅の情報を記録しておこう"
"と思うでゲソ。"
msgstr "This travel guide may be useful, because we will have many meeting at Nagoya."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:66
msgid "### 交通"
msgstr "### Methods of transport"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:71
msgid ""
"高速バスは安いでゲソ。 [夜行バス比較なび 全国の夜行バスの最安値情報](http://"
"www.bushikaku.net/)  から検索すれば 東京→名古屋 を片道2000円程度で移動できる"
"でゲソ。 ただし、年末年始は相場が高めだったでゲソ...盲点だっだじゃなイカ。"
msgstr ""
"Highway express bus is inexpensive method to trip Nagoya from Tokyo.\n"
"Using [夜行バス比較なび](http://www.bushikaku.net/),\n"
"you can find ticket 2000 yen per one way.\n"
"However, there are no inexpensive ticket during the year change period."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:73
msgid "### 宿"
msgstr "### Hotel"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:81
msgid ""
"ホテルはいつも [じゃらんnet](http://www.jalan.net/)  で探しているのでゲソが、"
"どうも名古屋近郊だといつでも [カプセルイン名古屋](http://www.jalan.net/"
"yad335292/plan/)  が最安値のようでゲソ。2500円で一泊できるでゲソ。 ホテル自体"
"は、、、まぁ可も不可もない感じでゲソ。 カプセルの中に電源がないので注意が必要"
"でゲソ。"
msgstr ""
"I always find hotel on [じゃらんnet](http://www.jalan.net/).\n"
"In Nagoya, [カプセルイン名古屋](http://www.jalan.net/yad335292/plan/) is lowest price as 2500 yen per night.\n"
"Quality of the hotel is .... so not bad.\n"
"Note capsule room in the hotel has no power resource."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:83
msgid "### 朝、温泉に入りたい"
msgstr "### Hot spring early morning"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:89
msgid ""
"夜行高速バスで移動すると、どうしてもひとっ風呂あびたくなるでゲソ。 少し駅から"
"遠いでゲソが [太閤天然温泉　湯吉郎](http://www.toukichirou.com/index.html)  "
"は土日祝日にかぎって朝6時から開いているので、おすすめでゲソー。 タオルが有料"
"なので持参すべきでゲソ。"
msgstr ""
"After exiting highway express bus, I would like to take a bath.\n"
"[太閤天然温泉　湯吉郎](http://www.toukichirou.com/index.html) open since 6.00 a.m. on Saturday and Sunday,\n"
"however the hot spring is far away from Nagoya station.\n"
"Note you should have your own towel, because there are no free towels in the hot spring."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:91
msgid "### スタバでもくもく"
msgstr "### Hack place"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:95
msgid ""
"[栄駅近辺には多くのスタバがひしめいている](http://www.starbucks.co.jp/store/"
"search/detail.php?id=389)  でゲソ。たいだい電源があり、夜22:30ぐらいまで開い"
"ているようでゲソ。 作業場所に困ることはなさそうでゲソ。"
msgstr ""
"There are many Starbucks Coffee shops\n"
"[around Sakae](http://www.starbucks.co.jp/store/search/detail.php?id=389).\n"
"These shop almost have power resource, and open until 22:30 p.m.\n"
"You will have no trouble to find hack place."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:97
msgid "### マルツパーツ"
msgstr "### Electronic components store"

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:110
msgid ""
"[マルツパーツ館　名古屋小田井店](http://www.marutsu.co.jp/nagoyaotai/)  は名"
"古屋にある唯一のパーツショップのようでゲソ。 ^[[\\@ytsuboiからツッコミ]"
"(https://twitter.com/ytsuboi/status/420159418789924864) で [「大須あたりには"
"もっとたくさんあります」](http://osu-ameyoko.co.jp/?page_id=272)  だそうでゲ"
"ソ!] 1Fにマイコンボードが置いてあり [STM32F4DISCOVERY](http://www.st.com/web/"
"jp/catalog/tools/FM116/SC959/SS1532/PF252419)  と [STM32VLDISCOVERY](http://"
"www.st.com/web/jp/catalog/tools/FM116/SC959/SS1532/PF250863)  が置いてあった"
"でゲソ。やはりワシが最初にターゲットにした [STM32F3DISCOVERY](http://www.st-"
"japan.co.jp/web/jp/catalog/tools/PF254044)  はマイナーなボードだったようでゲ"
"ソ。。。"
msgstr ""
"There is [マルツパーツ館　名古屋小田井店](http://www.marutsu.co.jp/nagoyaotai/) as only electronic components store at Nagoya.\n"
"^[[\\@ytsuboi say](https://twitter.com/ytsuboi/status/420159418789924864) [\"There are many shop around Osu.\"](http://osu-ameyoko.co.jp/?page_id=272)]\n"
"Many single-board computers are on ground floor.\n"
"I found [STM32F4DISCOVERY](http://www.st.com/web/jp/catalog/tools/FM116/SC959/SS1532/PF252419)\n"
"and [STM32VLDISCOVERY](http://www.st.com/web/jp/catalog/tools/FM116/SC959/SS1532/PF250863).\n"
"[STM32F3DISCOVERY](http://www.st-japan.co.jp/web/jp/catalog/tools/PF254044) as first target board on Ajhc project may be not popular..."

#. type: Plain text
#: posts/2014-01-05-mbed_fp_0.md:117
msgid ""
"![](/img/20140105_mbed_fp_meeting.jpg)  ![](/img/20140105_R1098744.jpg)  ![]"
"(/img/20140105_R1098746.jpg)  ![](/img/20140105_R1098739.jpg)  ![](/"
"img/20140105_R1098741.jpg)"
msgstr "![](/img/20140105_mbed_fp_meeting.jpg)  ![](/img/20140105_R1098744.jpg)  ![](/img/20140105_R1098746.jpg)  ![](/img/20140105_R1098739.jpg)  ![](/img/20140105_R1098741.jpg)"

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:5
#, no-wrap
msgid ""
"title: ocamloptの全体像\n"
"description: ocamloptのランタイムとコンパイルパイプラインを知らべてみたでゲソ!\n"
"tags: ocaml, internal\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:8
msgid "## 発端"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:10
msgid "![](/img/20130213-nomore_camlp4.png)"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:12
msgid ""
"[ocamloptを読むことになりました。 - Togetter](http://togetter.com/li/450580)"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:15
msgid "Camlp4だけはこわいんでゲソ...  逃げるしかないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:20
msgid ""
"考えてみると、確かにアラフラにはjhcを採用する予定でゲソが、 ひょっとしたらこ"
"のデザインに致命的な欠陥が見つかる可能性も高いでゲソ。 その場合、OCamlは代替"
"案として大変有望でゲソ。 今のうちに調べておいて損はないんじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:23
msgid ""
"[簡単なプログラム](https://github.com/master-q/read_ocamlopt/)  を作ってみ"
"て、コンパイル結果とocamloptを比較すればだいたいわかるはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:40
#, no-wrap
msgid ""
"~~~\n"
"$ uname -a\n"
"Linux casper 3.2.0-4-amd64 #1 SMP Debian 3.2.35-2 x86_64 GNU/Linux\n"
"$ pwd\n"
"/home/kiwamu/src/read_ocamlopt\n"
"$ ocamlopt -version\n"
"4.00.1\n"
"$ cat helloworld/helloworld.ml\n"
"let hello _ = print_endline \"Hello world!\";;\n"
"let _ = hello ();\n"
"$ make\n"
"ocamlopt -verbose -dstartup -o helloworld/helloworld helloworld/helloworld.ml\n"
"+ as -o 'helloworld/helloworld.o' '/tmp/camlasm034093.s'\n"
"+ as -o '/tmp/camlstartup43810e.o' 'helloworld/helloworld.startup.s'\n"
"+ gcc -o 'helloworld/helloworld'   '-L/usr/local/lib/ocaml'  '/tmp/camlstartup43810e.o' '/usr/local/lib/ocaml/std_exit.o' 'helloworld/helloworld.o' '/usr/local/lib/ocaml/stdlib.a' '/usr/local/lib/ocaml/libasmrun.a' -lm  -ldl\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:42
msgid ""
"ということは以下のファイルについて調べればocamloptの全体像がわかるはずでゲ"
"ソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-02-13-ocamlopt.md:46
msgid ""
"[helloworld.startup.s](https://github.com/master-q/read_ocamlopt/blob/master/"
"helloworld/helloworld.startup.s) - 起動プロセスについて"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-02-13-ocamlopt.md:46
msgid "libasmrun.a - ランタイムについて"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-02-13-ocamlopt.md:46
msgid "helloworld.o - コンパイルパイプラインについて"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:48
msgid "## 起動プロセスについて"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:59
msgid ""
"~~~ $ pwd /home/kiwamu/src/read_ocamlopt/helloworld $ gdb helloworld (gdb) b "
"camlHelloworld__hello_1030 Breakpoint 1 at 0x403560 (gdb) run Starting "
"program: /home/kiwamu/src/read_ocamlopt/helloworld/helloworld warning: Could "
"not load shared library symbols for linux-vdso.so.1.  Do you need \"set "
"solib-search-path\" or \"set sysroot\"?"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:70
msgid ""
"Breakpoint 1, 0x0000000000403560 in camlHelloworld__hello_1030 ()  (gdb) bt "
"#0 0x0000000000403560 in camlHelloworld__hello_1030 ()  #1 "
"0x0000000000403591 in camlHelloworld__entry ()  #2 0x00000000000003e8 in ?? "
"()  #3 0x0000000000403229 in caml_program ()  #4 0x000000000002950d in ?? "
"()  #5 0x0000000000411a52 in caml_start_program ()  #6 0x0000000000000000 "
"in ?? ()  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:74
msgid ""
"スタックが小細工されているけれど、 caml_start_program関数を呼び出すのは"
"asmrun/startup.cなので、 以下のようなコールグラフになるはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:114
#, no-wrap
msgid ""
"~~~\n"
"caml_main (asmrun/startup.c)\n"
"=> caml_init_custom_operations(); /* これocamlopt nativeでも必要？ */\n"
"   caml_register_custom_operations(&caml_int32_ops);\n"
"   caml_register_custom_operations(&caml_nativeint_ops);\n"
"   caml_register_custom_operations(&caml_int64_ops);\n"
"parse_camlrunparam(); /* OCAMLRUNPARAM環境変数の解析 */\n"
"=> caml_init_gc (minor_heap_init, heap_size_init, heap_chunk_init,\n"
"                 percent_free_init, max_percent_free_init);\n"
"   caml_page_table_initialize(Bsize_wsize(minor_size) + major_heap_size);\n"
"   caml_set_minor_heap_size (Bsize_wsize (norm_minsize (minor_size)));\n"
"   caml_major_heap_increment = Bsize_wsize (norm_heapincr (major_incr));\n"
"   caml_percent_free = norm_pfree (percent_fr);\n"
"   caml_percent_max = norm_pmax (percent_m);\n"
"   caml_init_major_heap (major_heap_size);\n"
"init_atoms();\n"
"/* なんだろ？Initialize the atom table and the static data and code area limits. */\n"
"caml_init_signals();\n"
"/* スタックあふれ検出 */\n"
"sigsetjmp(caml_termination_jmpbuf.buf, 0); /* 例外かな？ */\n"
"=> caml_start_program (asmrun/amd64.S)\n"
"   /* r12-r15はcallee-savedなので、レジスタで取りまわすことはないはず... */\n"
"   push caml_gc_regs\n"
"   push caml_last_return_address\n"
"   push caml_bottom_of_stack\n"
"   /* caml_young_ptrをr15にロード */\n"
"   /* caml_exception_pointerをr14にロード */\n"
"   /* Exception handlerをr13にロード */\n"
"   push r13\n"
"   push r14\n"
"   /* スタックポインタをr14にロード */\n"
"   /* r12にentry_pointを取りcall */\n"
"   => caml_program (helloworld.startup.s)\n"
"      => camlPervasives__entry\n"
"         => register_named_value \"Pervasives.do_at_exit\" do_at_exit\n"
"            => caml_register_named_value /* プロセス終了時にflushするように */\n"
"      caml_globals_inited += 1\n"
"      => camlHelloworld__entry /* <= OCamlコード */\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:119
msgid ""
"ところで、上記のような解析をする際にはocamloptでコンパイルされた実行バイナリ"
"をobjdump -Sで見てみると良いでゲソ。 C言語の場合と同じように元のOCamlソース"
"コードがまざって見えるので読みやすいでゲソ。 OCamlは本当に取り回しの良い、安"
"心して使える言語でゲソ。 これが歴史の重みという奴じゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:121
msgid "## ランタイムについて"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:126
msgid ""
"んー。やっぱり無茶苦茶多いじゃなイカ...  でもこれ全部本当に必要なのカ？ 機能"
"を限定すれば削れそうなものもありそうでゲソ。 ちょっと今はocamloptを本格的に使"
"うかわからないので、これらの詳細調査は遠慮したいでゲッソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:131
msgid ""
"もし使う時が来たら、また [簡約! λカ娘(4) - 参照透明な海を守る会](http://www."
"paraiso-lang.org/ikmsm/books/c83.html)  でやったようにランタイムのサイズ削減"
"をやってみれば、自然に中身に手垢をつけられるはずでゲソ。 その時が楽しみでゲッ"
"ソ!"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:177
#, no-wrap
msgid ""
"~~~\n"
"$ size /usr/local/lib/ocaml/libasmrun.a|grep libasmrun.a|sort -k 6\n"
"   1696       0       0    1696     6a0 alloc.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1108      24       0    1132     46c amd64.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3656       0       0    3656     e48 array.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1342       8      16    1366     556 backtrace.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1150       0     104    1254     4e6 callback.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3165       0       8    3173     c65 compact.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2585      16    6144    8745    2229 compare.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    633       0      16     649     289 custom.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"     94      12       4     110      6e debugger.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    421       0       0     421     1a5 dynlink.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   6569      24   20640   27233    6a61 extern.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1272      40      40    1352     548 fail.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1815       0      56    1871     74f finalise.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3836       0       0    3836     efc floats.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2791      64    8056   10911    2a9f freelist.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   4628       0      72    4700    125c gc_ctrl.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1524       0     476    2000     7d0 globroots.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2369       0      24    2393     959 hash.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   7196      16    6240   13452    348c intern.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   6343     184       0    6527    197f ints.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   7217      56      40    7313    1c91 io.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    938       0       0     938     3aa lexing.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"     80       0       0      80      50 main.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3960       0      80    4040     fc8 major_gc.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3529       0       0    3529     dc9 md5.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   3256       0      40    3296     ce0 memory.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    310       0       0     310     136 meta.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2373       0     200    2573     a0d minor_gc.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    701       0       8     709     2c5 misc.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1721       0       0    1721     6b9 natdynlink.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1531       0       0    1531     5fb obj.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2220       0       4    2224     8b0 parsing.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    917       0       0     917     395 printexc.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2316       8      80    2404     964 roots.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1347      24      32    1403     57b signals.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    804       0    8200    9004    232c signals_asm.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1502      48     288    1838     72e startup.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1261       0       4    1265     4f1 str.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2706      36       8    2750     abe sys.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"    202       0       0     202      ca terminfo.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   1532       0       0    1532     5fc unix.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"   2181       8      16    2205     89d weak.o (ex /usr/local/lib/ocaml/libasmrun.a)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:179
msgid "## コンパイルパイプラインについて"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:181
msgid "まずはコールグラフを書いてみたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:217
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"main\n"
"Arg.parse (Arch.command_line_options @ Options.list) anonymous usage;\n"
"=> process_file Format.err_formatter\n"
"   => process_implementation_file ppf name\n"
"      => Optcompile.implementation ppf name opref (* <= コンパイルパイプライン本体 *)\n"
"         let (++) x f = f x in\n"
"         let (+++) (x, y) f = (x, f y) in\n"
"         let inputfile = Pparse.preprocess sourcefile in\n"
"         Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number\n"
"             (* :: Parsetree.structure *)\n"
"         ++ print_if ppf Clflags.dump_parsetree Printast.implementation\n"
"             (* :: Parsetree.structure -> Parsetree.structure *)\n"
"         ++ Typemod.type_implementation sourcefile outputprefix modulename env\n"
"             (* :: Parsetree.structure -> Typedtree.structure * Typedtree.module_coercion *)\n"
"         ++ Translmod.transl_store_implementation modulename\n"
"             (* :: Typedtree.structure * Typedtree.module_coercion -> int * Lambda.lambda *)\n"
"         +++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda\n"
"             (* :: Lambda.lambda -> Lambda.lambda *)\n"
"         +++ Simplif.simplify_lambda\n"
"             (* :: Lambda.lambda -> Lambda.lambda *)\n"
"         +++ print_if ppf Clflags.dump_lambda Printlambda.lambda\n"
"             (* :: Lambda.lambda -> Lambda.lambda *)\n"
"         ++ Asmgen.compile_implementation outputprefix ppf;\n"
"             (* :: int * Lambda.lambda -> unit *)\n"
"         Compilenv.save_unit_info cmxfile; (* <= コンパイル済みcurrent_unitをファイル書き込み *)\n"
"=> Asmlink.link ppf (List.rev !objfiles) target;\n"
"   make_startup_file ppf startup units_tolink; (* <= helloworld.startup.sファイル生成 *)\n"
"   => Proc.assemble_file startup startup_obj\n"
"      Ccomp.command (Config.asm ^ \" -o \" ^\n"
"        Filename.quote outfile ^ \" \" ^ Filename.quote infile)\n"
"      (* gasでオブジェクトファイルに *)\n"
"   call_linker (List.map object_file_name objfiles) startup_obj output_name;\n"
"   => Ccomp.call_linker mode output_name files c_lib;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:222
msgid ""
"少し混乱しやすいでゲソが、 Argモジュールは単にコマンド引数を解析するだけでな"
"く、 [標準ライブラリArgモジュール](http://ocaml.jp/Arg)  にある通り、"
"anonymous関数を引数を適用するんでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:229
msgid ""
"Optcompile.implementation関数がコンパイルパイプラインの本体で、 Haskellのdoと"
"比較すると、 ++ が >> で、 +++ が >>= みたいな感じでゲソ。 あくまで感じであっ"
"てモナドとかそんな高尚なもんじゃないでゲソ。 つまり内側から外側に向かって処理"
"が進むようでゲソ。 最初ギョっとするでゲソが、慣れれば読みやすいでゲソ。 "
"print_ifは無視できるので、コンパイルパイプラインを抜き出すと..."
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:243
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"let inputfile = Pparse.preprocess sourcefile in\n"
"Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number\n"
"    (* :: Parsetree.structure *)\n"
"++ Typemod.type_implementation sourcefile outputprefix modulename env\n"
"    (* :: Parsetree.structure -> Typedtree.structure * Typedtree.module_coercion *)\n"
"++ Translmod.transl_store_implementation modulename\n"
"    (* :: Typedtree.structure * Typedtree.module_coercion -> int * Lambda.lambda *)\n"
"+++ Simplif.simplify_lambda\n"
"    (* :: Lambda.lambda -> Lambda.lambda *)\n"
"++ Asmgen.compile_implementation outputprefix ppf;\n"
"    (* :: int * Lambda.lambda -> unit *)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:245
msgid ""
"それでは、このコンパイルパイプラインに注目して再度コールグラフを書いてみよう"
"じゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:298
#, no-wrap
msgid ""
"~~~ {.ocaml}\n"
"Optcompile.implementation ppf name opref\n"
"=> let inputfile = Pparse.preprocess sourcefile in\n"
"   let comm = Printf.sprintf \"%s %s > %s\" pp (Filename.quote sourcefile) tmpfile in\n"
"   Ccomp.command comm (* 指定されたプリプロセッサコマンドにかける *)\n"
"=> Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number\n"
"   Location.input_name := inputfile;\n"
"   let lexbuf = Lexing.from_channel ic in\n"
"   Location.init lexbuf inputfile;\n"
"   => Parse.implementation lexbuf\n"
"      => wrap Parser.implementation (* パーサ本体 *)\n"
"=> ++ Typemod.type_implementation sourcefile outputprefix modulename env\n"
"   let (str, sg, finalenv) = type_structure initial_env ast Location.none in\n"
"   let simple_sg = simplify_signature sg in\n"
"   check_nongen_schemes finalenv str.str_items;\n"
"   normalize_signature finalenv simple_sg;\n"
"   let coercion = Includemod.compunit sourcefile sg \"(inferred signature)\" simple_sg in\n"
"   Typecore.force_delayed_checks (); (* 型推論の本体 *)\n"
"   (str, coercion) (* :: Typedtree.structure * Typedtree.module_coercion *)\n"
"=> ++ Translmod.transl_store_implementation modulename\n"
"   => transl_store_gen module_name (str, restr) false\n"
"      let (map, prims, size) = build_ident_map restr (defined_idents str) in\n"
"      let f = function\n"
"        | [ { str_desc = Tstr_eval expr } ] when topl ->\n"
"            assert (size = 0);\n"
"            subst_lambda !transl_store_subst (transl_exp expr)\n"
"        | str -> transl_store_structure module_id map prims str in\n"
"      transl_store_label_init module_id size f str\n"
"      (* λ項に変換してるらしい、返値のintはサイズみたい *)\n"
"=> +++ Simplif.simplify_lambda\n"
"   => let lam = simplify_exits lam (* なんだろう？ *)\n"
"   => simplify_lets lam\n"
"      (* 最適化。だいたい以下？\n"
"         * コンパイル時β簡約\n"
"         * 未使用のletを削除。またlet参照を値にする *)\n"
"=> ++ Asmgen.compile_implementation outputprefix ppf;\n"
"   (* λ項からアセンブリコードへ *)\n"
"   Emit.begin_assembly(); (* アセンブラファイルのヘッダを書き込む *)\n"
"   => Closure.intro size lam (* :: Clambda.ulambda *)\n"
"      let (ulam, approx) = close Tbl.empty Tbl.empty lam in ulam\n"
"      (* アンカリー化、直接呼び出し *)\n"
"   ++ Cmmgen.compunit size (* :: Clambda.ulambda -> Cmm.phrase list *)\n"
"   (* λ項からC--へ *)\n"
"   ++ List.iter (compile_phrase ppf) (* :: Cmm.phrase list -> unit *)\n"
"   compile_phrase ppf\n"
"     (Cmmgen.reference_symbols\n"
"        (List.filter (fun s -> s <> \"\" && s.[0] <> '%')\n"
"           (List.map Primitive.native_name !Translmod.primitive_declarations))\n"
"     ); (* 関数とデータをアセンブラファイルに書き込む *)\n"
"   Emit.end_assembly(); (* アセンブラファイルのフッタを書き込む *)\n"
"   Proc.assemble_file asmfile (prefixname ^ ext_obj) (* gasでオブジェクトファイルに *)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-13-ocamlopt.md:299
msgid ""
"このコンパイルパイプラインが実際には一瞬で完了するのだから、すごいでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第6回 議事録\n"
"description: OSC2013-TokyoをAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc, android\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:12
msgid ""
"Metasepi作戦会議 第6回を [オープンソースカンファレンス2013 Tokyo/Fall]"
"(http://www.ospn.jp/osc2013-fall/)  で開催したでゲソ。 そろそろ発表ネタがつき"
"てきたのでゲソが、丁度Haskellを使ってAndroid NDKアプリが書けたので、 その設計"
"ノウハウを解説したでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:20
msgid ""
"設計ノウハウというのはこれまでやってきた [スナッチ設計](2013-01-09-"
"design_arafura.html)  手法の詳細についてでゲソ。 Android NDKには [native-"
"activity](http://developer.android.com/tools/sdk/ndk/index.html#Samples)  と"
"いうサンプルがあるじゃなイカ？ このC言語で書かれたプログラムをスナッチ設計す"
"ることで、 AndroidアプリをHaskellで設計する方法を知ることができたのでゲソ。 "
"今回はこのAndroid NDKでのスナッチ設計具体例を観察してようじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:23
msgid ""
"おまけでHaskellで書いたAndroid NDKアプリをTravis CIでビルドテストする方法をLT"
"したので、 その資料も置いておくでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:27
msgid ""
"### Metasepi team meeting #6: \"Snatch-driven development\" - "
"@masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:29
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/27376607\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20131020-osc-tokyoajhc\" title=\"Metasepi team meeting #6: &quot;"
"Snatch-driven development&quot;\" target=\"_blank\">Metasepi team meeting "
"#6: &quot;Snatch-driven development&quot;</a> </strong> from <strong><a href="
"\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></"
"strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:31
msgid "### AndroidアプリをTravis CIでビルド - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:33
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/27376614\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20131020-osc-tokyotravisciandroid\" title=\"AndroidアプリをTravis CI"
"でビルド\" target=\"_blank\">AndroidアプリをTravis CIでビルド</a> </strong> "
"from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:37
msgid "### Haskellで書かれたAndroid NDKアプリが動作"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:39 posts/2013-12-17-snatch-droid.md:51
msgid ""
"<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/"
"n6cepTfnFoo\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr ""

#. type: Plain text
#: posts/2013-10-20-osc2013-tokyo.md:45
msgid ""
"![](/img/20131020_desk.jpg)  ![](/img/20131020_android.jpg)  ![](/"
"img/20131020_mbed.jpg)  ![](/img/20131020_okano.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:5
#, no-wrap
msgid ""
"title: Build forkOS API using pthread.\n"
"description: pthreadでHaskellのforkOSを作ってみるでゲソ!\n"
"tags: jhc, ajhc, thread, pthread\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:11
msgid ""
"再入可能にしようとして、まずは [forkOS](http://hackage.haskell.org/packages/"
"archive/base/latest/doc/html/Control-Concurrent.html#v:forkOS)  を作ろうとし"
"たらハマったでゲソ。 このページはforkOSをpthread\\_createを使って作るメモ書き"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:13
msgid "## 作成方法を考えよう"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:15
msgid "作る前にまずは作戦をねるでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:17
msgid "### (1) GHC baseパッケージの設計をまねる"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:21
msgid ""
"[GHCでのforkOSの実装](http://hackage.haskell.org/packages/archive/base/"
"latest/doc/html/src/Control-Concurrent.html#forkOS)  を見ると、StablePtrにIO"
"関数を包んで、C言語のforkOS\\_createThread関数に渡しているでゲソ。 pthread"
"\\_createは"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:26
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ghc/libraries/base/Control/Concurrent.hs\n"
"foreign export ccall forkOS_entry\n"
"    :: StablePtr (IO ()) -> IO ()\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:29
#, no-wrap
msgid ""
"foreign import ccall \"forkOS_entry\" forkOS_entry_reimported\n"
"    :: StablePtr (IO ()) -> IO ()\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:34
#, no-wrap
msgid ""
"forkOS_entry :: StablePtr (IO ()) -> IO ()\n"
"forkOS_entry stableAction = do\n"
"        action <- deRefStablePtr stableAction\n"
"        action\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:37
#, no-wrap
msgid ""
"foreign import ccall forkOS_createThread\n"
"    :: StablePtr (IO ()) -> IO CInt\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:49
#, no-wrap
msgid ""
"forkOS :: IO () -> IO ThreadId\n"
"forkOS action0\n"
"    | rtsSupportsBoundThreads = do\n"
"-- snip --\n"
"        entry <- newStablePtr (myThreadId >>= putMVar mv >> action_plus)\n"
"        err <- forkOS_createThread entry\n"
"        when (err /= 0) $ fail \"Cannot create OS thread.\"\n"
"        tid <- takeMVar mv\n"
"        freeStablePtr entry\n"
"        return tid\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:61
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* File: ghc/rts/posix/OSThreads.c */\n"
"static void *\n"
"forkOS_createThreadWrapper ( void * entry )\n"
"{\n"
"    Capability *cap;\n"
"    cap = rts_lock();\n"
"    rts_evalStableIO(&cap, (HsStablePtr) entry, NULL);\n"
"    rts_unlock(cap);\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:73
#, no-wrap
msgid ""
"int\n"
"forkOS_createThread ( HsStablePtr entry )\n"
"{\n"
"    pthread_t tid;\n"
"    int result = pthread_create(&tid, NULL,\n"
"\t\t\t\tforkOS_createThreadWrapper, (void*)entry);\n"
"    if(!result)\n"
"        pthread_detach(tid);\n"
"    return result;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:81
msgid ""
"どうやらGHCではStablePtrはFFIを越えることができて、その型はHsStablePtrのよう"
"でゲソ。 このようなコードをAjhcでも実現できなイカ？ ところが [それぽいコード]"
"(https://github.com/ajhc/ajhc-dumpyard/tree/master/try_pthread1)  を書いてみ"
"たところエラーになるじゃなイカ。 これはStablePtrは単なるスマートポインタにな"
"るはずでゲソが、 どうもこのスマートポインタを直接C言語コードに渡すのが禁止さ"
"れているようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:90
#, no-wrap
msgid ""
"~~~\n"
"$ make\n"
"--snip--\n"
"Compiling...\n"
"[1 of 1] Jhc.Conc         \n"
"jhc-conc-pthread/Jhc/Conc.hs:28  - Error: caught error processing decl: user error (createFunc: attempt to pass a void argument)\n"
"jhc-conc-pthread/Jhc/Conc.hs:28  - Error: Type 'Foreign.StablePtr.StablePtr (IO ())' cannot be used in a foreign declaration\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:93
msgid ""
"このスマートポインタを直接C言語コードに見せる行為をはたして許して良いものか考"
"えどころでゲソ。。。 イカはforeignで使って良い要素を判定している箇所の抜き出"
"しでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:98
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/E/FromHs.hs\n"
"instance DataTableMonad C where\n"
"    getDataTable = asks ceDataTable\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:107
#, no-wrap
msgid ""
"ffiTypeInfo bad t cont = do\n"
"    dataTable <- getDataTable\n"
"    case lookupExtTypeInfo dataTable t of\n"
"        Just r -> cont r\n"
"        Nothing -> do\n"
"            sl <- getSrcLoc\n"
"            liftIO $ warn sl InvalidFFIType $ printf \"Type '%s' cannot be used in a foreign declaration\" (pprint t :: String)\n"
"            return bad\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:121
#, no-wrap
msgid ""
"convertDecls tiData props classHierarchy assumps dataTable hsDecls = res where\n"
"    res = do\n"
"        (a,ws) <- evalRWST ans ceEnv 2\n"
"        mapM_ addWarning ws\n"
"        return a\n"
"    ceEnv = CeEnv {\n"
"        ceCoerce = tiCoerce tiData,\n"
"        ceAssumps = assumps,\n"
"        ceFuncs = funcs,\n"
"        ceProps = props,\n"
"        ceSrcLoc = bogusASrcLoc,\n"
"        ceDataTable = dataTable\n"
"        }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:139
#, no-wrap
msgid ""
"-- File: ajhc/src/E/Main.hs\n"
"processDecls ::\n"
"    CollectedHo             -- ^ Collected ho\n"
"    -> Ho                   -- ^ preliminary haskell object  data\n"
"    -> TiData               -- ^ front end output\n"
"    -> IO (CollectedHo,Ho)  -- ^ (new accumulated ho, final ho for this modules)\n"
"processDecls cho ho' tiData = withStackStatus \"processDecls\" $  do\n"
"--snip--\n"
"    let derives = (collectDeriving originalDecls)\n"
"    let dataTable = toDataTable (getConstructorKinds (hoKinds $ hoTcInfo ho'))\n"
"            (tiAllAssumptions tiData) originalDecls (hoDataTable $ hoBuild ho)\n"
"        classInstances = deriveClasses (choCombinators cho) fullDataTable derives\n"
"        fullDataTable = dataTable `mappend` hoDataTable (hoBuild ho)\n"
"--snip--\n"
"    ds' <- convertDecls tiData theProps\n"
"        (hoClassHierarchy $ hoTcInfo ho') allAssumps  fullDataTable decls\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:141
msgid ""
"もう一つ気になるのはdeRefStablePtrを使ってIOを元に戻しても実行不能という点で"
"ゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:144
msgid "~~~ {.haskell} import Foreign.StablePtr"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:151
#, no-wrap
msgid ""
"main :: IO ()\n"
"main = do\n"
"  p <- newStablePtr $ print \"hoge\"\n"
"  d <- deRefStablePtr p\n"
"  d\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:153
msgid "上のコードをコンパイルすると、イカのようなエラーになるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:172
msgid ""
"~~~ $ ajhc --tdir=tmp -o Main Main.hs --snip-- Typechecking...  "
"Compiling...  Collected Compilation...  -- TypeAnalyzeMethods -- "
"BoxifyProgram -- Boxy WorkWrap -- LambdaLift Converting to Grin...  "
"Updatable CAFS: 0 Constant CAFS: 0 Recursive CAFS: 0 Exiting abnormally. "
"Work directory is 'tmp' ajhc: Grin.FromE.compile'.ce in function: theMain "
"can't grok expression: <fromBang_ x128471745∷IO ()> x62470114 ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:174
msgid "### (2) foreign import ccall \"wrapper\"で関数ポインタを作る"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:180
msgid ""
"wrapperというforeign import宣言 ^[[本物のプログラマはHaskellを使う - 第22回　"
"FFIを使って他の言語の関数を呼び出す：ITpro](http://itpro.nikkeibp.co.jp/"
"article/COLUMN/20080805/312151/?ST=develop&P=4)] があり、これを使えば任意のIO"
"を関数ポインタに変換することができるようでゲソ。 wrapperを使えば簡単にpthread"
"\\_createにHaskellのIOを呼び出してもらえるじゃなイカ？ やってみるでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:185
msgid ""
"...と、 [ものすごくいい加減なコード](https://github.com/ajhc/ajhc-dumpyard/"
"tree/master/try_pthread2)  を書いてみたでゲソ。 ところが今度はFunPtrというC言"
"語の型がみつからないとGCCに怒られるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:196
msgid ""
"~~~ Running: gcc tmp/rts/profile.c tmp/rts/rts_support.c tmp/rts/gc_none.c "
"tmp/rts/jhc_rts.c tmp/lib/lib_cbits.c tmp/rts/gc_jgc.c tmp/rts/stableptr.c -"
"Itmp/cbits -Itmp tmp/main_code.c -o Main '-std=gnu99' -D_GNU_SOURCE '-falign-"
"functions=4' -ffast-math -Wextra -Wall -Wno-unused-parameter -fno-strict-"
"aliasing -DNDEBUG -O3 '-D_JHC_GC=_JHC_GC_JGC' tmp/main_code.c: In function "
"‘fFE$__CCall_testThread’: tmp/main_code.c:659:17: warning: statement with no "
"effect [-Wunused-value] tmp/main_code.c: In function ‘ftheMain’: tmp/"
"main_code.c:1146:68: error: ‘FunPtr’ undeclared (first use in this "
"function)  tmp/main_code.c:1146:68: note: each undeclared identifier is "
"reported only once for each function it appears in Exiting abnormally. Work "
"directory is 'tmp' ajhc: user error (C code did not compile.)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:199
msgid ""
"これはイカのようなC言語コードをAjhcが吐き出すためでゲソ。 もうちょっと小細工"
"すれば関数ポインタが使えるようになりそうじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:208
#, no-wrap
msgid ""
"~~~ {.c}\n"
"static void A_STD\n"
"ftheMain(gc_t gc)\n"
"{\n"
"        saved_gc = gc;\n"
"        (uint32_t)pthread_create((pthread_t*)0,(pthread_attr_t*)0,(FunPtr)((uintptr_t)&testThread),(HsPtr)0);\n"
"        return;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:215
#, no-wrap
msgid ""
"HsPtr\n"
"testThread(HsPtr x30)\n"
"{\n"
"        return (HsPtr)fFE$__CCall_testThread(saved_gc,(uintptr_t)x30);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:217
msgid ""
"どうも上の不具合はイカのpatchで簡単に修正できるようでゲソ。たぶんこれはイー"
"ジーミスだと思うでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:223
#, no-wrap
msgid ""
"~~~ {.diff}\n"
"--- a/lib/jhc/Jhc/Type/Ptr.hs\n"
"+++ b/lib/jhc/Jhc/Type/Ptr.hs\n"
"@@ -3,4 +3,4 @@ module Jhc.Type.Ptr where\n"
" import Jhc.Prim.Bits\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:228
#, no-wrap
msgid ""
" data {-# CTYPE \"HsPtr\" #-} Ptr a = Ptr Addr_\n"
"-data {-# CTYPE \"FunPtr\" #-} FunPtr a = FunPtr FunAddr_\n"
"+data {-# CTYPE \"HsFunPtr\" #-} FunPtr a = FunPtr FunAddr_\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:232
msgid ""
"しかしこれでFunPtrを使った関数ポインタを実現できたんでゲソが、 任意のIOを関数"
"ポインタ化できることにはならないでゲソ。 具体的にはイカのような型になってし"
"まっているforkOSの引数をIO ()にしたいでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:236
msgid "~~~ {.haskell} forkOS :: FunPtr (Ptr () -> IO (Ptr ())) -> IO Int ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:243
msgid ""
"GHCはどんな魔法を使っているのでゲソ？ [GHCでforeign import ccall \"wrapper"
"\"を使う例](https://github.com/ajhc/ajhc-dumpyard/tree/master/"
"ghc_foreign_wrapper)  を解析すれば何かわかるかもしれないでゲソ。 "
"freeHaskellFunPtrの行方を探ったところ、 どうもghc/rts/Adjustor.cでwrapperが"
"作ったコード片のラッパーを作るようでゲソ。 createAdjustorというのが主犯のよう"
"じゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:246
msgid ""
"とりあえず任意のIOをFunPtrに変換するのはキツいにしても、 定数的なIOはラベルを"
"ふるだけなのだから比較的簡単にFunPtr化できるんじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:249
msgid ""
"[Commentary/Rts/FFI – GHC](http://hackage.haskell.org/trac/ghc/wiki/"
"Commentary/Rts/FFI)  を読んでみたでゲソが、具体的な実現方法については言及がな"
"いでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:251
msgid "### (3) グローバル関数テーブルのインデックスを引数渡し"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:255
msgid ""
"StablePtrを使わずにコンテキスト間でIOを授受する方法として無理矢理考えてみたで"
"ゲソ。 結局インデックスの意味がC言語側に漏れるので、 StablePtrを直接C言語に渡"
"すケースと比較して危険度はほとんど変わらない気もするでゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:257
msgid "### (4) ラムダ式を使うために-std=gnu++11でコンパイル"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:259
msgid "さすがにこれは筋が悪すぎるので、困った時の隠し玉に取っておかなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:261
msgid ""
"## 結論: やはりnewStablePtrに直接IO ()を突っ込んだ際の挙動を観察するべき"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:266
msgid ""
"~~~ ajhc: Grin.FromE.compile'.ce in function: theMain can't grok expression: "
"<fromBang_ x128471745∷IO ()> x62470114 ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:268
msgid ""
"このメッセージはcompile'関数が以下の型を意図せず受け取ったことをしめしている"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:272
msgid "~~~ {.haskell} (EAp (EPrim (PrimPrim \"fromBang_\") [x] e1) e2)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:275
msgid ""
"ということはこのEApという型はどこかで変換されるべきで、そのしくみから漏れてき"
"たと考えられるじゃなイカ。 しかし仮にイカのようなpatchをあてても..."
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:288
#, no-wrap
msgid ""
"~~~ {.diff}\n"
"--- a/lib/haskell-extras/Foreign/StablePtr.hs\n"
"+++ b/lib/haskell-extras/Foreign/StablePtr.hs\n"
"@@ -5,7 +5,9 @@ module Foreign.StablePtr(\n"
"     castPtrToStablePtr,\n"
"     newStablePtr,\n"
"     deRefStablePtr,\n"
"-    freeStablePtr\n"
"+    freeStablePtr,\n"
"+    newStablePtrIO,\n"
"+    deRefStablePtrIO,\n"
"     ) where\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:293
#, no-wrap
msgid ""
" import Jhc.Prim.Rts\n"
"@@ -37,6 +39,19 @@ deRefStablePtr x = do\n"
"     fromUIO $ \\w -> case c_derefStablePtr (toBang_ x) w of\n"
"         (# w', s #) -> (# w', fromBang_ s #)\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:311
#, no-wrap
msgid ""
"+newStablePtrIO :: IO a -> IO (StablePtr (IO a))\n"
"+newStablePtrIO x = do\n"
"+    fromUIO $ \\w -> case c_newStablePtrIO x w of\n"
"+        (# w', s #) -> (# w', s #)\n"
"+\n"
"+deRefStablePtrIO :: StablePtr (IO a) -> IO (IO a)\n"
"+deRefStablePtrIO x = do\n"
"+    fromUIO $ \\w -> case c_derefStablePtrIO x w of\n"
"+        (# w', s #) -> (# w', s #)\n"
"+\n"
" foreign import ccall unsafe \"rts/stableptr.c c_freeStablePtr\"  c_freeStablePtr   :: Bang_ (StablePtr a) -> IO ()\n"
" foreign import ccall unsafe \"rts/stableptr.c c_newStablePtr\"   c_newStablePtr    :: Bang_ a -> UIO (Bang_ (StablePtr a))\n"
" foreign import ccall unsafe \"rts/stableptr.c c_derefStablePtr\" c_derefStablePtr :: Bang_ (StablePtr a) -> UIO (Bang_ a)\n"
"+\n"
"+foreign import ccall unsafe \"rts/stableptr.c c_newStablePtr\"   c_newStablePtrIO   :: IO a -> UIO (StablePtr (IO a))\n"
"+foreign import ccall unsafe \"rts/stableptr.c c_derefStablePtr\" c_derefStablePtrIO :: StablePtr (IO a) -> UIO (IO a)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:314
msgid ""
"ajhcのコンパイルでイカのようにエラーになってしまうでゲソ。 どうやらforeign "
"importに渡せる型は限定されているようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:322
msgid ""
"~~~ Compiling...  [1 of 4] Foreign.StablePtr lib/haskell-extras/Foreign/"
"StablePtr.hs:56 - Error: Type 'Foreign.StablePtr.StablePtr (IO Foreign."
"StablePtr.37_a)' cannot be used in a foreign declaration lib/haskell-extras/"
"Foreign/StablePtr.hs:57 - Error: Type 'IO Foreign.StablePtr.39_a' cannot be "
"used in a foreign declaration make[2]: *** [haskell-extras-0.8.1.hl] エラー "
"1 ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:324
msgid "じゃあUIOを経由してStablePtrを作るのはどーなんでゲソ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:328
msgid ""
"~~~ {.haskell} newStablePtrIO :: IO a -> IO (StablePtr (UIO a))  "
"newStablePtrIO x = newStablePtr (unIO x)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:334
#, no-wrap
msgid ""
"deRefStablePtrIO :: StablePtr (UIO a) -> IO (IO a)\n"
"deRefStablePtrIO x = do\n"
"  u <- deRefStablePtr x\n"
"  return $ fromUIO u\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:336
msgid "エラーは変化せず、そりゃそうカー。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:340
msgid ""
"ちょっと立ち返って、StablePtrを経由したIO ()の授受というのは本来どのような"
"コードになるべきなんでゲソ？ イカのようなコード、つまりIO ()をStablePtrと"
"Bang_で二重に包んだような型を作り、 この型をpthread_create()で生成されるス"
"レッドに渡して復元してほしいでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:344
msgid "~~~ {.haskell} import Foreign.StablePtr import Jhc.Prim.Rts"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:349
#, no-wrap
msgid ""
"iToB :: IO () -> IO (Bang_ (StablePtr (IO ())))\n"
"iToB io = do\n"
"  s <- newStablePtr io\n"
"  return $ toBang_ s\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:354
#, no-wrap
msgid ""
"runB :: Bang_ (StablePtr (IO ())) -> IO ()\n"
"runB b = do\n"
"  io <- deRefStablePtr $ fromBang_ b\n"
"  io\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:361
#, no-wrap
msgid ""
"main :: IO ()\n"
"main = do\n"
"  l <- getLine\n"
"  b <- iToB $ print l\n"
"  runB b\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:365
msgid ""
"ところが先のエラーがなぜ起きていたかというと予期しないEApがあったからじゃなイ"
"カ。 この変なEApだけごまかせばなんとかなるんじゃなイカ？ どうやらこのEApとい"
"う型はfromAp関数でEVarを剥き出しにしてからパターンマッチされるようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:372
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/E/Type.hs\n"
"fromAp :: E -> (E,[E])\n"
"fromAp e = f [] e where\n"
"    f as (EAp e a) = f (a:as) e\n"
"    f as e  =  (e,as)\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:403
#, no-wrap
msgid ""
"-- File: ajhc/src/Grin/FromE.hs\n"
"    ce e | (EVar tvr,as) <- fromAp e = do\n"
"        as <- return $ args as\n"
"        lfunc <- asks lfuncMap\n"
"        let fty = toTypes TyNode (getType e)\n"
"        case mlookup (tvrIdent tvr) (ccafMap cenv) of\n"
"            Just (Const c) -> app fty (Return [c]) as\n"
"            Just x@Var {} -> app fty (gEval x) as\n"
"            Nothing | Just (v,n,rt) <- mlookup (tvrIdent tvr) lfunc -> do\n"
"                    let (x,y) = splitAt n as\n"
"                    app fty (App v (keepIts x) rt) y\n"
"            Nothing -> case mlookup (tvrIdent tvr) (scMap cenv) of\n"
"                Just (v,as',es)\n"
"                    | length as >= length as' -> do\n"
"                        let (x,y) = splitAt (length as') as\n"
"                        app fty (App v (keepIts x) es) y\n"
"                    | otherwise -> do\n"
"                        let pt = partialTag v (length as' - length as)\n"
"                        return $ dstore (NodeC pt (keepIts as))\n"
"                Nothing | not (isLifted $ EVar tvr) -> do\n"
"                    mtick' \"Grin.FromE.app-unlifted\"\n"
"                    app fty (Return [toVal tvr]) as\n"
"                Nothing -> do\n"
"                    case as of\n"
"                        [] -> evalVar fty tvr\n"
"                        _ -> do\n"
"                            ee <- evalVar [TyNode] tvr\n"
"                            app fty ee as\n"
"            _ -> error \"FromE.ce: bad.\"\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:405
msgid "そこでイカのようなfromBang_プリミティブを抹殺する関数を作ったでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:414
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"    stripBang :: E -> E\n"
"    stripBang e = f e where\n"
"      f (EAp p a) = g p a\n"
"      f e = e\n"
"      g (EPrim (PrimPrim \"fromBang_\") [b] _) a = EAp b a\n"
"      g e a = EAp e a\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:417
msgid ""
"このstripBangを通してからfromApにeを食わせたところ無事エラーが出なくなったで"
"ゲソ。 ちょっと危険な気もするが、大目に見てほしいでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:419 posts/2013-06-21-impl_mvar.md:379
msgid "## 実装"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:421
msgid "ここまで来ればforkOSを実装するのは簡単でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:432
msgid ""
"~~~ {.haskell} -- File: ajhc/lib/haskell-extras/Control/Concurrent.hs {-# "
"LANGUAGE ForeignFunctionInterface #-} module Control.Concurrent (forkOS, "
"ThreadId) where import Foreign.Ptr import Foreign.StablePtr import Foreign."
"Storable import Foreign.Marshal.Alloc import Control.Monad (when)  import "
"Jhc.Prim.Rts"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:435
msgid ""
"data {-# CTYPE \"rts/conc.h jhc_threadid_t\" #-} CthreadIdT data ThreadId = "
"ThreadId CthreadIdT"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:438
#, no-wrap
msgid ""
"foreign import ccall \"rts/conc.h forkOS_createThread\" forkOScreateThread ::\n"
"   FunPtr (Bang_ (StablePtr (IO ())) -> IO (Ptr ())) -> Bang_ a -> Ptr Int -> IO CthreadIdT\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:446
#, no-wrap
msgid ""
"forkOScreateThreadWrapper :: Bang_ (StablePtr (IO ())) -> IO (Ptr ())\n"
"forkOScreateThreadWrapper b = do\n"
"  let s = fromBang_ b\n"
"  d <- deRefStablePtr s\n"
"  d\n"
"  freeStablePtr s\n"
"  return nullPtr\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:451
#, no-wrap
msgid ""
"foreign export ccall \"forkOScreateThreadWrapper\" forkOScreateThreadWrapper ::\n"
"  Bang_ (StablePtr (IO ())) -> IO (Ptr ())\n"
"foreign import ccall \"&forkOScreateThreadWrapper\" p_forkOScreateThreadWrapper ::\n"
"  FunPtr (Bang_ (StablePtr (IO ())) -> IO (Ptr ()))\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:460
#, no-wrap
msgid ""
"forkOS :: IO () -> IO ThreadId\n"
"forkOS f = alloca $ \\ip -> do\n"
"  s <- newStablePtr f\n"
"  pth <- forkOScreateThread p_forkOScreateThreadWrapper (toBang_ s) ip\n"
"  i <- peek ip\n"
"  when (i /= 0) $ fail \"Cannot create OS thread.\"\n"
"  return $ ThreadId pth\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-forkos_jhc.md:473
#, no-wrap
msgid ""
"~~~ {.c}\n"
"// File: ajhc/rts/rts/conc.c\n"
"jhc_threadid_t\n"
"forkOS_createThread(void *(*wrapper) (void *), void *entry, int *err)\n"
"{\n"
"        pthread_t tid;\n"
"        *err = pthread_create(&tid, NULL, wrapper, entry);\n"
"        if (*err) {\n"
"                pthread_detach(tid);\n"
"        }\n"
"        return tid;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第5回 議事録\n"
"description: OSC2013-HiroshimaをAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:10
msgid ""
"Metasepi作戦会議 第5回を [オープンソースカンファレンス2013 Hiroshima](http://"
"www.ospn.jp/osc2013-hiroshima/)  で開催したでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:13
msgid ""
"そろそろAjhcの開発をはじめて一年たとうとしているので、今回の作戦会議では"
"Metasepi/Ajhcプロジェクトの概要とその振り返りをしてみたでゲソ。 参加していた"
"だいた方が関数型言語と組込みのどちらのドメインからも遠かったようで、少し内容"
"がつたわりにくかったかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:16
msgid ""
"今回のスライドは英語で書いてみたでゲソ。ワシの書いたスライドの内、英語のもの"
"は数年経た後にもアクセスと反応があるので、 Ajhcの説明を日本語でしゃべるときで"
"も資料だけは英語にしておくと後で役に立つかもしれないじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:20
msgid "### Metasepi team meeting: Ajhc Project Overview - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:22
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/26924024\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20131006-osc-hiroshimaajhc\" title=\"Metasepi team meeting: Ajhc "
"Project Overview\" target=\"_blank\">Metasepi team meeting: Ajhc Project "
"Overview</a> </strong> from <strong><a href=\"http://www.slideshare.net/"
"master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:24
msgid "## 旅の情報 (広島)"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:27
msgid ""
"[コミック＆インターネットカフェ【アプレシオ広島駅前店】](http://www.aprecio."
"co.jp/hiroshima_ekimae/tabid/270/Default.aspx)  が高速バスの乗降場所に近いの"
"で、時間があるときにはシャワーを借りるといいかもでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-10-06-osc2013-hi.md:32
msgid ""
"![](/img/20131006-many_seal.jpg)  ![](/img/20131006-occupation.jpg)  ![](/"
"img/20131006-desk.jpg)"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:5
#, no-wrap
msgid ""
"title: Haskell/OCaml製のOSって何があるんでゲソ？\n"
"description: 作る前に類似の例がないか調べるでゲソ。\n"
"tags: haskell, ocaml, os\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:8
msgid "ざっくり検索してみると、こんなところみたいでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-08-18-haskell-or-ocaml-os.md:13
msgid "[Funk (OCaml製)](http://home.gna.org/funk/)"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-08-18-haskell-or-ocaml-os.md:13
msgid "[snowflake-os (OCaml製)](http://code.google.com/p/snowflake-os/)"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-08-18-haskell-or-ocaml-os.md:13
msgid "[House (Haskell製)](http://programatica.cs.pdx.edu/House/)"
msgstr ""

#. type: Bullet: '* '
#: posts/2012-08-18-haskell-or-ocaml-os.md:13
msgid "[HaLVM (Haskell製)](http://corp.galois.com/halvm/)"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:20
msgid ""
"それぞれぱっと見てみた感想なんでゲソが、まずどれも日常のデスクトップとして使"
"えるしろものではないでゲソ。 さっとコードを読むかぎりだと、割り込みをポーリン"
"グでひろうようになっていたり、 OCamlのシグナルハンドラに割り込みを直結させる"
"ようになっていたり、 いろいろつぎはぎ感があるでゲソ。 またHouseやHaLVMはpatch"
"のあたったGHC6でしかコンパイルできないようでゲソ。 というかワシもコンパイルで"
"きなかったでゲソ。。。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:26
msgid ""
"ん？disってるって？そうでゲソ。わるイカ？ まぁ、これらのソフトウェアは実現可"
"能性を探索するためのコンセプトに過ぎないのでゲソ。 これらのプロジェクトが存在"
"したからこそ 「がんばればデスクトップとして使えるkernelを強い型を持つ言語で設"
"計できる」 という勇気がわくでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:33
msgid ""
"個人的に有望そうなプロジェクトはsnowflake-osに見えるでゲソ。 コードはキレイで"
"はないでゲソが、 AC'97のサウンドドライバまで持っているでゲソ。 サウンドドライ"
"バはソフトリアルタイムなので、真面目に作ったら大変なはずじゃなイカ。 しかもこ"
"のプロジェクトは2012年3月まで生き延びている形跡があるでゲソ。 継続は力でゲソ!"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:35
msgid "## これらのプロジェクトの何が問題？"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:40
msgid ""
"これらのプロジェクト中のコードを読むかぎりMDとMIの切り分けや、割り込み処理、 "
"メモリマップが既存のUNIXモドキkernelと比較して、たいへん、、、その、、、稚拙"
"でゲソ。 これらBSDから脈々と受け継がれてきた秘伝のタレ、じゃなかったkernel内"
"部のモジュール分割と抽象化を捨ててしまっているでゲソ。 気持ちは大変よくわかる"
"でゲソ。関数型言語を使った場合にC言語でつちかわれたデザインが正しいという可能"
"性は低いでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:44
msgid ""
"ただ、イキナリそのkernelの全ての抽象化をイチからやり直すというのは現実的な解"
"なのカ？ 1977年から2012年、つまり35年もの歴史を一気にスクラッチから全く異なる"
"別解を得る。 とほうもない知能と腕力が必要そうでゲソ。。。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:47
msgid ""
"教訓として言えるのは、まず最初は典型的なUNIXモドキOSのモノリシックkernelの設"
"計をそのままパクって、 設計言語だけを変更した方が安全な道かもしれない、という"
"ことかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:49
msgid "## Metasepiに再利用できそうカ？"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:52
msgid ""
"Haskell製の方しかあまり調べてないでゲソが、 再利用できそうなプロジェクトはあ"
"りそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:60
msgid ""
"HaLVMには [HaNS](http://corp.galois.com/hans) というTCP/IPプロトコルスタック"
"があるでゲソ。 これは最初のネットワークドライバを書く際には参考になりそうでゲ"
"ソ。 ただしMD側の抽象化は不足してそうでゲソが。。。 また、 [A Principled "
"Approach to Operating System Construction in Haskell](http://ogi.altocumulus."
"org/~hallgren/ICFP2005/)  によると、monadicなハードウェア抽象化をすることが可"
"能だとあるでゲソ。 ひょっとしたら御利益があるかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-18-haskell-or-ocaml-os.md:62
msgid ""
"本当はOCaml製のソースコードの検証も必要なんでゲソが、 現状では手がまわってい"
"ないでゲソ。。。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:5
#, no-wrap
msgid ""
"title: Detail of the jgc garbage collector\n"
"description: 再入を実現する前によくGCを観察してみるでゲソ!\n"
"tags: jhc, jgc, gc, haskell\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:11
msgid ""
"AjhcのデフォルトのGCはjgcでゲソ。 このjgcについての解説は [\\@dec9ue]"
"(https://twitter.com/dec9ue)  氏のプレゼン資料が詳しかったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:13 posts/2013-02-03-kickoff_meeting.md:29
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/16298437\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/dec9ue/gc-16298437\" title=\"小二病でもGCや"
"りたい\" target=\"_blank\">小二病でもGCやりたい</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/dec9ue\" target=\"_blank"
"\">dec9ue</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:15
msgid "これからAjhcを使って以下を実現したいでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:20
msgid "クリティカルリージョンの保護"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:20
msgid "割り込みコンテキストをHaskellで記述"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:20
msgid "並列実行"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:20
msgid "GCの中断と再開"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:22
msgid ""
"とすると、jgcに対してもう少し突っ込んだ理解を今しておいた方が良さそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:24
msgid "## GCのルート"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:26
msgid ""
"gc_perform_gc関数の前半でヒープにマーキングしているはずなので、読めばわかるは"
"ずじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:33
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void A_STD\n"
"gc_perform_gc(gc_t gc)\n"
"{\n"
"        profile_push(&gc_gc_time);\n"
"        arena->number_gcs++;\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:38
#, no-wrap
msgid ""
"        unsigned number_redirects = 0;\n"
"        unsigned number_stack = 0;\n"
"        unsigned number_ptr = 0;\n"
"        struct stack stack = EMPTY_STACK;\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:40
#, no-wrap
msgid "        clear_used_bits(arena);\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:54
#, no-wrap
msgid ""
"        debugf(\"Setting Roots:\");\n"
"        stack_check(&stack, root_stack.ptr);\n"
"        for(unsigned i = 0; i < root_stack.ptr; i++) {\n"
"                gc_add_grey(&stack, root_stack.stack[i]);\n"
"                debugf(\" %p\", root_stack.stack[i]);\n"
"        }\n"
"        debugf(\" # \");\n"
"        struct StablePtr *sp;\n"
"        LIST_FOREACH(sp, &root_StablePtrs, link) {\n"
"            gc_add_grey(&stack, (entry_t *)sp);\n"
"            debugf(\" %p\", root_stack.stack[i]);\n"
"        }\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:56
msgid "gc_perform_gc関数が開始すると..."
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-05-17-jgc_detail.md:67
msgid "stack一時変数を初期化"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-05-17-jgc_detail.md:67
msgid "arenaの中身のused_bitを一般0クリア"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-05-17-jgc_detail.md:67
msgid ""
"stack_check関数を呼び出してstack一時変数がroot_stack.ptr個分のエントリを格納"
"できるか調べ"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-05-17-jgc_detail.md:67
msgid ""
"stack一時変数のサイズが足りなければstack_grow関数でreallocを呼び出し拡張"
msgstr ""

#. type: Bullet: '5. '
#: posts/2013-05-17-jgc_detail.md:67
msgid "root_stack.stack配列の要素を一つずつgc_add_grey関数に食わせる"
msgstr ""

#. type: Bullet: '6. '
#: posts/2013-05-17-jgc_detail.md:67
msgid ""
"gc_add_grey関数はroot_stack.stack配列の要素がヒープ中かどうかチェックする。"
"nh_stuff配列の中にある要素は静的確保されたもの"
msgstr ""

#. type: Bullet: '7. '
#: posts/2013-05-17-jgc_detail.md:67
msgid ""
"さらにgc_add_grey関数はroot_stack.stack配列の要素にused_bitが立ってないことを"
"確認してから立てる"
msgstr ""

#. type: Bullet: '8. '
#: posts/2013-05-17-jgc_detail.md:67
msgid "6と7に成功したらstack->stack配列に当該root_stack.stack配列の要素を積む"
msgstr ""

#. type: Bullet: '9. '
#: posts/2013-05-17-jgc_detail.md:67
msgid "BSDリストであるroot_StablePtrsを順番に辿る"
msgstr ""

#. type: Bullet: '10. '
#: posts/2013-05-17-jgc_detail.md:67
msgid ""
"6と7と同様にしてgc_add_grey関数でチェックした後stack->stack配列に"
"root_StablePtrsの要素を積む"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:69
msgid ""
"ということはroot_stackとroot_StablePtrsの2つがGCルートということになるでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:73
msgid ""
"ところでちょっと気になるんでゲソが、 root_StablePtrsをgc_add_grey関数にかける"
"前にstack_checkをもう一度呼び出してstack一時変数のサイズが足りてるかチェック"
"した方がいいんじゃなイカ...  このままだとStablePtrの個数が多い場合にはふっと"
"ぶ気がするでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:75
msgid "### root_stackとは何か"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:78
msgid ""
"これはふつーのプログラムでは使われないようでゲソ。 jhcのGrinがgc_add_root関数"
"を使うコード吐き出すことがあるようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:99
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/C/FromGrin2.hs\n"
"declareEvalFunc isCAF n = do\n"
"    fn <- tagToFunction n\n"
"    grin <- asks rGrin\n"
"    declareStruct n\n"
"    nt <- nodeType n\n"
"    let ts = runIdentity $ findArgs (grinTypeEnv grin) n\n"
"        fname = toName $ \"E_\" ++ show fn\n"
"        aname = name \"arg\"\n"
"        rvar = localVariable wptr_t (name \"r\")\n"
"        atype = ptrType nt\n"
"        body = rvar =* functionCall (toName (show $ fn)) (mgc [ project' (arg i) (variable aname) | _ <- ts | i <- [(1 :: Int) .. ] ])\n"
"        update =  f_update (variable aname) rvar\n"
"        addroot =  if isCAF && fopts FO.Jgc then f_gc_add_root (cast sptr_t rvar) else emptyExpression\n"
"        body' = if not isCAF && fopts FO.Jgc then subBlock (gc_roots [f_MKLAZY(variable aname)] & rest) else rest\n"
"        rest = body & update & addroot & creturn rvar\n"
"    tellFunctions [function fname wptr_t (mgct [(aname,atype)]) [a_STD, a_FALIGNED] body']\n"
"    return fname\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:107
msgid ""
"ちょっとコードの意図が取りにくいでゲソが\"E\\_\"ではじまる関数はサンクの評価"
"関数であるはずなので、 スタティックサンクだとGCルートになるんじゃなイカ？ そ"
"の時に\"E\\_\"ではじまる評価関数の中にgc_add_root関数が埋め込まれるはずでゲ"
"ソ。 ...でもなんかそのケースは稀な気がするでゲソ。 grinの最適化の中でほとんど"
"のスタティックサンクは使用元の関数の中に展開されてしまいそうでゲソ。 簡単な例"
"を作ってみてもgc_add_root関数が埋め込まれたC言語コードをajhcは吐き出さないよ"
"うでゲソ。 まぁここではこんなものがGCルートになる可能性があるよ、ということで"
"いいんじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:109
msgid "### root_StablePtrsとは何か"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:114
msgid ""
"[Foreign.StablePtr.newStablePtr(これはGHCのAPI)](http://www.haskell.org/ghc/"
"docs/latest/html/libraries/base/Foreign-StablePtr.html#v:newStablePtr)  を"
"Haskellコードから呼ぶとstruct StablePtrがstableptr.cでmalloc確保されて、 "
"root_StablePtrsに繋がれるんでゲソ。 つまりStablePtrを保管する器ということじゃ"
"なイカ。リストより木構造の方が良い気もするでゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:124
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- | newStablePtr will seq its argument to get rid of nasty GC issues and be\n"
"-- compatible with FFI calling conventions, if this is an issue, you can put an\n"
"-- extra box around it.\n"
"newStablePtr :: a -> IO (StablePtr a)\n"
"newStablePtr x = do\n"
"    fromUIO $ \\w -> case c_newStablePtr (toBang_ x) w of\n"
"        (# w', s #) -> (# w', fromBang_ s #)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:134
#, no-wrap
msgid ""
"~~~ {.c}\n"
"wptr_t c_newStablePtr(sptr_t c) {\n"
"    struct StablePtr* sp = malloc(sizeof(struct StablePtr));\n"
"    sp->contents = c;\n"
"    LIST_INSERT_HEAD(&root_StablePtrs, sp, link);\n"
"    assert(GET_PTYPE(sp) == 0);\n"
"    return (wptr_t)TO_SPTR(P_VALUE,(wptr_t)sp);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:136
msgid "### 他にGCルートになるものは？"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:140
msgid ""
"さすがに上の2つだけがGCルートのはずないでゲソ。根っこがスカスカじゃなイカ。 "
"もう一つGCルートがあり、それはC言語のミューテターがコツコツ作るGCスタックでゲ"
"ソ。 gc_perform_gc関数の続きを読むと..."
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:170
#, no-wrap
msgid ""
"~~~ {.c}\n"
"        stack_check(&stack, gc - gc_stack_base);\n"
"        number_stack = gc - gc_stack_base;\n"
"        for(unsigned i = 0; i < number_stack; i++) {\n"
"                debugf(\" |\");\n"
"                // TODO - short circuit redirects on stack\n"
"                sptr_t ptr = gc_stack_base[i];\n"
"                if(1 && (IS_LAZY(ptr))) {\n"
"                        assert(GET_PTYPE(ptr) == P_LAZY);\n"
"                        VALGRIND_MAKE_MEM_DEFINED(FROM_SPTR(ptr), sizeof(uintptr_t));\n"
"                        if(!IS_LAZY(GETHEAD(FROM_SPTR(ptr)))) {\n"
"                                void *gptr = TO_GCPTR(ptr);\n"
"                                if(gc_check_heap(gptr))\n"
"                                        s_set_used_bit(gptr);\n"
"                                number_redirects++;\n"
"                                debugf(\" *\");\n"
"                                ptr = (sptr_t)GETHEAD(FROM_SPTR(ptr));\n"
"                        }\n"
"                }\n"
"                if(__predict_false(!IS_PTR(ptr))) {\n"
"                        debugf(\" -\");\n"
"                        continue;\n"
"                }\n"
"                number_ptr++;\n"
"                entry_t *e = TO_GCPTR(ptr);\n"
"                debugf(\" %p\",(void *)e);\n"
"                gc_add_grey(&stack, e);\n"
"        }\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:174
msgid ""
"このコードはgcからgc_stack_baseまでの領域の差す先を entry_tポインタとして"
"gc_add_grey関数に食わせるでゲソ。 gcとgc_stack_baseはプログラム起動時には同じ"
"場所を指しているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:186
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void\n"
"jhc_alloc_init(void) {\n"
"        VALGRIND_PRINTF(\"Jhc-Valgrind mode active.\\n\");\n"
"#ifdef _JHC_JGC_FIXED_MEGABLOCK\n"
"        saved_gc = gc_stack_base = (void *) gc_stack_base_area;\n"
"#else\n"
"        saved_gc = gc_stack_base = malloc((1UL << 18)*sizeof(gc_stack_base[0]));\n"
"#endif\n"
"        arena = new_arena();\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:188
msgid "ところがミューテターの中にgc_frame0関数というのがよくあらわれるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:220
#, no-wrap
msgid ""
"~~~ {.c}\n"
"static wptr_t A_STD A_MALLOC\n"
"fR$__fJhc_Basics_$pp(gc_t gc,sptr_t v80776080,sptr_t v58800110)\n"
"{\n"
"        {   gc_frame0(gc,1,v58800110); // <= GCルートにv58800110を登録\n"
"            wptr_t v100444 = eval(gc,v80776080);\n"
"            if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100444) {\n"
"                return eval(gc,v58800110);\n"
"            } else {\n"
"                sptr_t v106;\n"
"                sptr_t v108;\n"
"                /* (\"CJhc.Prim.Prim.:\" ni106 ni108) */\n"
"                v106 = ((struct sCJhc_Prim_Prim_$x3a*)v100444)->a1;\n"
"                v108 = ((struct sCJhc_Prim_Prim_$x3a*)v100444)->a2;\n"
"                {   gc_frame0(gc,2,v106,v108); // <= GCルートにv106とv108を登録\n"
"                    sptr_t x7 = s_alloc(gc,cFR$__fJhc_Basics_$pp);\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x7)->head = TO_FPTR(&E__fR$__fJhc_Basics_$pp);\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x7)->a1 = v108;\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x7)->a2 = v58800110;\n"
"                    sptr_t v69834446 = MKLAZY(x7);\n"
"                    {   gc_frame0(gc,1,v69834446); // <= GCルートにv69834446を登録\n"
"                        wptr_t x8 = s_alloc(gc,cCJhc_Prim_Prim_$x3a);\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x8)->a1 = v106;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x8)->a2 = v69834446;\n"
"                        return x8;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:222
msgid ""
"このgc_frame0関数はイカのような実装で、つまり上のミューテターはGCルートに"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:226
msgid "v58800110: 関数の引数の一つ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:226
msgid "v106とv108: v100444のメンバー。v100444自体はGCルートに登録されない"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:226
msgid ""
"v69834446: s_alloc関数で確保したx7スマートポインタに遅延ビットを立てたもの"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:228
msgid "の4つを登録しているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:234
#, no-wrap
msgid ""
"~~~ {.c}\n"
"#define gc_frame0(gc,n,...) void *ptrs[n] = { __VA_ARGS__ }; \\\n"
"        for(int i = 0; i < n; i++) gc[i] = (sptr_t)ptrs[i]; \\\n"
"        gc_t sgc = gc;  gc_t gc = sgc + n;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:239
msgid ""
"どーせs_alloc関数を呼ばないかぎりはGCは走らないので、 GCルートに追加するタイ"
"ミングはs_alloc関数の直前まではあんまり厳密にしなくても良いはずでゲソ。 ま"
"た、eval関数はサンクの評価を行なう可能性があり、その中でs_alloc関数を呼び出す"
"可能性があるので、 その直前でGCルートを最新の情報に更新しておく必要があるはず"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:245
msgid ""
"ミューテターをC言語で書いていても、コンパイルパイプラインで自動生成するように"
"すれば、 gc_frame0関数の挿入のようなアイデアも実装漏れが起きることを気にしな"
"いで実現できるでゲソ。 いいじゃなイカ! しかもこの\"gc\"という参照でゲソが、ス"
"コープを抜けると元の位置を自動的に指すようになっているでゲソ。 C言語のスコー"
"プを使った上手いスタックの実現方法でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:250
msgid ""
"ただしこのjgcのGCスタックはC言語のスタックに強く紐づいているため、 再入を実現"
"するためにはGCスタックもコンテキスト分持つ必要があるでゲソ。 例えばLWP毎に一"
"つ必要になるはずでゲソ。 さらに多重割り込みを考慮すると割り込み毎に一つ必要に"
"なるはずじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:252
msgid "## ミューテターにとってのクリティカルリージョンは？"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:254
msgid ""
"まずイカの関数は単一のHaskellヒープをさわってしまうので、なんらかの排他処理が"
"必要になるはずでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262
msgid "gc_perform_gc"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262
msgid "s_alloc"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262
msgid "gc_add_root"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262
msgid "gc_array_alloc"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262
msgid "gc_array_alloc_atomic"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262 posts/2013-06-20-reentrant_jhc.md:322
msgid "gc_malloc_foreignptr"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-17-jgc_detail.md:262 posts/2013-06-20-reentrant_jhc.md:322
msgid "gc_new_foreignptr"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:270
msgid ""
"これらの関数はajhc/rts/rts/gc_jgc.cで閉じているので、C言語実装で比較的容易に"
"排他処理できそうでゲソ。 またgc_frame0マクロはgcポインタを作りなおすだけなの"
"でゲソが、 コンストラクタを呼んでスマートポインタを得てからgcポインタの位置を"
"ずらしているでゲソ。 この方式のままだとコンストラクタ+GCルート登録までを排他"
"するか、 自コンテキストから他コンテキストとでヒープを分けるか...とにかく使え"
"るしろものではないじゃなイカ。 さらに並列実行の時にいったいどーやって誰が"
"gc_perform_gcすれば良いのかは今のところアイデアがないでゲソ...  完全に並列GC"
"にする方法があるのか、はたまたジャイアントロックするにしても他のコンテキスト"
"を停止させる方法があるのか謎でゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:272
msgid "## 参照はループになるか？"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:277
msgid ""
"おそらくループなることはないでゲソ。 gc_perform_gc関数を読むかぎりでは参照"
"ループを検出しているようには見えないでゲソ。 それなら参照カウントを使ったGCを"
"導入することも可能なんじゃなイカ？ メジャーGCが走る頻度を下げることが可能かも"
"しれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:279
msgid "## GCを中断/再開できるか"
msgstr ""

#. type: Plain text
#: posts/2013-05-17-jgc_detail.md:284
msgid ""
"jgcではGC開始時にused_bitを全クリアしていまうため、 マーキングフェーズが完全"
"に完了しないかぎりヒープ領域の内でどこを使って良いのか判別できないでゲソ。 無"
"理矢理回避策を考えるとするとビットマーク領域を2倍持っておいて、 一方を空き領"
"域検索用に、一方を漸進的なマーキング用に使うというアイデアでゲソ。 ただ、ほん"
"とうにこの実装で上手くいくかはやってみないとわからないところでゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:5
#, no-wrap
msgid ""
"title: Jhc compile pipeline: Grin => C (code example)\n"
"description: jhcコンパイルパイプラインを後段から順番に読んでいかなイカ？\n"
"tags: compiler, jhc, c, grin\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:9
msgid ""
"お待ちかねでゲソ! jhcのコンパイルパイプラインを詳細に調査してみようと思うで"
"ゲッソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:20
msgid ""
"~~~ $ cat Fib.hs fibonacci :: [Int] fibonacci = 1:1:zipWith (+) fibonacci "
"(tail fibonacci)  main :: IO ()  main = print $ take 40 fibonacci $ make sh "
"jhc_dump_code.sh Fib.hs > jhc_dump_code.log 2>&1 dot -Tpng hs.out_grin.dot > "
"hs.out_grin.dot.png ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:25
msgid ""
"この簡単なフィボナッチ数列を出力するだけのプログラムをjhcでコンパイルして、 "
"[そのダンプ](https://gitorious.org/metasepi/jhc-arafura/trees/arafura/"
"metasepi-arafura/misc/jhc_dump_fib)  を取ったでゲソ。 今回はその中でイカの2つ"
"を比較することで、GrinからC言語への変換がどのようになっているのか調査してみよ"
"うと思うでゲッソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-16-jhc_grin_to_c.md:28
msgid ""
"[hs.out_final.grin](https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/"
"metasepi-arafura/misc/jhc_dump_fib/hs.out_final.grin) - C言語への変換直前の"
"Grin"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-05-16-jhc_grin_to_c.md:28
msgid ""
"[hs.out_code.c](https://gitorious.org/metasepi/jhc-arafura/blobs/arafura/"
"metasepi-arafura/misc/jhc_dump_fib/hs.out_code.c) - 最終的なC言語ソース"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:30
msgid ""
"一応、上記のダンプが所望のものかどうかjhc本体のソースコードでチェックしてきる"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:43
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- jhc/src/Grin/Main.hs\n"
"compileToGrin prog = do\n"
"    stats <- Stats.new\n"
"    putProgressLn \"Converting to Grin...\"\n"
"-- snip --\n"
"    x <- storeAnalyze x\n"
"    => dumpFinalGrin x\n"
"       writeFile (outputName ++ \"_grin.dot\") (graphGrin grin)\n"
"       dumpGrin \"final\" grin\n"
"    compileGrinToC x\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:46
msgid ""
"うん。ちゃんとC言語に変換する直前のダンプでゲソ。 先のhs.out_final.grinを見て"
"みるとグローバルから辿れる要素はイカのようでゲソ。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Caf: v-930757141"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: b_main :: () -> ()"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -> (N)"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fJhc.Show.shows :: (I,I) -> (N)"
msgstr ""

#. type: Bullet: '5. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fR@.fJhc.Show.11_showl :: (I,N) -> (N)"
msgstr ""

#. type: Bullet: '6. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: ftheMain$2 :: (I,I) -> (N)"
msgstr ""

#. type: Bullet: '7. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fR@.fJhc.Basics.++ :: (I,N) -> (N)"
msgstr ""

#. type: Bullet: '8. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: ftheMain$3 :: () -> (N)"
msgstr ""

#. type: Bullet: '9. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fR@.fJhc.Basics.zipWith :: (I,I) -> (N)"
msgstr ""

#. type: Bullet: '10. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -> (N)"
msgstr ""

#. type: Bullet: '11. '
#: posts/2013-05-16-jhc_grin_to_c.md:58
msgid "Func: ftheMain :: () -> ()"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:60
msgid ""
"また、上記の関数は-dgrin-graphが吐いた図によるとイカのような関係にあるらしい"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:62
msgid ""
"[![](https://gitorious.org/metasepi/jhc-arafura/blobs/"
"raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/misc/"
"jhc_dump_fib/hs.out_grin.dot.png)](https://gitorious.org/metasepi/jhc-"
"arafura/blobs/raw/4c932225363068e235d211ad9340c94d2be45907/metasepi-arafura/"
"misc/jhc_dump_fib/hs.out_grin.dot.png)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:65
msgid ""
"これらがどのようにC言語に写像されているか、 また逆にC言語ソースコードで上記由"
"来ではない部分が存在するかどうかチェックしてみなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:67
msgid "## ダンプ解析 (例による理解)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:69
msgid "### 1. Caf: v-930757141"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:75
msgid "~~~ {.haskell} -- Grin -- -- Cafs v-930757141 := (FtheMain$3)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:84
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"typedef struct fptr * fptr_t;\n"
"typedef struct sptr * sptr_t;\n"
"typedef struct node {\n"
"        fptr_t head;\n"
"        sptr_t rest[];\n"
"} A_MAYALIAS node_t;\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:93
#, no-wrap
msgid ""
"#define P_WHNF  0x0\n"
"#define P_LAZY  0x1\n"
"#define P_VALUE 0x2\n"
"#define P_FUNC  0x3\n"
"#define TO_SPTR_C(t,x) (typeof (x))((uintptr_t)(x) + (t))\n"
"        // attach a ptype to a smart pointer, suitable for use by constant initialializers\n"
"#define TO_FPTR(fn)   TO_SPTR_C(P_FUNC,(fptr_t)fn)\n"
"#define MKLAZY_C(fn)  TO_SPTR_C(P_LAZY,(sptr_t)fn)\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:99
msgid ""
"/* CAFS */ /* v-930757141 = (FtheMain$3)*/ static node_t _g930757141 = { ."
"head = TO_FPTR(&E__ftheMain$d3) }; #define g930757141 "
"(MKLAZY_C(&_g930757141))  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:107
msgid ""
"これを図にまとめると、イカのようになるでゲソ。 CAF(Constant Applicative "
"Form) というのは 「一度実行したら、その結果をメモ化して使いまわせるもの」のこ"
"とでゲソ。 ^[[簡約!? λカ娘(算) - 参照透明な海を守る会](http://www.paraiso-"
"lang.org/ikmsm/books/c82.html) を参照] ということはg930757141というのは未評価"
"のサンクで、 このサンクの値を評価して確定させるためにはCode pointerの先にあ"
"る E__ftheMain$d3()関数を実行する必要があるということが予想できるじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:109
msgid "![](/draw/2013-02-14-jhc_grin_to_c_1_v-930757141.png)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:111
msgid "ではこのサンクg930757141はどのように使われるんでゲソ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:117
msgid ""
"~~~ {.c} const void * const nh_stuff[] = { &_g930757141, &_c1, &_c2, &_c3, "
"NULL }; ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:122
msgid ""
"まずnh_stuff配列から参照されているでゲソ。 これはGCルートのようでゲソ。 グ"
"ローバルから見えるサンクは当然解放することができないので、 GCルートになるはず"
"でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:138
#, no-wrap
msgid ""
"~~~ {.c}\n"
"ftheMain\n"
"=> eval(gc,g930757141)\n"
"   void *ds = FROM_SPTR(g930757141); // (uintptr_t)(x) & ~0x3)\n"
"   sptr_t h = (sptr_t)(GETHEAD(ds)); // ((node_t *)(x))->head\n"
"   eval_fn fn = (eval_fn)FROM_SPTR(h);\n"
"   => wptr_t r =  E__ftheMain$d3(gc,_g930757141); // (*fn)(gc,NODEP(ds));\n"
"      => wptr_t r2 = ftheMain$d3(gc);\n"
"         => return fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));\n"
"      => update(_g930757141,r2);\n"
"         GETHEAD(_g930757141) = (fptr_t)r2;\n"
"      gc_add_root(gc,(sptr_t)r2);\n"
"      return r2;\n"
"   return r;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:144
msgid ""
"さらg930757141はevel()関数を通して評価され、 最終的に_g930757141のheadメン"
"バーをftheMain$d3()関数の実行結果で上書きしているでゲソ。 結局eval()関数を通"
"したことで、g930757141は未評価サンクから評価済みサンクに変化したんでゲソ。 こ"
"のeval()関数、場合によってはさらにその子供のサンクを評価するために一度実行に"
"入ると長い時間滞留する可能性があるでゲソ。 jhcのコンパイル結果にeval()を使っ"
"ている箇所があったら注意して確認する必要があるということになるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:146
msgid "### 2. Func: b_main :: () -> ()"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:154
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"-- Functions\n"
"b_main :: () -> ()\n"
"b_main  = do\n"
"  ftheMain\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:162
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"void\n"
"_amain(void)\n"
"{\n"
"        return (void)b__main(saved_gc);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:169 posts/2013-05-16-jhc_grin_to_c.md:945
#, no-wrap
msgid ""
"static void A_STD\n"
"b__main(gc_t gc)\n"
"{\n"
"        return ftheMain(gc);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:173
msgid ""
"うむ。これはなんかそのままでゲソ。 あえて違うところを挙げるとするならsaved_gc"
"を引数で取り回すということでゲソ。 saved_gcはjgcの機能なので、別のGCを選択し"
"た場合には当然この出力も変化するはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:175
msgid "### 3. Func: fW@.fJhc.Inst.Show.showWord :: (bits32,I) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:201
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fW@.fJhc.Inst.Show.showWord :: (bits32,I) -> (N)\n"
"fW@.fJhc.Inst.Show.showWord w1540496947 ni1826240557 = do\n"
"  let\n"
"      fW@.fR@.fJhc.Inst.Show.showWord w80100072 ni196335308 = do\n"
"        w40405746 <- w80100072 / 10\n"
"        w253468956 <- w80100072 % 10\n"
"        bm124940226 <- (bits<max>)ConvOp Zx bits32 w253468956\n"
"        w132127022 <- (bits32)ConvOp Lobits bits<max> bm124940226\n"
"        w26031830 <- 48 + w132127022\n"
"        w260152044 <- (bits32)ConvOp B2B bits32 w26031830\n"
"        withRoots(ni196335308)\n"
"          nd122 <- dstore (CJhc.Type.Basic.Char w260152044)\n"
"          ni55102202 <- demote nd122\n"
"          case w40405746 of\n"
"            0 -> withRoots(ni55102202)\n"
"              dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)\n"
"            w0 -> withRoots(ni55102202)\n"
"              nd15 <- dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)\n"
"              ni1829124143 <- demote nd15\n"
"              fW@.fR@.fJhc.Inst.Show.showWord w40405746 ni1829124143\n"
"   in\n"
"    fW@.fR@.fJhc.Inst.Show.showWord w1540496947 ni1826240557\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:246
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fW$__fJhc_Inst_Show_showWord(gc_t gc,uint32_t v1540496947,sptr_t v1826240557)\n"
"{\n"
"        sptr_t v196335308;\n"
"        uint32_t v80100072;\n"
"        // let fW@.fR@.fJhc.Inst.Show.showWord w80100072 ni196335308 = do\n"
"        // fW@.fR@.fJhc.Inst.Show.showWord w1540496947 ni1826240557\n"
"        v80100072 = v1540496947;\n"
"        v196335308 = v1826240557;\n"
"        fW$__fR$__fJhc_Inst_Show_showWord__2:;\n"
"        {   uint32_t v40405746 = (v80100072 / 10); // w40405746 <- w80100072 / 10\n"
"            uint32_t v253468956 = (v80100072 % 10); // w253468956 <- w80100072 % 10\n"
"            uintmax_t v124940226 = ((uintmax_t)v253468956); // bm124940226 <- (bits<max>)ConvOp Zx bits32 w253468956\n"
"            uint32_t v132127022 = ((uint32_t)v124940226); // w132127022 <- (bits32)ConvOp Lobits bits<max> bm124940226\n"
"            uint32_t v26031830 = (48 + v132127022); // w26031830 <- 48 + w132127022\n"
"            uint32_t v260152044 = v26031830; // w260152044 <- (bits32)ConvOp B2B bits32 w26031830\n"
"            {   gc_frame0(gc,1,v196335308);\n"
"                wptr_t v122 = RAW_SET_UF(v260152044); // nd122 <- dstore (CJhc.Type.Basic.Char w260152044)\n"
"                sptr_t v55102202 = demote(v122); // ni55102202 <- demote nd122\n"
"                if (0 == v40405746) { // case w40405746 of 0 ->\n"
"                    {   gc_frame0(gc,1,v55102202);\n"
"                        wptr_t x3 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x3)->a1 = v55102202;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x3)->a2 = v196335308;\n"
"                        return x3;\n"
"                    }\n"
"                } else { // w0 ->\n"
"                    {   gc_frame0(gc,1,v55102202);\n"
"                        wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // nd15 <- dstore (CJhc.Prim.Prim.: ni55102202 ni196335308)\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x4)->a1 = v55102202;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x4)->a2 = v196335308;\n"
"                        wptr_t v15 = x4;\n"
"                        sptr_t v1829124143 = demote(v15); // ni1829124143 <- demote nd15\n"
"                        v80100072 = v40405746; // fW@.fR@.fJhc.Inst.Show.showWord w40405746 ni1829124143\n"
"                        v196335308 = v1829124143;\n"
"                        goto fW$__fR$__fJhc_Inst_Show_showWord__2;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:250
msgid ""
"C言語側にGrinコード断片をコメントで入れてみたでゲソ。 だいたい1対1に対応が取"
"れているじゃなイカ。 ここではGrinとC言語の違いに着目して、そのしくみを詳しく"
"見てみるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:254
msgid ""
"まず第一にdstore (CJhc.Type.Basic.Char,x)がRAW_SET_UF(x)になることがあるでゲ"
"ソ。 このRAW_SET_UF()はイカのような定義で、即値のWHNFに変換してくれるでゲ"
"ソ。 CJhc.Type.Basic.Charは即値なので、RAW_SET_UF()を使ってスマートポインタに"
"埋め込まれるんじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:258
msgid ""
"~~~ {.c} #define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) << 2) | P_VALUE))  "
"~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:266
msgid ""
"ところがdstore (CJhc.Prim.Prim.: x y)  のような場合にはイカのようにs_alloc()"
"でヒープへのスマートポインタを作って、 格納するでゲソ。 これはHaskellの(:)演"
"算子を思いうかべればすぐわかるでゲソ。 (:)演算子は2つの要素をconsし、 その"
"consした結果がstruct sCJhc_Prim_Prim_$x3aなんでゲソ。 つまりconsする旅にヒー"
"プの領域を消費するということでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:272 posts/2013-05-16-jhc_grin_to_c.md:976
#, no-wrap
msgid ""
"~~~ {.c}\n"
"struct sCJhc_Prim_Prim_$x3a {\n"
"    sptr_t a1;\n"
"    sptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:277
msgid ""
"wptr_t x4 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); ((struct sCJhc_Prim_Prim_"
"$x3a*)x4)->a1 = x; ((struct sCJhc_Prim_Prim_$x3a*)x4)->a2 = y; ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:281
msgid ""
"最後にfW@.fR@.fJhc.Inst.Show.showWord関数の再帰がgotoループになっているでゲ"
"ソ。 たまたまこの関数の例はすぐにループ化できる再帰だから良かったでゲソ。 し"
"かし、原理的に全ての再帰がループ化されるのカ？少し不安でゲソ..."
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:283
msgid "### 4. Func: fJhc.Show.shows :: (I,I) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:305
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fJhc.Show.shows :: (I,I) -> (N)\n"
"fJhc.Show.shows ni29375120 ni44000678 = do\n"
"  withRoots(ni44000678)\n"
"    nd100038 <- eval ni29375120\n"
"    (CJhc.Type.Word.Int w216085094) <- return nd100038\n"
"    h100040 <- 0 `Gt` w216085094\n"
"    case h100040 of\n"
"      1 -> do\n"
"        w196289068 <- (bits32)Neg w216085094\n"
"        bm253468954 <- (bits<max>)ConvOp Sx bits32 w196289068\n"
"        w124235152 <- (bits32)ConvOp Lobits bits<max> bm253468954\n"
"        ni244126258 <- istore (FW@.fJhc.Inst.Show.showWord w124235152 ni44000678)\n"
"        withRoots(ni244126258)\n"
"          dstore (CJhc.Prim.Prim.: &(CJhc.Type.Basic.Char 45) ni244126258)\n"
"      0 -> do\n"
"        bm220263214 <- (bits<max>)ConvOp Sx bits32 w216085094\n"
"        w110207578 <- (bits32)ConvOp Lobits bits<max> bm220263214\n"
"        fW@.fJhc.Inst.Show.showWord w110207578 ni44000678\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:341
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fJhc_Show_shows(gc_t gc,sptr_t v29375120,sptr_t v44000678)\n"
"{\n"
"        {   uint32_t v216085094;\n"
"            gc_frame0(gc,1,v44000678); // withRoots(ni44000678)\n"
"            wptr_t v100038 = eval(gc,v29375120); // nd100038 <- eval ni29375120\n"
"            v216085094 = ((struct sCJhc_Type_Word_Int*)v100038)->a1; // (CJhc.Type.Word.Int w216085094) <- return nd100038\n"
"            uint16_t v100040 = (((int32_t)0) > ((int32_t)v216085094)); // h100040 <- 0 `Gt` w216085094\n"
"            if (0 == v100040) { // case h100040 of 0 -> do\n"
"                uintmax_t v220263214 = ((intmax_t)((int32_t)v216085094)); // bm220263214 <- (bits<max>)ConvOp Sx bits32 w216085094\n"
"                uint32_t v110207578 = ((uint32_t)v220263214); // w110207578 <- (bits32)ConvOp Lobits bits<max> bm220263214\n"
"                return fW$__fJhc_Inst_Show_showWord(gc,v110207578,v44000678); // fW@.fJhc.Inst.Show.showWord w110207578 ni44000678\n"
"            } else { // 1 -> do\n"
"                /* 1 */\n"
"                assert(1 == v100040);\n"
"                uint32_t v196289068 = (-((int32_t)v216085094)); // w196289068 <- (bits32)Neg w216085094\n"
"                uintmax_t v253468954 = ((intmax_t)((int32_t)v196289068)); // bm253468954 <- (bits<max>)ConvOp Sx bits32 w196289068\n"
"                uint32_t v124235152 = ((uint32_t)v253468954); // w124235152 <- (bits32)ConvOp Lobits bits<max> bm253468954\n"
"                sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord); // ni244126258 <- istore (FW@.fJhc.Inst.Show.showWord w124235152 ni44000678)\n"
"                ((struct sFW$__fJhc_Inst_Show_showWord*)x5)->head = TO_FPTR(&E__fW$__fJhc_Inst_Show_showWord);\n"
"                ((struct sFW$__fJhc_Inst_Show_showWord*)x5)->a1 = v124235152;\n"
"                ((struct sFW$__fJhc_Inst_Show_showWord*)x5)->a2 = v44000678;\n"
"                sptr_t v244126258 = MKLAZY(x5);\n"
"                {   gc_frame0(gc,1,v244126258); // withRoots(ni244126258)\n"
"                    wptr_t x6 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: &(CJhc.Type.Basic.Char 45) ni244126258)\n"
"                    ((struct sCJhc_Prim_Prim_$x3a*)x6)->a1 = ((sptr_t)RAW_SET_UF('-'));\n"
"                    ((struct sCJhc_Prim_Prim_$x3a*)x6)->a2 = v244126258;\n"
"                    return x6;\n"
"                }\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:345
msgid ""
"これもほぼ1対1に対応しているでゲソが、唯一の例外が istore (FW@.fJhc.Inst."
"Show.showWord x y)  がs_alloc()によるヒープの確保に化けることでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:352
#, no-wrap
msgid ""
"~~~ {.c}\n"
"struct sFW$__fJhc_Inst_Show_showWord {\n"
"    fptr_t head;\n"
"    sptr_t a2;\n"
"    uint32_t a1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:359
msgid ""
"sptr_t x5 = s_alloc(gc,cFW$__fJhc_Inst_Show_showWord); ((struct sFW"
"$__fJhc_Inst_Show_showWord*)x5)->head = TO_FPTR(&E__fW"
"$__fJhc_Inst_Show_showWord); ((struct sFW$__fJhc_Inst_Show_showWord*)x5)->a1 "
"= x; ((struct sFW$__fJhc_Inst_Show_showWord*)x5)->a2 = y; sptr_t v244126258 "
"= MKLAZY(x5); ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:365
msgid ""
"この謎はjhcのjhcライブラリのソース見れば理解できるでゲソ。 showWord関数はイカ"
"のように通常のLazyな関数じゃなイカ。 ということはここでは未評価サンクだけ作り"
"後で誰かがforceしてくれるのを待てばいいんでゲソ。 ここで作成する未評価サンク"
"の実体がstruct sFW$__fJhc_Inst_Show_showWordで、 やはりヒープに確保されるでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:373
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- jhc/lib/jhc/Jhc/Inst/Show.hs\n"
"showWord :: Word -> String -> String\n"
"showWord w rest = w `seq` case quotRem w 10 of\n"
"    (n',d) -> n' `seq` d `seq` rest' `seq` if n' == 0 then rest' else showWord n' rest'\n"
"        where rest' = chr (fromIntegral d + ord '0') : rest\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:375
msgid "### 5. Func: fR@.fJhc.Show.11_showl :: (I,N) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:393
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fR@.fJhc.Show.11_showl :: (I,N) -> (N)\n"
"fR@.fJhc.Show.11_showl ni108431528 nd267777212 = do\n"
"  ni267777293 <- demote nd267777212\n"
"  withRoots(nd267777212,ni267777293)\n"
"    nd100036 <- eval ni108431528\n"
"    (ni126,ni95) <- case nd100036 of\n"
"      (CJhc.Prim.Prim.: ni26 ni67) -> withRoots(ni26,ni67)\n"
"        ni110947984 <- istore (FR@.fJhc.Show.11_showl ni67 nd267777212)\n"
"        withRoots(ni110947984)\n"
"          ni215884490 <- istore (FJhc.Show.shows ni26 ni110947984)\n"
"          return (&(CJhc.Type.Basic.Char 44),ni215884490)\n"
"      [] -> return (&(CJhc.Type.Basic.Char 93),ni267777293)\n"
"    withRoots(ni95,ni126)\n"
"      dstore (CJhc.Prim.Prim.: ni126 ni95)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:442
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fR$__fJhc_Show_11__showl(gc_t gc,sptr_t v108431528,wptr_t v267777212)\n"
"{\n"
"        sptr_t v267777293 = demote(v267777212); // ni267777293 <- demote nd267777212\n"
"        {   sptr_t v126;\n"
"            sptr_t v95;\n"
"            struct tup1 x7;\n"
"            gc_frame0(gc,2,v267777212,v267777293); // withRoots(nd267777212,ni267777293)\n"
"            wptr_t v100036 = eval(gc,v108431528); // nd100036 <- eval ni108431528\n"
"            if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100036) { // case nd100036 of [] ->\n"
"                x7.t0 = ((sptr_t)RAW_SET_UF(']')); // return (&(CJhc.Type.Basic.Char 93),ni267777293)\n"
"                x7.t1 = v267777293;\n"
"            } else { // (CJhc.Prim.Prim.: ni26 ni67) ->\n"
"                sptr_t v26;\n"
"                sptr_t v67;\n"
"                /* (\"CJhc.Prim.Prim.:\" ni26 ni67) パターンマッチ */\n"
"                v26 = ((struct sCJhc_Prim_Prim_$x3a*)v100036)->a1;\n"
"                v67 = ((struct sCJhc_Prim_Prim_$x3a*)v100036)->a2;\n"
"                {   gc_frame0(gc,2,v26,v67); // withRoots(ni26,ni67)\n"
"                    sptr_t x8 = s_alloc(gc,cFR$__fJhc_Show_11__showl); // ni110947984 <- istore (FR@.fJhc.Show.11_showl ni67 nd267777212)\n"
"                    ((struct sFR$__fJhc_Show_11__showl*)x8)->head = TO_FPTR(&E__fR$__fJhc_Show_11__showl);\n"
"                    ((struct sFR$__fJhc_Show_11__showl*)x8)->a1 = v67;\n"
"                    ((struct sFR$__fJhc_Show_11__showl*)x8)->a2 = v267777212;\n"
"                    sptr_t v110947984 = MKLAZY(x8);\n"
"                    {   gc_frame0(gc,1,v110947984); // withRoots(ni110947984)\n"
"                        sptr_t x9 = s_alloc(gc,cFJhc_Show_shows); // ni215884490 <- istore (FJhc.Show.shows ni26 ni110947984)\n"
"                        ((struct sFJhc_Show_shows*)x9)->head = TO_FPTR(&E__fJhc_Show_shows);\n"
"                        ((struct sFJhc_Show_shows*)x9)->a1 = v26;\n"
"                        ((struct sFJhc_Show_shows*)x9)->a2 = v110947984;\n"
"                        sptr_t v215884490 = MKLAZY(x9);\n"
"                        x7.t0 = ((sptr_t)RAW_SET_UF(',')); // return (&(CJhc.Type.Basic.Char 44),ni215884490)\n"
"                        x7.t1 = v215884490;\n"
"                    }\n"
"                }\n"
"            }\n"
"            v126 = x7.t0; // (ni126,ni95) <-\n"
"            v95 = x7.t1;\n"
"            {   gc_frame0(gc,2,v95,v126); // withRoots(ni95,ni126)\n"
"                wptr_t x10 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: ni126 ni95)\n"
"                ((struct sCJhc_Prim_Prim_$x3a*)x10)->a1 = v126;\n"
"                ((struct sCJhc_Prim_Prim_$x3a*)x10)->a2 = v95;\n"
"                return x10;\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:445
msgid ""
"ここまで来るとほぼこれまで仕入れた知識で読めるでゲソ! 新しく出てきた表現をあ"
"えて挙げるならタプルでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:452
#, no-wrap
msgid ""
"~~~ {.c}\n"
"struct tup1 {\n"
"    sptr_t t0;\n"
"    sptr_t t1;\n"
"};\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:455
msgid ""
"これはもう見たままでゲソ。タプルじゃなイカ。 ところでなんでいきなりタプルを使"
"うことになったんでゲソ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:459
msgid ""
"この関数はjhcライブラリのshowList関数の中にあるshowlローカル関数に由来してい"
"るでゲソ。 どうもShowS型の合成を (文字,サンク) というタプルでの表現に変換して"
"いるようじゃなイカ。 コンパイルパイプラインの最適化のどこでこの変換が行なわれ"
"るのか興味が出てきたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:463
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- jhc/lib/jhc/Jhc/Show.hs\n"
"type  ShowS    = String -> String\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:474
#, no-wrap
msgid ""
"class  Show a  where\n"
"-- snip --\n"
"    showList         :: [a] -> ShowS\n"
"-- snip --\n"
"    showList []       = showString \"[]\"\n"
"    showList (x:xs)   = showChar '[' . shows x . showl xs\n"
"                        where showl []     = showChar ']'\n"
"                              showl (x:xs) = showChar ',' . shows x .\n"
"                                             showl xs\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:476
msgid "### 6. Func: ftheMain$2 :: (I,I) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:490
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"ftheMain$2 :: (I,I) -> (N)\n"
"ftheMain$2 ni38 ni42 = do\n"
"  withRoots(ni42)\n"
"    nd100032 <- eval ni38\n"
"    withRoots(nd100032)\n"
"      nd100092 <- eval ni42\n"
"      (CJhc.Type.Word.Int w239029634) <- return nd100032\n"
"      (CJhc.Type.Word.Int w242159974) <- return nd100092\n"
"      w215350916 <- w239029634 + w242159974\n"
"      dstore (CJhc.Type.Word.Int w215350916)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:512
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"ftheMain$d2(gc_t gc,sptr_t v38,sptr_t v42)\n"
"{\n"
"        {   gc_frame0(gc,1,v42); // withRoots(ni42)\n"
"            wptr_t v100032 = eval(gc,v38); // nd100032 <- eval ni38\n"
"            {   uint32_t v239029634;\n"
"                uint32_t v242159974;\n"
"                gc_frame0(gc,1,v100032); // withRoots(nd100032)\n"
"                wptr_t v100092 = eval(gc,v42); // nd100092 <- eval ni42\n"
"                v239029634 = ((struct sCJhc_Type_Word_Int*)v100032)->a1; // (CJhc.Type.Word.Int w239029634) <- return nd100032\n"
"                v242159974 = ((struct sCJhc_Type_Word_Int*)v100092)->a1; // (CJhc.Type.Word.Int w242159974) <- return nd100092\n"
"                uint32_t v215350916 = (v239029634 + v242159974); // w215350916 <- w239029634 + w242159974\n"
"                wptr_t x11 = s_alloc(gc,cCJhc_Type_Word_Int); // dstore (CJhc.Type.Word.Int w215350916)\n"
"                ((struct sCJhc_Type_Word_Int*)x11)->a1 = v215350916;\n"
"                return x11;\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:516
msgid ""
"ここではじめて\"+\"演算子を使っているでゲソ。 中間に変数をはさんでいるのでわ"
"かりにくいでゲソが、全部展開するとイカのような処理のはずでゲソ。 jhcではプリ"
"ミティブ型が則、C言語のプリミティブ型に落ちるので、こんな芸当ができるんでゲ"
"ソ!"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:521
#, no-wrap
msgid ""
"~~~ {.c}\n"
"struct sCJhc_Type_Word_Int {\n"
"    uint32_t a1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:525
#, no-wrap
msgid ""
"((struct sCJhc_Type_Word_Int*)x11)->a1 =\n"
"  ((struct sCJhc_Type_Word_Int*)v100032)->a1 + ((struct sCJhc_Type_Word_Int*)v100092)->a1;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:527
msgid "### 7. Func: fR@.fJhc.Basics.++ :: (I,N) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:541
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fR@.fJhc.Basics.++ :: (I,N) -> (N)\n"
"fR@.fJhc.Basics.++ ni29534742 nd29534740 = do\n"
"  withRoots(nd29534740)\n"
"    nd100000 <- eval ni29534742\n"
"    case nd100000 of\n"
"      (CJhc.Prim.Prim.: ni106 ni108) -> withRoots(ni106,ni108)\n"
"        ni69834446 <- istore (FR@.fJhc.Basics.++ ni108 nd29534740)\n"
"        withRoots(ni69834446)\n"
"          dstore (CJhc.Prim.Prim.: ni106 ni69834446)\n"
"      [] -> return nd29534740\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:574
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fR$__fJhc_Basics_$pp(gc_t gc,sptr_t v29534742,wptr_t v29534740)\n"
"{\n"
"        {   gc_frame0(gc,1,v29534740); // withRoots(nd29534740)\n"
"            wptr_t v100000 = eval(gc,v29534742); // nd100000 <- eval ni29534742\n"
"            if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100000) { // case nd100000 of [] ->\n"
"                return v29534740; // return nd29534740\n"
"            } else { // (CJhc.Prim.Prim.: ni106 ni108) ->\n"
"                sptr_t v106;\n"
"                sptr_t v108;\n"
"                /* (\"CJhc.Prim.Prim.:\" ni106 ni108) パターンマッチ */\n"
"                v106 = ((struct sCJhc_Prim_Prim_$x3a*)v100000)->a1;\n"
"                v108 = ((struct sCJhc_Prim_Prim_$x3a*)v100000)->a2;\n"
"                {   gc_frame0(gc,2,v106,v108); // withRoots(ni106,ni108)\n"
"                    sptr_t x12 = s_alloc(gc,cFR$__fJhc_Basics_$pp); // ni69834446 <- istore (FR@.fJhc.Basics.++ ni108 nd29534740)\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x12)->head = TO_FPTR(&E__fR$__fJhc_Basics_$pp);\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x12)->a1 = v108;\n"
"                    ((struct sFR$__fJhc_Basics_$pp*)x12)->a2 = v29534740;\n"
"                    sptr_t v69834446 = MKLAZY(x12);\n"
"                    {   gc_frame0(gc,1,v69834446); // withRoots(ni69834446)\n"
"                        wptr_t x13 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: ni106 ni69834446)\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x13)->a1 = v106;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x13)->a2 = v69834446;\n"
"                        return x13;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:576
msgid "この関数はこれまでの調査結果で理解できるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:578
msgid "### 8. Func: ftheMain$3 :: () -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:585
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"ftheMain$3 :: () -> (N)\n"
"ftheMain$3  = do\n"
"  fR@.fJhc.Basics.++ &\"[]\" []\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:592
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"struct sCJhc_Prim_Prim_$x3a {\n"
"    sptr_t a1;\n"
"    sptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:596
#, no-wrap
msgid ""
"#define RAW_SET_UF(n)  ((wptr_t)(((uintptr_t)(n) << 2) | P_VALUE))\n"
"#define RAW_SET_16(w)  (wptr_t)(((uintptr_t)(w) << 16) | P_VALUE)\n"
"#define SET_RAW_TAG(x)    RAW_SET_16(x)\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:604
#, no-wrap
msgid ""
"enum {\n"
"    CJhc_Prim_Prim_$BE = 1,\n"
"    CJhc_Prim_Prim_$LR = 0,\n"
"    CJhc_Prim_Prim_$x3a = 0,\n"
"    CJhc_Type_Basic_Char = 0,\n"
"    CJhc_Type_Word_Int = 0\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:611
msgid ""
"/* (HcNode CJhc.Prim.Prim.: [Left &(\"CJhc.Type.Basic.Char\" 93),Left "
"&(\"CJhc.Prim.Prim.[]\")],1) */ static const struct sCJhc_Prim_Prim_$x3a _c1 "
"= {.a1 = (sptr_t)RAW_SET_UF(']'), .a2 = (sptr_t)SET_RAW_TAG(CJhc_Prim_Prim_"
"$BE)}; #define c1 (TO_SPTR_C(P_WHNF, (sptr_t)&_c1))  /* (HcNode CJhc.Prim."
"Prim.: [Left &(\"CJhc.Type.Basic.Char\" 91),Right 1],2) */ static const "
"struct sCJhc_Prim_Prim_$x3a _c2 = {.a1 = (sptr_t)RAW_SET_UF('['), .a2 = c1}; "
"#define c2 (TO_SPTR_C(P_WHNF, (sptr_t)&_c2))"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:618
#, no-wrap
msgid ""
"static wptr_t A_STD A_MALLOC\n"
"ftheMain$d3(gc_t gc)\n"
"{\n"
"        return fR$__fJhc_Basics_$pp(gc,c2,SET_RAW_TAG(CJhc_Prim_Prim_$BE));\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:620
msgid "いきなりc2というグローバル変数が出てきたじゃなイカ。これはなんでゲソ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:622
#, fuzzy
#| msgid "![](/draw/2012-12-27-compile.png)"
msgid "![](/draw/2013-02-17-jhc_grin_to_c_c2.png)"
msgstr "![](/draw/2012-12-27-compile.png)"

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:624
msgid ""
"なるほどたしかに fR@.fJhc.Basics.++ &\"[]\" [] とあったので\"[]\"という文字列"
"が欲しかったんでゲソね。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:626
msgid "### 9. Func: fR@.fJhc.Basics.zipWith :: (I,I) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:646
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fR@.fJhc.Basics.zipWith :: (I,I) -> (N)\n"
"fR@.fJhc.Basics.zipWith ni182639120 ni132127014 = do\n"
"  withRoots(ni132127014)\n"
"    nd100028 <- eval ni182639120\n"
"    case nd100028 of\n"
"      (CJhc.Prim.Prim.: ni40405740 ni40) -> withRoots(ni40,ni40405740)\n"
"        nd100030 <- eval ni132127014\n"
"        case nd100030 of\n"
"          (CJhc.Prim.Prim.: ni194635132 ni116) -> withRoots(ni116,ni194635132)\n"
"            ni248061794 <- istore (FR@.fJhc.Basics.zipWith ni40 ni116)\n"
"            withRoots(ni248061794)\n"
"              ni229109160 <- istore (FtheMain$2 ni40405740 ni194635132)\n"
"              withRoots(ni229109160)\n"
"                dstore (CJhc.Prim.Prim.: ni229109160 ni248061794)\n"
"          [] -> return []\n"
"      [] -> return []\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:698
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fR$__fJhc_Basics_zipWith(gc_t gc,sptr_t v182639120,sptr_t v132127014)\n"
"{\n"
"        {   gc_frame0(gc,1,v132127014); // withRoots(ni132127014)\n"
"            wptr_t v100028 = eval(gc,v182639120); // nd100028 <- eval ni182639120\n"
"            if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100028) { // case nd100028 of [] ->\n"
"                return v100028; // return []\n"
"            } else { // (CJhc.Prim.Prim.: ni40405740 ni40) ->\n"
"                sptr_t v40;\n"
"                sptr_t v40405740;\n"
"                /* (\"CJhc.Prim.Prim.:\" ni40405740 ni40) パターンマッチ */\n"
"                v40405740 = ((struct sCJhc_Prim_Prim_$x3a*)v100028)->a1;\n"
"                v40 = ((struct sCJhc_Prim_Prim_$x3a*)v100028)->a2;\n"
"                {   gc_frame0(gc,2,v40,v40405740); // withRoots(ni40,ni40405740)\n"
"                    wptr_t v100030 = eval(gc,v132127014); // nd100030 <- eval ni132127014\n"
"                    if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100030) { // case nd100030 of [] ->\n"
"                        return v100030; // return []\n"
"                    } else { // (CJhc.Prim.Prim.: ni194635132 ni116) ->\n"
"                        sptr_t v116;\n"
"                        sptr_t v194635132;\n"
"                        /* (\"CJhc.Prim.Prim.:\" ni194635132 ni116) パターンマッチ */\n"
"                        v194635132 = ((struct sCJhc_Prim_Prim_$x3a*)v100030)->a1;\n"
"                        v116 = ((struct sCJhc_Prim_Prim_$x3a*)v100030)->a2;\n"
"                        {   gc_frame0(gc,2,v116,v194635132); // withRoots(ni116,ni194635132)\n"
"                            sptr_t x14 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); // ni248061794 <- istore (FR@.fJhc.Basics.zipWith ni40 ni116)\n"
"                            ((struct sFR$__fJhc_Basics_zipWith*)x14)->head = TO_FPTR(&E__fR$__fJhc_Basics_zipWith);\n"
"                            ((struct sFR$__fJhc_Basics_zipWith*)x14)->a1 = v40;\n"
"                            ((struct sFR$__fJhc_Basics_zipWith*)x14)->a2 = v116;\n"
"                            sptr_t v248061794 = MKLAZY(x14);\n"
"                            {   gc_frame0(gc,1,v248061794); // withRoots(ni248061794)\n"
"                                sptr_t x15 = s_alloc(gc,cFtheMain$d2); // ni229109160 <- istore (FtheMain$2 ni40405740 ni194635132)\n"
"                                ((struct sFtheMain$d2*)x15)->head = TO_FPTR(&E__ftheMain$d2);\n"
"                                ((struct sFtheMain$d2*)x15)->a1 = v40405740;\n"
"                                ((struct sFtheMain$d2*)x15)->a2 = v194635132;\n"
"                                sptr_t v229109160 = MKLAZY(x15);\n"
"                                {   gc_frame0(gc,1,v229109160); // withRoots(ni229109160)\n"
"                                    wptr_t x16 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: ni229109160 ni248061794)\n"
"                                    ((struct sCJhc_Prim_Prim_$x3a*)x16)->a1 = v229109160;\n"
"                                    ((struct sCJhc_Prim_Prim_$x3a*)x16)->a2 = v248061794;\n"
"                                    return x16;\n"
"                                }\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:700
msgid "うむ。これも今の知識で読めるでゲソ。次の人!っでゲッソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:702
msgid "### 10. Func: fW@.fR@.fJhc.List.387_f :: (bits32,I) -> (N)"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:721
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"fW@.fR@.fJhc.List.387_f :: (bits32,I) -> (N)\n"
"fW@.fR@.fJhc.List.387_f w115160438 ni124940224 = do\n"
"  h100024 <- 0 `Gte` w115160438\n"
"  case h100024 of\n"
"    1 -> return []\n"
"    0 -> do\n"
"      nd100026 <- eval ni124940224\n"
"      case nd100026 of\n"
"        (CJhc.Prim.Prim.: ni304 ni306) -> do\n"
"          w194508206 <- w115160438 - 1\n"
"          withRoots(ni304,ni306)\n"
"            ni131889104 <- istore (FW@.fR@.fJhc.List.387_f w194508206 ni306)\n"
"            withRoots(ni131889104)\n"
"              dstore (CJhc.Prim.Prim.: ni304 ni131889104)\n"
"        [] -> return []\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:760
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static wptr_t A_STD A_MALLOC\n"
"fW$__fR$__fJhc_List_387__f(gc_t gc,uint32_t v115160438,sptr_t v124940224)\n"
"{\n"
"        uint16_t v100024 = (((int32_t)0) >= ((int32_t)v115160438)); // h100024 <- 0 `Gte` w115160438\n"
"        if (0 == v100024) { // case h100024 of 0 -> do\n"
"            wptr_t v100026 = eval(gc,v124940224); // nd100026 <- eval ni124940224\n"
"            if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100026) { // case nd100026 of [] ->\n"
"                return v100026; // return []\n"
"            } else { // (CJhc.Prim.Prim.: ni304 ni306) -> do\n"
"                sptr_t v304;\n"
"                sptr_t v306;\n"
"                /* (\"CJhc.Prim.Prim.:\" ni304 ni306) パターンマッチ */\n"
"                v304 = ((struct sCJhc_Prim_Prim_$x3a*)v100026)->a1;\n"
"                v306 = ((struct sCJhc_Prim_Prim_$x3a*)v100026)->a2;\n"
"                uint32_t v194508206 = (v115160438 - 1); // w194508206 <- w115160438 - 1\n"
"                {   gc_frame0(gc,2,v304,v306); // withRoots(ni304,ni306)\n"
"                    sptr_t x17 = s_alloc(gc,cFW$__fR$__fJhc_List_387__f); // ni131889104 <- istore (FW@.fR@.fJhc.List.387_f w194508206 ni306)\n"
"                    ((struct sFW$__fR$__fJhc_List_387__f*)x17)->head = TO_FPTR(&E__fW$__fR$__fJhc_List_387__f);\n"
"                    ((struct sFW$__fR$__fJhc_List_387__f*)x17)->a1 = v194508206;\n"
"                    ((struct sFW$__fR$__fJhc_List_387__f*)x17)->a2 = v306;\n"
"                    sptr_t v131889104 = MKLAZY(x17);\n"
"                    {   gc_frame0(gc,1,v131889104); // withRoots(ni131889104)\n"
"                        wptr_t x18 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // dstore (CJhc.Prim.Prim.: ni304 ni131889104)\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x18)->a1 = v304;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x18)->a2 = v131889104;\n"
"                        return x18;\n"
"                    }\n"
"                }\n"
"            }\n"
"        } else { // 1 ->\n"
"            /* 1 */\n"
"            assert(1 == v100024);\n"
"            return SET_RAW_TAG(CJhc_Prim_Prim_$BE); // return []\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:762
msgid "これも今までのパターンと同じでゲソ。もはや楽勝でゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:764
msgid "### 11. Func: ftheMain :: () -> ()"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:806
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- Grin --\n"
"ftheMain :: () -> ()\n"
"ftheMain  = do\n"
"  nd163 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"  ni856819231 <- demote nd163\n"
"  withRoots(ni856819231)\n"
"    nd168 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"    ni220263216 <- demote nd168\n"
"    overwrite ni856819231 (CJhc.Prim.Prim.: &(CJhc.Type.Word.Int 1) ni220263216)\n"
"    withRoots(ni220263216)\n"
"      ni144627460 <- istore (FR@.fJhc.Basics.zipWith ?::I ?::I)\n"
"      overwrite ni144627460 (FR@.fJhc.Basics.zipWith ni856819231 ni220263216)\n"
"      overwrite ni220263216 (CJhc.Prim.Prim.: &(CJhc.Type.Word.Int 1) ni144627460)\n"
"      nd100014 <- fW@.fR@.fJhc.List.387_f 40 ni856819231\n"
"      ni78 <- case nd100014 of\n"
"        (CJhc.Prim.Prim.: ni129 ni32) -> withRoots(ni32,ni129)\n"
"          ni194635134 <- istore (FR@.fJhc.Show.11_showl ni32 [])\n"
"          withRoots(ni194635134)\n"
"            ni196335306 <- istore (FJhc.Show.shows ni129 ni194635134)\n"
"            withRoots(ni196335306)\n"
"              nd84 <- dstore (CJhc.Prim.Prim.: &(CJhc.Type.Basic.Char 91) ni196335306)\n"
"              demote nd84\n"
"        [] -> return ni-930757141\n"
"      nd100016 <- eval ni78\n"
"      ni81465164 <- demote nd100016\n"
"      nd0 <- let\n"
"          fJhc.Monad.72_go ni10 = do\n"
"            nd100020 <- eval ni10\n"
"            case nd100020 of\n"
"              (CJhc.Prim.Prim.: ni12 ni260952206) -> withRoots(ni260952206)\n"
"                nd100022 <- eval ni12\n"
"                (CJhc.Type.Basic.Char w216085086) <- return nd100022\n"
"                w249143450 <- (bits32)ConvOp B2B bits32 w216085086\n"
"                (void)jhc_utf8_putchar(int) w249143450\n"
"                fJhc.Monad.72_go ni260952206\n"
"              [] -> return (CJhc.Prim.Prim.())\n"
"       in\n"
"        fJhc.Monad.72_go ni81465164\n"
"      (void)jhc_utf8_putchar(int) 10\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:895
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* C言語 */\n"
"static void A_STD\n"
"ftheMain(gc_t gc)\n"
"{\n"
"        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // nd163 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"        wptr_t v163 = x19; // なんで置き換えた？？？\n"
"        sptr_t v856819231 = demote(v163); // ni856819231 <- demote nd163\n"
"        {   gc_frame0(gc,1,v856819231); // withRoots(ni856819231)\n"
"            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // nd168 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"            wptr_t v168 = x20;\n"
"            sptr_t v220263216 = demote(v168); // ni220263216 <- demote nd168\n"
"            ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))->a1 = c3; // overwrite ni856819231 (CJhc.Prim.Prim.: &(CJhc.Type.Word.Int 1) ni220263216)\n"
"            ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))->a2 = v220263216;\n"
"            {   sptr_t v10;\n"
"                wptr_t v100014;\n"
"                sptr_t v78;\n"
"                gc_frame0(gc,1,v220263216); // withRoots(ni220263216)\n"
"                sptr_t x21 = s_alloc(gc,cFR$__fJhc_Basics_zipWith); // ni144627460 <- istore (FR@.fJhc.Basics.zipWith ?::I ?::I)\n"
"                ((struct sFR$__fJhc_Basics_zipWith*)x21)->head = TO_FPTR(&E__fR$__fJhc_Basics_zipWith);\n"
"                sptr_t v144627460 = MKLAZY(x21);\n"
"                ((struct sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))->head = TO_FPTR(&E__fR$__fJhc_Basics_zipWith); // overwrite ni144627460 (FR@.fJhc.Basics.zipWith ni856819231 ni220263216)\n"
"                ((struct sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))->a1 = v856819231;\n"
"                ((struct sFR$__fJhc_Basics_zipWith*)FROM_SPTR(v144627460))->a2 = v220263216;\n"
"                ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))->a1 = c3; // overwrite ni220263216 (CJhc.Prim.Prim.: &(CJhc.Type.Word.Int 1) ni144627460)\n"
"                ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v220263216))->a2 = v144627460;\n"
"                v100014 = fW$__fR$__fJhc_List_387__f(gc,40,v856819231); // nd100014 <- fW@.fR@.fJhc.List.387_f 40 ni856819231\n"
"                if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100014) { // ni78 <- case nd100014 of [] ->\n"
"                    v78 = g930757141; // return ni-930757141\n"
"                } else { // (CJhc.Prim.Prim.: ni129 ni32) ->\n"
"                    sptr_t v129;\n"
"                    sptr_t v32;\n"
"                    /* (\"CJhc.Prim.Prim.:\" ni129 ni32) パターンマッチ */\n"
"                    v129 = ((struct sCJhc_Prim_Prim_$x3a*)v100014)->a1;\n"
"                    v32 = ((struct sCJhc_Prim_Prim_$x3a*)v100014)->a2;\n"
"                    {   gc_frame0(gc,2,v32,v129); // withRoots(ni32,ni129)\n"
"                        sptr_t x22 = s_alloc(gc,cFR$__fJhc_Show_11__showl); // ni194635134 <- istore (FR@.fJhc.Show.11_showl ni32 [])\n"
"                        ((struct sFR$__fJhc_Show_11__showl*)x22)->head = TO_FPTR(&E__fR$__fJhc_Show_11__showl);\n"
"                        ((struct sFR$__fJhc_Show_11__showl*)x22)->a1 = v32;\n"
"                        ((struct sFR$__fJhc_Show_11__showl*)x22)->a2 = SET_RAW_TAG(CJhc_Prim_Prim_$BE);\n"
"                        sptr_t v194635134 = MKLAZY(x22);\n"
"                        {   gc_frame0(gc,1,v194635134); // withRoots(ni194635134)\n"
"                            sptr_t x23 = s_alloc(gc,cFJhc_Show_shows); // ni196335306 <- istore (FJhc.Show.shows ni129 ni194635134)\n"
"                            ((struct sFJhc_Show_shows*)x23)->head = TO_FPTR(&E__fJhc_Show_shows);\n"
"                            ((struct sFJhc_Show_shows*)x23)->a1 = v129;\n"
"                            ((struct sFJhc_Show_shows*)x23)->a2 = v194635134;\n"
"                            sptr_t v196335306 = MKLAZY(x23);\n"
"                            {   gc_frame0(gc,1,v196335306); // withRoots(ni196335306)\n"
"                                wptr_t x24 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // nd84 <- dstore (CJhc.Prim.Prim.: &(CJhc.Type.Basic.Char 91) ni196335306)\n"
"                                ((struct sCJhc_Prim_Prim_$x3a*)x24)->a1 = ((sptr_t)RAW_SET_UF('['));\n"
"                                ((struct sCJhc_Prim_Prim_$x3a*)x24)->a2 = v196335306;\n"
"                                wptr_t v84 = x24;\n"
"                                v78 = demote(v84); // demote nd84\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                }\n"
"                wptr_t v100016 = eval(gc,v78); // nd100016 <- eval ni78\n"
"                sptr_t v81465164 = demote(v100016); // ni81465164 <- demote nd100016\n"
"                v10 = v81465164; // in fJhc.Monad.72_go ni81465164\n"
"                fJhc_Monad_72__go__25:; // let fJhc.Monad.72_go ni10 = do\n"
"                {   wptr_t v100020 = eval(gc,v10); // nd100020 <- eval ni10\n"
"                    if (SET_RAW_TAG(CJhc_Prim_Prim_$BE) == v100020) { // case nd100020 of [] ->\n"
"                        SET_RAW_TAG(CJhc_Prim_Prim_$LR); // return (CJhc.Prim.Prim.())\n"
"                    } else { // (CJhc.Prim.Prim.: ni12 ni260952206) ->\n"
"                        sptr_t v12;\n"
"                        sptr_t v260952206;\n"
"                        /* (\"CJhc.Prim.Prim.:\" ni12 ni260952206) パターンマッチ */\n"
"                        v12 = ((struct sCJhc_Prim_Prim_$x3a*)v100020)->a1;\n"
"                        v260952206 = ((struct sCJhc_Prim_Prim_$x3a*)v100020)->a2;\n"
"                        {   uint32_t v216085086;\n"
"                            gc_frame0(gc,1,v260952206); // withRoots(ni260952206)\n"
"                            wptr_t v100022 = eval(gc,v12); // nd100022 <- eval ni12\n"
"                            v216085086 = ((uint32_t)RAW_GET_UF(v100022)); // (CJhc.Type.Basic.Char w216085086) <- return nd100022\n"
"                            uint32_t v249143450 = v216085086; // w249143450 <- (bits32)ConvOp B2B bits32 w216085086\n"
"                            saved_gc = gc; // なにこれ？\n"
"                            (void)jhc_utf8_putchar((int)v249143450); // (void)jhc_utf8_putchar(int) w249143450\n"
"                            v10 = v260952206; // fJhc.Monad.72_go ni260952206\n"
"                            goto fJhc_Monad_72__go__25;\n"
"                        }\n"
"                    }\n"
"                }\n"
"                saved_gc = gc; // なにこれ？\n"
"                return (void)jhc_utf8_putchar((int)10); // (void)jhc_utf8_putchar(int) 10\n"
"            }\n"
"        }\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:899
msgid ""
"overwriteという不吉なキーワードはなんでゲソ？ \"overwrite ni856819231 (CJhc."
"Prim.Prim.: &(CJhc.Type.Word.Int 1) ni220263216)\"に着目すると、 元のコード"
"は..."
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:908
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"  nd163 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"  ni856819231 <- demote nd163 // 一度目の束縛\n"
"  withRoots(ni856819231)\n"
"    nd168 <- dstore (CJhc.Prim.Prim.: ?::I ?::I)\n"
"    ni220263216 <- demote nd168\n"
"    overwrite ni856819231 (CJhc.Prim.Prim.: &(CJhc.Type.Word.Int 1) ni220263216) // 二度目の束縛\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:910
msgid "これがC言語に変換されると..."
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:922
#, no-wrap
msgid ""
"~~~ {.c}\n"
"        wptr_t x19 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // スマートポインタを埋めずallocだけ\n"
"        wptr_t v163 = x19;\n"
"        sptr_t v856819231 = demote(v163); // 一度目のスマートポインタ代入\n"
"        {   gc_frame0(gc,1,v856819231);\n"
"            wptr_t x20 = s_alloc(gc,cCJhc_Prim_Prim_$x3a); // a2に入れるスマートポインタをalloc\n"
"            wptr_t v168 = x20;\n"
"            sptr_t v220263216 = demote(v168);\n"
"            ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))->a1 = c3; // alloc済みスマートポインタに代入\n"
"            ((struct sCJhc_Prim_Prim_$x3a*)FROM_SPTR(v856819231))->a2 = v220263216;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:927
msgid ""
"ということはoverwriteキーワードはdstoreなどと異なりヒープ領域を確保せず、 第"
"一引数で指定されたスマートポインタを上書きすると考えられるじゃなイカ。 なんと"
"なく上記の例ではoverwriteを使わず一回のdstoreにしてしまっても問題なさそうでゲ"
"ソが、 コンストラクタと初期化を分割したり、再帰の中で次々に値を更新して結果を"
"得たい場合などに重宝しそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:931
msgid ""
"もう一つ気になるのは\"saved_gc = gc\"でゲソ。Grinにはなかった行がC言語にいき"
"なり現われるでゲソ...  saved_gcはb__main関数から第一引数として取り回されるの"
"で、 同じものだと思っていたでゲソ。ここはよくわからなかったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:938
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void \n"
"_amain(void)\n"
"{\n"
"        return (void)b__main(saved_gc);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:947
msgid "### Grin由来ではないC言語コード"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:951
msgid ""
"さて。Grinの関数がC言語にどう変換されたか見てきたでゲソ。 でも、とりこぼした"
"要素はないか気にならなイカ？ チェックでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:961
#, no-wrap
msgid ""
"~~~ {.c}\n"
"enum {\n"
"    CJhc_Prim_Prim_$BE = 1,\n"
"    CJhc_Prim_Prim_$LR = 0,\n"
"    CJhc_Prim_Prim_$x3a = 0,\n"
"    CJhc_Type_Basic_Char = 0,\n"
"    CJhc_Type_Word_Int = 0\n"
"};\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:964
msgid ""
"このenumは有意に使われるのは CJhc_Prim_Prim_$BE だけで、 残りは全く使われてい"
"ないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:970
msgid ""
"CJhc_Prim_Prim_$BE はこれまで見た通り、 リストの終端である [] を表わしていた"
"でゲソ。 どこからでも参照され、中身のない要素はこのようにenumで表わされるよう"
"でゲソ。 ...しかし16bitしか幅がないので、場合によっては足りなく...  ってそん"
"なにNilみたいな要素をばかすか作りっこないでゲッソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:980
#, no-wrap
msgid ""
"struct sCJhc_Type_Word_Int {\n"
"    uint32_t a1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:986
#, no-wrap
msgid ""
"struct sFJhc_Show_shows {\n"
"    fptr_t head;\n"
"    sptr_t a1;\n"
"    sptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:992
#, no-wrap
msgid ""
"struct sFR$__fJhc_Basics_$pp {\n"
"    fptr_t head;\n"
"    sptr_t a1;\n"
"    wptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:998
#, no-wrap
msgid ""
"struct sFR$__fJhc_Basics_zipWith {\n"
"    fptr_t head;\n"
"    sptr_t a1;\n"
"    sptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1004
#, no-wrap
msgid ""
"struct sFR$__fJhc_Show_11__showl {\n"
"    fptr_t head;\n"
"    sptr_t a1;\n"
"    wptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1010
#, no-wrap
msgid ""
"struct sFW$__fJhc_Inst_Show_showWord {\n"
"    fptr_t head;\n"
"    sptr_t a2;\n"
"    uint32_t a1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1016
#, no-wrap
msgid ""
"struct sFW$__fR$__fJhc_List_387__f {\n"
"    fptr_t head;\n"
"    sptr_t a2;\n"
"    uint32_t a1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1022
#, no-wrap
msgid ""
"struct sFtheMain$d2 {\n"
"    fptr_t head;\n"
"    sptr_t a1;\n"
"    sptr_t a2;\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1027
#, no-wrap
msgid ""
"struct sFtheMain$d3 {\n"
"    fptr_t head;\n"
"};\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1032
msgid ""
"これらのstructはこれまで見てきた通り、ヒープに確保される要素群でゲソ。 特に"
"structの先頭メンバーがfptr_tになっているstructはサンクでゲソ。 structのメン"
"バーを見ればサンクかどうか分かるのは fptr_tを特別なスマートポインタとして扱っ"
"ている恩恵でゲッソー。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1048
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void \n"
"jhc_hs_init(void)\n"
"{\n"
"        find_cache(&cCJhc_Prim_Prim_$x3a,arena,TO_BLOCKS(sizeof(struct sCJhc_Prim_Prim_$x3a)),2);\n"
"        find_cache(&cCJhc_Type_Word_Int,arena,TO_BLOCKS(sizeof(struct sCJhc_Type_Word_Int)),0);\n"
"        find_cache(&cFW$__fR$__fJhc_List_387__f,arena,TO_BLOCKS(sizeof(struct sFW$__fR$__fJhc_List_387__f)),2);\n"
"        find_cache(&cFR$__fJhc_Basics_zipWith,arena,TO_BLOCKS(sizeof(struct sFR$__fJhc_Basics_zipWith)),3);\n"
"        find_cache(&cFR$__fJhc_Basics_$pp,arena,TO_BLOCKS(sizeof(struct sFR$__fJhc_Basics_$pp)),3);\n"
"        find_cache(&cFtheMain$d2,arena,TO_BLOCKS(sizeof(struct sFtheMain$d2)),3);\n"
"        find_cache(&cFR$__fJhc_Show_11__showl,arena,TO_BLOCKS(sizeof(struct sFR$__fJhc_Show_11__showl)),3);\n"
"        find_cache(&cFJhc_Show_shows,arena,TO_BLOCKS(sizeof(struct sFJhc_Show_shows)),3);\n"
"        find_cache(&cFW$__fJhc_Inst_Show_showWord,arena,TO_BLOCKS(sizeof(struct sFW$__fJhc_Inst_Show_showWord)),2);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1050
msgid ""
"このjhc_hs_init関数はHaskellのRTSを初期化するお約束のhs_init関数から呼び出さ"
"れるようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1059
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void\n"
"hs_init(int *argc, char **argv[])\n"
"{\n"
"        if(!hs_init_count++) {\n"
"                jhc_alloc_init();\n"
"                jhc_hs_init();\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1061
msgid "find_cache関数とは何者なのでゲソ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1080
#, no-wrap
msgid ""
"~~~ {.c}\n"
"struct s_cache *\n"
"find_cache(struct s_cache **rsc, struct s_arena *arena,\n"
"           unsigned short size, unsigned short num_ptrs)\n"
"{\n"
"        if(__predict_true(rsc && *rsc))\n"
"                return *rsc;\n"
"        struct s_cache *sc = SLIST_FIRST(&arena->caches);\n"
"        for(;sc;sc = SLIST_NEXT(sc,next)) {\n"
"                if(sc->size == size && sc->num_ptrs == num_ptrs)\n"
"                        goto found;\n"
"        }\n"
"        sc = new_cache(arena,size,num_ptrs);\n"
"found:\n"
"        if(rsc)\n"
"                *rsc = sc;\n"
"        return sc;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1100
#, no-wrap
msgid ""
"struct s_cache *\n"
"new_cache(struct s_arena *arena, unsigned short size, unsigned short num_ptrs)\n"
"{\n"
"        struct s_cache *sc = malloc(sizeof(*sc));\n"
"        memset(sc,0,sizeof(*sc));\n"
"        sc->arena = arena;\n"
"        sc->size = size;\n"
"        sc->num_ptrs = num_ptrs;\n"
"        sc->flags = 0;\n"
"        size_t excess = BLOCK_SIZE - sizeof(struct s_block);\n"
"        sc->num_entries = (8*excess) / (8*sizeof(uintptr_t)*size + 1) - 1;\n"
"        sc->color = (sizeof(struct s_block) + BITARRAY_SIZE_IN_BYTES(sc->num_entries) +\n"
"                        sizeof(uintptr_t) - 1) / sizeof(uintptr_t);\n"
"        SLIST_INIT(&sc->blocks);\n"
"        SLIST_INIT(&sc->full_blocks);\n"
"        SLIST_INSERT_HEAD(&arena->caches,sc,next);\n"
"        return sc;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1109
msgid ""
"struct s_arenaのcachesメンバーには、 サイズとポインタの数で種類分けされた"
"cacheと呼ばれるエントリが列になっているでゲソ。 find_cache関数の第三引数はサ"
"イズ、第四引数はポインタの数で、 呼び元が欲しいcacheが既にcachesメンバーに確"
"保されているのかチェックするのがfind_cache関数のでゲソ。 もし対応するエントリ"
"がcachesに入ってなかった場合、 find_cache関数はnew_cache関数を呼び出して新し"
"いエントリを確保するんじゃなイカ。 ...でもこのcachesメンバーはコンパイル時に"
"静的に確保してしまうこともできそうなもんでゲソ。 ここらへんは改善できそうでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1121
#, no-wrap
msgid ""
"~~~ {.c}\n"
"static wptr_t A_STD A_FALIGNED\n"
"E__fJhc_Show_shows(gc_t gc,struct sFJhc_Show_shows* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fJhc_Show_shows(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1132
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__fR$__fJhc_Basics_$pp(gc_t gc,struct sFR$__fJhc_Basics_$pp* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fR$__fJhc_Basics_$pp(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1143
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__fR$__fJhc_Basics_zipWith(gc_t gc,struct sFR$__fJhc_Basics_zipWith* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fR$__fJhc_Basics_zipWith(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1154
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__fR$__fJhc_Show_11__showl(gc_t gc,struct sFR$__fJhc_Show_11__showl* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fR$__fJhc_Show_11__showl(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1165
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__fW$__fJhc_Inst_Show_showWord(gc_t gc,struct sFW$__fJhc_Inst_Show_showWord* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fW$__fJhc_Inst_Show_showWord(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1176
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__fW$__fR$__fJhc_List_387__f(gc_t gc,struct sFW$__fR$__fJhc_List_387__f* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = fW$__fR$__fJhc_List_387__f(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1187
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__ftheMain$d2(gc_t gc,struct sFtheMain$d2* arg)\n"
"{\n"
"        {   wptr_t r;\n"
"            gc_frame0(gc,1,MKLAZY(arg));\n"
"            r = ftheMain$d2(gc,arg->a1,arg->a2);\n"
"            update(arg,r);\n"
"            return r;\n"
"        }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1198
#, no-wrap
msgid ""
"static wptr_t A_STD A_FALIGNED\n"
"E__ftheMain$d3(gc_t gc,struct sFtheMain$d3* arg)\n"
"{\n"
"        wptr_t r;\n"
"        r = ftheMain$d3(gc);\n"
"        update(arg,r);\n"
"        gc_add_root(gc,(sptr_t)r);\n"
"        return r;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1200
msgid "この\"E__f\"で始まる関数群はほぼ同じことをしているでゲソ。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-05-16-jhc_grin_to_c.md:1205
msgid "gc_frame0(gc,1,MKLAZY(arg));"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-05-16-jhc_grin_to_c.md:1205
msgid "関数名から\"E__f\"プレフィックスを除いた関数を呼び出す"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-05-16-jhc_grin_to_c.md:1205
msgid "update(arg,r);"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-05-16-jhc_grin_to_c.md:1205
msgid "return r;"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1208
msgid ""
"まず最初のgc_frame0はイカのようなマクロで、 引数argはポインタで、lazy "
"locationフラグを立ててGCルートに追加するでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1216
#, no-wrap
msgid ""
"~~~ {.c}\n"
"#define TO_SPTR(t,x)   (typeof (x))((uintptr_t)(x) | (t))\n"
"#define MKLAZY(fn)    TO_SPTR(P_LAZY,(sptr_t)fn)\n"
"#define gc_frame0(gc,n,...) void *ptrs[n] = { __VA_ARGS__ }; \\\n"
"        for(int i = 0; i < n; i++) gc[i] = (sptr_t)ptrs[i]; \\\n"
"        gc_t sgc = gc;  gc_t gc = sgc + n;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1220
msgid ""
"update関数は\"E__f\"プレフィックスを除いた関数の返値でargのhead、 つまり"
"fptr_tを上書きするでゲソ。 これは未評価サンクの評価を行なっているんじゃなイ"
"カ？"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1230
#, no-wrap
msgid ""
"~~~ {.c}\n"
"typedef struct node {\n"
"        fptr_t head;\n"
"        sptr_t rest[];\n"
"} A_MAYALIAS node_t;\n"
"#define NODEP(x)     ((node_t *)(x))\n"
"#define GETHEAD(x)   (NODEP(x)->head)\n"
"inline static void update(void *t, wptr_t n) { GETHEAD(t) = (fptr_t)n; }\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1233
msgid ""
"もう一度、\"1. Caf: v-930757141\"を振り替えってみるでゲソ。 詳細に図を描いて"
"みたら未評価サンクが評価される動作がはっきり解ったじゃなイカ!"
msgstr ""

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1235
#, fuzzy
#| msgid "![](/draw/2013-01-09-sequence_diagram.png)"
msgid "![](/draw/2013-02-14-jhc_grin_to_c_E__f.png)"
msgstr "![](/draw/2013-01-09-sequence_diagram.png)"

#. type: Plain text
#: posts/2013-05-16-jhc_grin_to_c.md:1237
msgid ""
"うん。なんとなくGrin=>Cがどんな変換なのかイメージがつかめたでゲソ。 次は例に"
"よる理解ではなく、jhcのソースコードそのものを理解することもできるんじゃなイ"
"カ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:5
#, no-wrap
msgid ""
"title: (作成中) Implement MVar.\n"
"description: MVarを実装してスレッド同士仲良くしたいでゲソ!\n"
"tags: jhc, ajhc, thread, mvar\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:12
msgid ""
"forkOSを作ったは良いけれど、このままだとスレッド間通信できないでゲソ。 STMを"
"いきなり作りたいところでゲソが、まずはMVarを作らなイカ？ とりあえず [チケッ"
"ト](https://github.com/ajhc/ajhc/issues/25)  は切ったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:14
msgid "## GHCの実装を解析するでゲソ"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:16
msgid "### Haskell層"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:22
msgid ""
"haddockの [Control.Concurrent.MVar](http://hackage.haskell.org/packages/"
"archive/base/latest/doc/html/Control-Concurrent-MVar.html)  から読みはじめよ"
"うと思うでゲッソ。 GHCのソースコードだとMVarはghc/libraries/base/GHC/MVar.hs"
"で定義されているでゲソ。 まずカラッポのMVarを作ってみようじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:26
msgid ""
"~~~ {.haskell} -- File: ghc/libraries/base/GHC/MVar.hs data MVar a = MVar "
"(MVar# RealWorld a)"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:31
#, no-wrap
msgid ""
"newEmptyMVar  :: IO (MVar a)\n"
"newEmptyMVar = IO $ \\ s# ->\n"
"    case newMVar# s# of\n"
"         (# s2#, svar# #) -> (# s2#, MVar svar# #)\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:35
msgid ""
"-- File: ghc/libraries/ghc-prim/GHC/Types.hs newtype IO a = IO (State# "
"RealWorld -> (# State# RealWorld, a #))  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:37
msgid "このパターンはAjhcの中でも見かけたでゲソ。UIOじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:44
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/lib/haskell-extras/Foreign/StablePtr.hs\n"
"newStablePtr :: a -> IO (StablePtr a)\n"
"newStablePtr x = do\n"
"    fromUIO $ \\w -> case c_newStablePtr (toBang_ x) w of\n"
"        (# w', s #) -> (# w', fromBang_ s #)\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:48
msgid ""
"-- File: ajhc/lib/jhc/Jhc/IO.hs fromUIO :: UIO a -> IO a fromUIO x = IO (ST "
"x)"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:57
msgid ""
"-- File: ajhc/lib/jhc-prim/Jhc/Prim/IO.hs data State_ :: * -> # data "
"RealWorld :: * type UST s a = State_ s -> (# State_ s, a #)  type UIO a = "
"UST RealWorld a newtype ST s a = ST (UST s a)  newtype IO a = IO (ST "
"RealWorld a)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:59
msgid ""
"無事MVarが得られたので、なにか入れてみようと思うでゲソ。つまりputMVarを使うで"
"ゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:66
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"putMVar  :: MVar a -> a -> IO ()\n"
"putMVar (MVar mvar#) x = IO $ \\ s# ->\n"
"    case putMVar# mvar# x s# of\n"
"        s2# -> (# s2#, () #)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:68
msgid "やはりIOをほどいてプリミティブ関数に内容物をほおりこむでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:70
msgid "最後にMVarから内容物を取り出してみるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:75
msgid ""
"~~~ {.haskell} takeMVar :: MVar a -> IO a takeMVar (MVar mvar#) = IO $ \\ s# "
"-> takeMVar# mvar# s# ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:77
msgid "### cmm層"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:80
msgid ""
"newMVar\\#プリミティブはどーなっているでゲソ？ と、これは単にmvarを初期化して"
"いるだかのようでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:87
#, no-wrap
msgid ""
"~~~ {.c}\n"
"// File: ghc/rts/PrimOps.cmm\n"
"stg_newMVarzh\n"
"{\n"
"    /* args: none */\n"
"    W_ mvar;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:89
#, no-wrap
msgid "    ALLOC_PRIM ( SIZEOF_StgMVar, NO_PTRS, stg_newMVarzh );\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:98
#, no-wrap
msgid ""
"    mvar = Hp - SIZEOF_StgMVar + WDS(1);\n"
"    SET_HDR(mvar,stg_MVAR_DIRTY_info,CCCS);\n"
"        // MVARs start dirty: generation 0 has no mutable list\n"
"    StgMVar_head(mvar)  = stg_END_TSO_QUEUE_closure;\n"
"    StgMVar_tail(mvar)  = stg_END_TSO_QUEUE_closure;\n"
"    StgMVar_value(mvar) = stg_END_TSO_QUEUE_closure;\n"
"    RET_P(mvar);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:102
#, no-wrap
msgid ""
"// File: ghc/rts/StgMiscClosures.cmm\n"
"/* ----------------------------------------------------------------------------\n"
"   END_TSO_QUEUE\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:106
#, no-wrap
msgid ""
"   This is a static nullary constructor (like []) that we use to mark the\n"
"   end of a linked TSO queue.\n"
"   ------------------------------------------------------------------------- */\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:109
msgid ""
"INFO_TABLE_CONSTR(stg_END_TSO_QUEUE,0,0,0,CONSTR_NOCAF_STATIC,\"END_TSO_QUEUE"
"\",\"END_TSO_QUEUE\")  { foreign \"C\" barf(\"END_TSO_QUEUE object entered!"
"\") never returns; }"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:112
msgid "CLOSURE(stg_END_TSO_QUEUE_closure,stg_END_TSO_QUEUE); ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:115
msgid ""
"またputMVar\\#というプリミティブも使っていたでゲソ。 さー長いソースコードでゲ"
"ソ。気合いで読もうじゃなイカー。"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:121
#, no-wrap
msgid ""
"~~~ {.c}\n"
"// File: ghc/rts/PrimOps.cmm\n"
"stg_putMVarzh\n"
"{\n"
"    W_ mvar, val, info, tso, q;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:125
#, no-wrap
msgid ""
"    /* args: R1 = MVar, R2 = value */\n"
"    mvar = R1;\n"
"    val  = R2;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:131
#, no-wrap
msgid ""
"#if defined(THREADED_RTS)\n"
"    (\"ptr\" info) = foreign \"C\" lockClosure(mvar \"ptr\") [];\n"
"#else\n"
"    info = GET_INFO(mvar);\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:135
#, no-wrap
msgid ""
"    if (info == stg_MVAR_CLEAN_info) {\n"
"        foreign \"C\" dirty_MVAR(BaseReg \"ptr\", mvar \"ptr\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:137
#, no-wrap
msgid "    if (StgMVar_value(mvar) != stg_END_TSO_QUEUE_closure) {\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:142
#, no-wrap
msgid ""
"        // see Note [mvar-heap-check] above\n"
"        HP_CHK_GEN_TICKY(SIZEOF_StgMVarTSOQueue, R1_PTR & R2_PTR, stg_putMVarzh);\n"
"        TICK_ALLOC_PRIM(SIZEOF_StgMVarTSOQueue, 0, 0);\n"
"        CCCS_ALLOC(SIZEOF_StgMVarTSOQueue);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:144
#, no-wrap
msgid "        q = Hp - SIZEOF_StgMVarTSOQueue + WDS(1);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:148
#, no-wrap
msgid ""
"        SET_HDR(q, stg_MVAR_TSO_QUEUE_info, CCS_SYSTEM);\n"
"        StgMVarTSOQueue_link(q) = END_TSO_QUEUE;\n"
"        StgMVarTSOQueue_tso(q)  = CurrentTSO;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:160
#, no-wrap
msgid ""
"\tif (StgMVar_head(mvar) == stg_END_TSO_QUEUE_closure) {\n"
"\t    StgMVar_head(mvar) = q;\n"
"\t} else {\n"
"            StgMVarTSOQueue_link(StgMVar_tail(mvar)) = q;\n"
"            foreign \"C\" recordClosureMutated(MyCapability() \"ptr\",\n"
"                                             StgMVar_tail(mvar)) [];\n"
"\t}\n"
"\tStgTSO__link(CurrentTSO)       = q;\n"
"\tStgTSO_block_info(CurrentTSO)  = mvar;\n"
"\tStgTSO_why_blocked(CurrentTSO) = BlockedOnMVar::I16;\n"
"\tStgMVar_tail(mvar)             = q;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:165
#, no-wrap
msgid ""
"        R1 = mvar;\n"
"        R2 = val;\n"
"\tjump stg_block_putmvar;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:179
#, no-wrap
msgid ""
"    q = StgMVar_head(mvar);\n"
"loop:\n"
"    if (q == stg_END_TSO_QUEUE_closure) {\n"
"\t/* No further takes, the MVar is now full. */\n"
"\tStgMVar_value(mvar) = val;\n"
"    \tunlockClosure(mvar, stg_MVAR_DIRTY_info);\n"
"\tjump %ENTRY_CODE(Sp(0));\n"
"    }\n"
"    if (StgHeader_info(q) == stg_IND_info ||\n"
"        StgHeader_info(q) == stg_MSG_NULL_info) {\n"
"        q = StgInd_indirectee(q);\n"
"        goto loop;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:181
#, no-wrap
msgid "    // There are takeMVar(s) waiting: wake up the first one\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:187
#, no-wrap
msgid ""
"    tso = StgMVarTSOQueue_tso(q);\n"
"    StgMVar_head(mvar) = StgMVarTSOQueue_link(q);\n"
"    if (StgMVar_head(mvar) == stg_END_TSO_QUEUE_closure) {\n"
"        StgMVar_tail(mvar) = stg_END_TSO_QUEUE_closure;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:190
#, no-wrap
msgid ""
"    ASSERT(StgTSO_why_blocked(tso) == BlockedOnMVar::I16);\n"
"    ASSERT(StgTSO_block_info(tso) == mvar);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:195
#, no-wrap
msgid ""
"    // actually perform the takeMVar\n"
"    W_ stack;\n"
"    stack = StgTSO_stackobj(tso);\n"
"    PerformTake(stack, val);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:198
#, no-wrap
msgid ""
"    // indicate that the MVar operation has now completed.\n"
"    StgTSO__link(tso) = stg_END_TSO_QUEUE_closure;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:202
#, no-wrap
msgid ""
"    if (TO_W_(StgStack_dirty(stack)) == 0) {\n"
"        foreign \"C\" dirty_STACK(MyCapability() \"ptr\", stack \"ptr\") [];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:204
#, no-wrap
msgid "    foreign \"C\" tryWakeupThread(MyCapability() \"ptr\", tso) [];\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:208
#, no-wrap
msgid ""
"    unlockClosure(mvar, stg_MVAR_DIRTY_info);\n"
"    jump %ENTRY_CODE(Sp(0));\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:214
#, no-wrap
msgid ""
"#define PerformTake(stack, value)               \\\n"
"    W_ sp;                                      \\\n"
"    sp = StgStack_sp(stack);                    \\\n"
"    W_[sp + WDS(1)] = value;                    \\\n"
"    W_[sp + WDS(0)] = stg_gc_unpt_r1_info;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:228
#, no-wrap
msgid ""
"// File: ghc/includes/rts/storage/SMPClosureOps.h\n"
"EXTERN_INLINE StgInfoTable *lockClosure(StgClosure *p)\n"
"{\n"
"    StgWord info;\n"
"    do {\n"
"\tnat i = 0;\n"
"\tdo {\n"
"\t    info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);\n"
"\t    if (info != (W_)&stg_WHITEHOLE_info) return (StgInfoTable *)info;\n"
"\t} while (++i < SPIN_COUNT);\n"
"\tyieldThread();\n"
"    } while (1);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:243
#, no-wrap
msgid ""
"// File: ghc/rts/sm/Storage.c\n"
"/*\n"
"   This is the write barrier for MVARs.  An MVAR_CLEAN objects is not\n"
"   on the mutable list; a MVAR_DIRTY is.  When written to, a\n"
"   MVAR_CLEAN turns into a MVAR_DIRTY and is put on the mutable list.\n"
"   The check for MVAR_CLEAN is inlined at the call site for speed,\n"
"   this really does make a difference on concurrency-heavy benchmarks\n"
"   such as Chaneneos and cheap-concurrency.\n"
"*/\n"
"void\n"
"dirty_MVAR(StgRegTable *reg, StgClosure *p)\n"
"{\n"
"    recordClosureMutated(regTableToCapability(reg),p);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:249
#, no-wrap
msgid ""
"// File: ghc/rts/Capability.h\n"
"EXTERN_INLINE void\n"
"recordMutableCap (StgClosure *p, Capability *cap, nat gen)\n"
"{\n"
"    bdescr *bd;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:263
#, no-wrap
msgid ""
"    // We must own this Capability in order to modify its mutable list.\n"
"    //    ASSERT(cap->running_task == myTask());\n"
"    // NO: assertion is violated by performPendingThrowTos()\n"
"    bd = cap->mut_lists[gen];\n"
"    if (bd->free >= bd->start + BLOCK_SIZE_W) {\n"
"\tbdescr *new_bd;\n"
"\tnew_bd = allocBlock_lock();\n"
"\tnew_bd->link = bd;\n"
"\tbd = new_bd;\n"
"\tcap->mut_lists[gen] = bd;\n"
"    }\n"
"    *bd->free++ = (StgWord)p;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:271
#, no-wrap
msgid ""
"EXTERN_INLINE void\n"
"recordClosureMutated (Capability *cap, StgClosure *p)\n"
"{\n"
"    bdescr *bd;\n"
"    bd = Bdescr((StgPtr)p);\n"
"    if (bd->gen_no != 0) recordMutableCap(p,cap,bd->gen_no);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:278
#, no-wrap
msgid ""
"// File: ghc/rts/HeapStackCheck.cmm\n"
"stg_block_putmvar_finally\n"
"{\n"
"    unlockClosure(R3, stg_MVAR_DIRTY_info);\n"
"    jump StgReturn;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:288
#, no-wrap
msgid ""
"stg_block_putmvar\n"
"{\n"
"    Sp_adj(-3);\n"
"    Sp(2) = R2;\n"
"    Sp(1) = R1;\n"
"    Sp(0) = stg_block_putmvar_info;\n"
"    R3 = R1;\n"
"    BLOCK_BUT_FIRST(stg_block_putmvar_finally);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:294
#, no-wrap
msgid ""
"// File: ghc/rts/Threads.c\n"
"void\n"
"tryWakeupThread (Capability *cap, StgTSO *tso)\n"
"{\n"
"    traceEventThreadWakeup (cap, tso, tso->cap->no);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:308
#, no-wrap
msgid ""
"#ifdef THREADED_RTS\n"
"    if (tso->cap != cap)\n"
"    {\n"
"        MessageWakeup *msg;\n"
"        msg = (MessageWakeup *)allocate(cap,sizeofW(MessageWakeup));\n"
"        SET_HDR(msg, &stg_MSG_TRY_WAKEUP_info, CCS_SYSTEM);\n"
"        msg->tso = tso;\n"
"        sendMessage(cap, tso->cap, (Message*)msg);\n"
"        debugTraceCap(DEBUG_sched, cap, \"message: try wakeup thread %ld on cap %d\",\n"
"                      (W_)tso->id, tso->cap->no);\n"
"        return;\n"
"    }\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:320
#, no-wrap
msgid ""
"    switch (tso->why_blocked)\n"
"    {\n"
"    case BlockedOnMVar:\n"
"    {\n"
"        if (tso->_link == END_TSO_QUEUE) {\n"
"            tso->block_info.closure = (StgClosure*)END_TSO_QUEUE;\n"
"            goto unblock;\n"
"        } else {\n"
"            return;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:324
#, no-wrap
msgid ""
"    case BlockedOnMsgThrowTo:\n"
"    {\n"
"        const StgInfoTable *i;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:332
#, no-wrap
msgid ""
"        i = lockClosure(tso->block_info.closure);\n"
"        unlockClosure(tso->block_info.closure, i);\n"
"        if (i != &stg_MSG_NULL_info) {\n"
"            debugTraceCap(DEBUG_sched, cap, \"thread %ld still blocked on throwto (%p)\",\n"
"                          (W_)tso->id, tso->block_info.throwto->header.info);\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:338
#, no-wrap
msgid ""
"        // remove the block frame from the stack\n"
"        ASSERT(tso->stackobj->sp[0] == (StgWord)&stg_block_throwto_info);\n"
"        tso->stackobj->sp += 3;\n"
"        goto unblock;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:343
#, no-wrap
msgid ""
"    case BlockedOnBlackHole:\n"
"    case BlockedOnSTM:\n"
"    case ThreadMigrating:\n"
"        goto unblock;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:348
#, no-wrap
msgid ""
"    default:\n"
"        // otherwise, do nothing\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:354
#, no-wrap
msgid ""
"unblock:\n"
"    // just run the thread now, if the BH is not really available,\n"
"    // we'll block again.\n"
"    tso->why_blocked = NotBlocked;\n"
"    appendToRunQueue(cap,tso);\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:365
#, no-wrap
msgid ""
"    // We used to set the context switch flag here, which would\n"
"    // trigger a context switch a short time in the future (at the end\n"
"    // of the current nursery block).  The idea is that we have just\n"
"    // woken up a thread, so we may need to load-balance and migrate\n"
"    // threads to other CPUs.  On the other hand, setting the context\n"
"    // switch flag here unfairly penalises the current thread by\n"
"    // yielding its time slice too early.\n"
"    //\n"
"    // The synthetic benchmark nofib/smp/chan can be used to show the\n"
"    // difference quite clearly.\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:369
#, no-wrap
msgid ""
"    // cap->context_switch = 1;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:371
msgid "xxx takeMVarについても調べること"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:373
msgid "## 作戦"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:375
msgid "xxx リメンバーセットのGCのためにファイナライザの実装が必要"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:377
#, fuzzy
#| msgid "![](/draw/2012-12-27-loader.png)"
msgid "![](/draw/2013-06-22-remembered_set.png)"
msgstr "![](/draw/2012-12-27-loader.png)"

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:381
msgid "## テスト"
msgstr ""

#. type: Plain text
#: posts/2013-06-21-impl_mvar.md:385
msgid ""
"[testsuite/tests/concurrent/should_run/conc069.hs at master · ghc/testsuite]"
"(https://github.com/ghc/testsuite/blob/master/tests/concurrent/should_run/"
"conc069.hs)  が動けばいいんじゃなイカ？ forkIOはforkOSの別名でとりあえず良し"
"としたいところでゲソ。 というかforkIOと同一視して良いのであればもっと良いテス"
"トがころがっていそうなもんでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:5
#, no-wrap
msgid ""
"title: Metasepi航海日誌はじめるでゲソ\n"
"description: 型推論のある言語を使ってkernelを書くことはできなイカ？\n"
"tags: project\n"
"---\n"
msgstr ""
"title: Start to record Metasepi log book\n"
"description: Can we design real kernel using strong typed language?\n"
"tags: project\n"
"---\n"

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:9
msgid "おまえたち!久し振りでゲソ! ん？覚えてなイカ？"
msgstr "Welcome back, all! Um? Do you forget me?"

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:20
msgid ""
"この航海日誌を見ているということは [Haskell Advent Calendar 2011: 「簡約!? λ"
"カ娘(二期)」とHaskell製OSの紹介](http://d.masterq.net/?date=20111221#p01)  を"
"読んだこともあると思うでゲソ。 この日記ではHaskellで書かれたOS、 [House]"
"(http://programatica.cs.pdx.edu/House/)  を紹介したでゲソ。 ところがこの"
"House、進化が止まっているどころか、Houseの進化版である [Light House](http://"
"web.cecs.pdx.edu/~kennyg/house/)  にいたってはWebページが消えてしまっているで"
"ゲソ。 これは……ただのしかばねのようでゲソ……"
msgstr ""
"If you read this blog, I think you have read [Haskell Advent Calendar 2011:"
"「簡約!? λカ娘(二期)」とHaskell製OSの紹介](http://d.masterq.net/?"
"date=20111221#p01). I introduced Haskell OS named [House](http://"
"programatica.cs.pdx.edu/House/) on the article. However the House stops "
"growing and [Light House](http://web.cecs.pdx.edu/~kennyg/house/) website is "
"down. I think they are dead..."

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:27
msgid ""
"Houseのソースコードはおいおい読むとして、この現状は 「HaskellやOCamlのような"
"型推論を備えた言語を使って実用的なkernelを書くことは不可能」 ということを意味"
"しているのカ？ 否! 根性の問題でゲソ。 ドッグフード可能になるまでプロジェクト"
"を保守する根性が不足しているせいに違いないんでゲソ。"
msgstr ""
"While set reading House source code aside for another day, the fact means "
"\"Strong typed language such like Haskell or OCaml can't design practical "
"real kernel?\" No! I believe it's caused by less guts. Nobody have guts to "
"keep developing the projects to start [dogfooding](http://en.wikipedia.org/"
"wiki/Eating_your_own_dog_food)."

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:31
msgid ""
"そういうわけで、これから型推論を備えた言語を使って実用的なkernelを書くプロ"
"ジェクトをはじめるでゲソ。 このプロジェクトを\"Metasepi\"と呼ぶことにするで"
"ゲッソ。 海っぽくて良い名前でゲソ。"
msgstr ""
"Then, give the name \\\"Metasepi\\\" a project creating practical real "
"kernel using strong typed language. The good name sounds like sea."

#. type: Plain text
#: posts/2012-08-05-start-metasepi.md:32
msgid ""
"しばらくは与太話ばかり書いていると思うでゲソが、そのうち実際に手を動かしはじ"
"めるつもりでゲソ。"
msgstr "I'll write code soon, while the blog says absurd idea today."

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:5
#, no-wrap
msgid ""
"title: 簡約!? λカ娘 Rock!の紹介とHaskell製Androidアプリの解説\n"
"description: NDKでHaskellも動くでゲソー\n"
"tags: haskell, book, android, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:8
msgid "![](http://www.paraiso-lang.org/ikmsm/images/c85-cover-s.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:12
msgid ""
"この記事は [Android Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/"
"advent-calendar/2013/android)  の12/17(火曜)分じゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:18
msgid ""
"だいぶ息切れしてきた関数型プログラミングの本 [簡約!? λカ娘 Rock!](http://www."
"paraiso-lang.org/ikmsm/books/c85.html)  がコミックマーケット85 [3日目 西地区 "
"す-03a](http://twitcmap.jp/?id=0085-3-SUh-03-a)  で出るでゲソ。みんな買ってほ"
"しいでゲソ!"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:21
msgid "第1章 λカ娘探索2?"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:21
msgid "第2章 僕のカノジョはスナッチャー # <= コレ書いた"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:32
msgid ""
"がもくじで、 [\\@master_q](https://twitter.com/master_q)  は第2章を書いたらし"
"いでゲソ。 この記事では [Android NDK](http://developer.android.com/tools/sdk/"
"ndk/index.html)  に付属しているnative-activityサンプルアプリケーションを"
"Haskell化するでゲソ。 当然native-activityはC言語で書かれているので、いきなり"
"全部をHaskell化できないじゃなイカ。 そこで [スナッチ設計](http://www."
"slideshare.net/master_q/20131020-osc-tokyoajhc)  という手法を使って動作可能な"
"まま少しずつHaskellで設計置換していくんでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:36
msgid ""
"記事が気になったら是非 [サンプル版pdf](http://www.paraiso-lang.org/ikmsm/"
"books/c85-sample.pdf)  を読んでみてほしいでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:39
msgid "## Haskellで書いたAndroid NDKアプリってどんな感じ？"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:45
msgid ""
"Android NDKに対するスナッチ設計の詳細は先の同人誌に書いたので、 この記事では"
"Haskellで書いたAndroid NDKアプリの中身を見てみようと思うでゲソ。 題材は"
"Google Playからダウンロードできる [Cube](https://play.google.com/store/apps/"
"details?id=org.metasepi.ajhc.android.cube)  というアプリでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:47
msgid ""
"[![](/img/20131217_haskell_cube.png)](https://play.google.com/store/apps/"
"details?id=org.metasepi.ajhc.android.cube)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:49
msgid ""
"このアプリは単なるOpenGL ESのデモアプリで使い方はイカの動画を見ればすぐわかる"
"と思うでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:55
msgid ""
"このCubeアプリのソースコードは [https://github.com/ajhc/demo-android-ndk/"
"tree/master/cube](https://github.com/ajhc/demo-android-ndk/tree/master/"
"cube)  にあり、以下のようなディレクトリツリーを持っているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:85
#, no-wrap
msgid ""
"~~~\n"
"$ pwd\n"
"/home/kiwamu/src/demo-android-ndk/cube\n"
"$ tree\n"
".\n"
"|-- AndroidManifest.xml\n"
"|-- Makefile\n"
"|-- cube.xcf\n"
"|-- hs_src\n"
"|   |-- CubeVertices.hs\n"
"|   `-- Main.hs\n"
"|-- jni\n"
"|   |-- Android.mk\n"
"|   |-- Application.mk\n"
"|   |-- c_extern.h\n"
"|   |-- dummy4jhc.c\n"
"|   `-- main.c\n"
"`-- res\n"
"    |-- drawable-hdpi\n"
"    |   `-- ic_launcher.png\n"
"    |-- drawable-ldpi\n"
"    |   `-- ic_launcher.png\n"
"    |-- drawable-mdpi\n"
"    |   `-- ic_launcher.png\n"
"    |-- drawable-xhdpi\n"
"    |   `-- ic_launcher.png\n"
"    `-- values\n"
"        `-- strings.xml\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:88
msgid ""
"C言語とHaskellの界面の話題や、ビルド手順は先の同人誌が詳しいでゲソ。 この記事"
"では上記ファイルの内、Haskellで書かれているCubeVertices.hsとMain.hsについて解"
"説するでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:90
msgid "## CubeVertices.hsファイルについて"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:93
msgid ""
"まずこの立方体のデータがどこにあるかでゲソ。 それは簡単でイカのモジュールでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:95
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/"
"CubeVertices.hs](https://github.com/ajhc/demo-android-ndk/blob/master/cube/"
"hs_src/CubeVertices.hs)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:98
msgid "~~~ {.haskell} module CubeVertices where"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:100
msgid "import AndroidNdk"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:125
#, no-wrap
msgid ""
"vertices :: [GLfloat]\n"
"vertices = [\n"
"    -- front\n"
"    -0.5, 0.5, 0.5, \n"
"    -0.5, -0.5, 0.5, \n"
"    0.5, 0.5, 0.5,\n"
"    0.5, 0.5, 0.5, \n"
"    -0.5, -0.5, 0.5, \n"
"    0.5, -0.5, 0.5,\n"
"    -- right\n"
"    0.5, 0.5, 0.5, \n"
"--snip--\n"
"colors :: [GLfloat]\n"
"colors = [\n"
"    -- front\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    0.0625,0.57421875,0.92578125,1.0,\n"
"    -- right\n"
"    0.29296875,0.66796875,0.92578125,1.0,\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:129
msgid ""
"verticesとcolorsという名前のリストが入っているだけでゲソ。 このリストはMain."
"hsで使用されて、それぞれglVertexPointerとglColorPointerに渡されるだけじゃなイ"
"カ。 あとはHaskellじゃなくてOpenGLの知識でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:131
msgid "## glVertexPointerとglColorPointerの呼び出し"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:133
msgid ""
"そのglVertexPointerとglColorPointerはどこから呼び出されるかというとMain.hsの"
"engineDrawFrame関数でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:135
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/Main."
"hs#L80](https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/"
"Main.hs#L80)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:160
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"engineDrawFrame :: AndroidEngine -> IO ()\n"
"engineDrawFrame enghs = do\n"
"  let disp  = engEglDisplay enghs\n"
"      surf  = engEglSurface enghs\n"
"      w     = fromIntegral $ engWidth enghs\n"
"      h     = fromIntegral $ engHeight enghs\n"
"      s     = engState enghs\n"
"      dx    = fromIntegral $ sStateDx s\n"
"      dy    = fromIntegral $ sStateDy s\n"
"      angle = sStateAngle s\n"
"  when (disp /= c_EGL_NO_DISPLAY) $ do\n"
"    c_glClear $ c_GL_COLOR_BUFFER_BIT .|. c_GL_DEPTH_BUFFER_BIT\n"
"    withArray vertices $ \\vp -> withArray colors $ \\cp -> do -- xxx heavy\n"
"      c_glEnableClientState c_GL_VERTEX_ARRAY\n"
"      c_glEnableClientState c_GL_COLOR_ARRAY\n"
"      c_glVertexPointer 3 c_GL_FLOAT 0 vp\n"
"      c_glColorPointer 4 c_GL_FLOAT 0 cp\n"
"      c_glRotatef ((sqrt (dx ** 2 + dy ** 2)) / 10.0) dy dx 0.0\n"
"      c_glDrawArrays c_GL_TRIANGLES 0 36\n"
"      c_glDisableClientState c_GL_VERTEX_ARRAY\n"
"      c_glDisableClientState c_GL_COLOR_ARRAY\n"
"    void $ c_eglSwapBuffers disp surf\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:166
msgid ""
"このコード、前半はAndroidEngine型から現在の状態を引き出しているようじゃなイ"
"カ。 その後ディスプレイが初期化されていたら\"c_gl\"ではじまる名前の関数群、 "
"つまりOpenGL ESの関数群を呼び出して画面描画をするでゲソ。 このOpenGL ESの関数"
"群は以下のファイルで定義されているでゲソ。 HaskellからC言語の関数が呼び出せて"
"便利でゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:168
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/lib/android-ndk/"
"AndroidNdk/OpenGLES.hs](https://github.com/ajhc/demo-android-ndk/blob/master/"
"lib/android-ndk/AndroidNdk/OpenGLES.hs)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:170
msgid "## AndroidEngine型の状態変更"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:174
msgid ""
"engineDrawFrame関数の実装を見ていると、AndroidEngine型に変更がないと立方体は"
"微塵とも動かないことがわかるでゲソ。 誰かがAndroidEngine型の状態を変更してい"
"ないとつじつまが合わないんじゃなイカ？ この状態を変更する犯人は二人いるんでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:178
msgid ""
"まず一人目はeHandleInput関数でゲソ。 この関数はタッチパネルのドラッグ動作を検"
"出して、 AndroidEngine型に格納されている以下4つの状態を変更するでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:183
msgid "sStateX: 現在タッチされているX座標"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:183
msgid "sStateY: 現在タッチされているY座標"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:183
msgid "sStateDx: X方向のドラッグされた距離"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-12-17-snatch-droid.md:183
msgid "sStateDy: Y方向のドラッグされた距離"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:185
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/Main."
"hs#L38](https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/"
"Main.hs#L38)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:201
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"eHandleInput :: AndroidEngine -> AInputEventType -> AMotionEventAction -> (Float, Float) -> IO (Maybe AndroidEngine)\n"
"eHandleInput eng = go\n"
"  where go AInputEventTypeMotion AMotionEventActionUp _ = return Nothing\n"
"        go AInputEventTypeMotion act (x,y) = do\n"
"          let stat = engState eng\n"
"              ox = if act == AMotionEventActionDown then x else fromIntegral $ sStateX stat\n"
"              oy = if act == AMotionEventActionDown then y else fromIntegral $ sStateY stat\n"
"          return (Just $ eng { engAnimating = 1\n"
"                             , engState = stat { sStateX  = truncate x\n"
"                                               , sStateY  = truncate y\n"
"                                               , sStateDx = truncate $ x - ox\n"
"                                               , sStateDy = truncate $ y - oy } })\n"
"        go _ _ _ = return Nothing\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:207
msgid ""
"二人目はeHandleCmd関数じゃなイカ。 この関数のパターンマッチは長いでゲソがほ"
"ぼ [元にしたC言語のnative-activityサンプルコード](https://gist.github.com/"
"master-q/8001496#file-main-c-L182)  のままでゲソ。 この関数でAndroidのアク"
"ティビティの状態管理をしているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:209
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/Main."
"hs#L53](https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/"
"Main.hs#L53)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:237
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"eHandleCmd :: (AndroidApp, AndroidEngine) -> AAppCmd -> IO (Maybe AndroidApp, Maybe AndroidEngine)\n"
"eHandleCmd (app, eng) = go\n"
"  where go AAppCmdSaveState = do\n"
"          sstat <- malloc\n"
"          poke sstat $ engState eng\n"
"          return (Just $ app { appSavedState = sstat\n"
"                             , appSavedStateSize = toEnum $ sizeOf $ engState eng }, Nothing)\n"
"        go AAppCmdInitWindow | appWindow app /= nullPtr = do\n"
"          (Just eng') <- initDisplayHs androidActs eng\n"
"          engineDrawFrame eng'\n"
"          return (Nothing, Just eng')\n"
"        go AAppCmdTermWindow = do\n"
"          eng' <- engineTermDisplay eng\n"
"          return (Nothing, Just eng')\n"
"        go AAppCmdGainedFocus | engAccelerometerSensor eng /= nullPtr = do\n"
"          c_ASensorEventQueue_enableSensor (engSensorEventQueue eng) (engAccelerometerSensor eng)\n"
"          c_ASensorEventQueue_setEventRate (engSensorEventQueue eng) (engAccelerometerSensor eng) ((1000 `div` 60) * 1000)\n"
"          return (Nothing, Nothing)\n"
"        go AAppCmdLostFocus = do\n"
"          when (engAccelerometerSensor eng /= nullPtr) $ void $\n"
"            c_ASensorEventQueue_disableSensor (engSensorEventQueue eng) (engAccelerometerSensor eng)\n"
"          let eng' = eng { engAnimating = 0 }\n"
"          engineDrawFrame eng'\n"
"          return (Nothing, Just eng')\n"
"        go _ = return (Nothing, Nothing)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:239
msgid "## 全てをつなげる簡易フレームワーク"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:244
msgid ""
"engineDrawFrame、eHandleInput、eHandleCmdという3つの関数が出てきたでゲソが、 "
"これらは誰が呼び出すんでゲソ？ 呼び出す人が誰もいないなら動作するはずないじゃ"
"なイカ。 ここらへんの呼び出しはめんどうなのでフレームワークで包んでみたでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:246
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/Main."
"hs#L13](https://github.com/ajhc/demo-android-ndk/blob/master/cube/hs_src/"
"Main.hs#L13)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:253
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"androidActs :: AndroidNdkActs\n"
"androidActs = AndroidNdkActs { drawFrame = engineDrawFrame\n"
"                             , initDisplay = engineInitDisplay\n"
"                             , handleInput = eHandleInput\n"
"                             , handleCmd = eHandleCmd }\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:258
msgid ""
"foreign export ccall \"engineHandleInput\" engineHandleInput :: "
"FuncHandleInput foreign import ccall \"&engineHandleInput\" "
"p_engineHandleInput :: FunPtr FuncHandleInput engineHandleInput :: "
"FuncHandleInput engineHandleInput = handleInputHs androidActs"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:263
msgid ""
"foreign export ccall \"engineHandleCmd\" engineHandleCmd :: FuncHandleCmd "
"foreign import ccall \"&engineHandleCmd\" p_engineHandleCmd :: FunPtr "
"FuncHandleCmd engineHandleCmd :: FuncHandleCmd engineHandleCmd = handleCmdHs "
"androidAct"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:269
msgid ""
"--snip-- foreign export ccall \"androidMain\" androidMain :: Ptr AndroidApp -"
"> IO ()  androidMain :: Ptr AndroidApp -> IO ()  androidMain = androidMainHs "
"androidActs p_engineHandleInput p_engineHandleCmd ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:271
#, fuzzy
#| msgid "![](/draw/2012-12-27-loader.png)"
msgid "![](/draw/20131217_android-fw.png)"
msgstr "![](/draw/2012-12-27-loader.png)"

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:279
msgid ""
"このコード少しわかりにくいので図にしてみたでゲソ。 Androidアプリが起動すると"
"まず最初にandroidMain関数が実行されるんでゲソ。 つまりandroidMain関数はこのア"
"プリでのエントリポイントでゲソ。 この関数はC言語から呼び出せる"
"engineHandleInput、engineHandleCmdという関数と共に4つの関数を内包した"
"AndroidNdkActs型をHaskellで作られたAndroidフレームワークの初期化関数"
"androidMainHsに渡すんじゃなイカ。 このフレームワーク側ではAndroid本体からイベ"
"ントがあると、 いいかんじな処理をした後にAndroidNdkActs型の中の適切な関数を呼"
"び出してアプリを動作させるんでゲソ。 例えば、タッチパネルが操作されてたらイカ"
"のような手順で関数が呼び出されることになるでゲソ。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-12-17-snatch-droid.md:285
msgid "C言語がengineHandleInput関数を呼び出す"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-12-17-snatch-droid.md:285
msgid "engineHandleInput関数がフレームワークのhandleCmdHs関数を呼び出す"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-12-17-snatch-droid.md:285
msgid "いいかんじの処理が走る"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-12-17-snatch-droid.md:285
msgid ""
"フレームワークがAndroidNdkActs型の中からeHandleInput関数を選択して呼び出す"
msgstr ""

#. type: Bullet: '5. '
#: posts/2013-12-17-snatch-droid.md:285
msgid "eHandleInput関数がAndroidEngine型の中の状態を書き換える"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:288
msgid ""
"じゃぁ親玉であるandroidMain関数はどこから呼ばれるかというと、 C言語のエントリ"
"ポイントが呼び出すんでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:290
msgid ""
"[https://github.com/ajhc/demo-android-ndk/blob/master/cube/jni/main.c#L31]"
"(https://github.com/ajhc/demo-android-ndk/blob/master/cube/jni/main.c#L31)"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:294
#, no-wrap
msgid ""
"~~~ {.c}\n"
"void android_main(struct android_app* state) {\n"
"\tapp_dummy(); // Make sure glue isn't stripped.\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:299
#, no-wrap
msgid ""
"\t// Init & run Haskell code.\n"
"\tint hsargc = 1;\n"
"\tchar *hsargv = \"q\";\n"
"\tchar **hsargvp = &hsargv;\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:305
#, no-wrap
msgid ""
"\ths_init(&hsargc, &hsargvp);\n"
"\tandroidMain(state);\n"
"\ths_exit();\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-12-17-snatch-droid.md:306
msgid "なんかわかったような気になったじゃなイカ!"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:5
#, no-wrap
msgid ""
"title: Shape reentrant on Ajhc.\n"
"description: 再入可能を実現せよ。でゲソ!\n"
"tags: jhc, ajhc, reentrant, interrupt, lock\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:9
msgid ""
"いきなりAjhcの吐くコードを並列実行可能にすることはハードルが高すぎるでゲソ。 "
"まず再入可能を実現しなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:11
msgid "## スナッチ対象を決めるでゲソ"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:15
msgid ""
"再入可能を実現するにあたって、何かアプリケーション例があった方が良いでゲソ。 "
"[Cortex-M3向けデモ](https://github.com/ajhc/demo-cortex-m3)  の中にイカのよう"
"なコードがあるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:21
#, no-wrap
msgid ""
"~~~ {.gnuassembler}\n"
"/* File: demo-cortex-m3/stm32f3-discovery/Device/startup_stm32f30x.s */\n"
" \t.section\t.isr_vector,\"a\",%progbits\n"
"\t.type\tg_pfnVectors, %object\n"
"\t.size\tg_pfnVectors, .-g_pfnVectors\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:29
#, no-wrap
msgid ""
"g_pfnVectors:\n"
"\t.word\t_estack\n"
"\t.word\tReset_Handler\n"
"/* snip */\n"
"\t.word\tPendSV_Handler\n"
"\t.word\tSysTick_Handler\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:33
msgid ""
"~~~ {.c} // File: demo-cortex-m3/stm32f3-discovery/src/main.c __IO uint32_t "
"TimingDelay = 0;"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:38
#, no-wrap
msgid ""
"void SysTick_Handler(void)\n"
"{\n"
"  TimingDelay_Decrement();\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:46
#, no-wrap
msgid ""
"void TimingDelay_Decrement(void)\n"
"{\n"
"  if (TimingDelay != 0x00)\n"
"  { \n"
"    TimingDelay--;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:50
#, no-wrap
msgid ""
"void Delay(__IO uint32_t nTime)\n"
"{\n"
"  TimingDelay = nTime;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:54
#, no-wrap
msgid ""
"  while(TimingDelay != 0);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:56
msgid ""
"このしくみはDelay関数による指定時間待ち合わせを実現するために、イカのような動"
"作を期待しているでゲソ。"
msgstr ""

#. type: Bullet: '1. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "Delay関数呼び出し"
msgstr ""

#. type: Bullet: '2. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "Delay関数はグローバル変数TimingDelayに待ち時間を代入"
msgstr ""

#. type: Bullet: '3. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "Delay関数はそのままTimingDelayが0になるのを待つ"
msgstr ""

#. type: Bullet: '4. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "クロック割り込みでSysTick_Handler関数が起動される"
msgstr ""

#. type: Bullet: '5. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "SysTick_Handler関数はTimingDelayを1減ずる"
msgstr ""

#. type: Bullet: '6. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "4と5が繰り返されるとそのうちTimingDelayが0になる"
msgstr ""

#. type: Bullet: '7. '
#: posts/2013-06-20-reentrant_jhc.md:64
msgid "3の待ちが解除される"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:66
msgid "上記コードをHaskell化してみなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:68
msgid "## 設計方針"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:70
msgid ""
"設計の方針に大きく影響するのはHaskellヒープの確保でゲソ。これは大きく2つの案"
"に分かれるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:77
#, no-wrap
msgid ""
"* A. 実行バイナリの中でHaskellヒープは唯一一つだけ確保する\n"
"    * メリット: STMなどコンテキスト間での状態共有を実装しやすい\n"
"    * デメリット: ミューテターのクリティカルリージョン保護を実装する必要がある。場合によってはjgcの抜本的見直しが必要\n"
"* B. Haskellヒープをコンテキスト毎に分割して持つ\n"
"    * メリット: jgcのGCスタックをそのまま適用できる。GCコストがコンテキストの規模に比例する。並列実行できる\n"
"    * デメリット: コンテキスト間での状態共有には完全に正格なデータでなければならないなど制限がかる。設計者が意図しない所でサンクが共有されてしまう可能性\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:83
msgid ""
"通常はAの方が良い案でゲソ。GHCも案Aを採用しているじゃなイカ。 しかしAjhcでは"
"ミューテターが生C言語である関係上、 明示的なコンテキストスイッチをミューテ"
"ター側から判断させるのかきびしいでゲソ。 さらに将来NetBSD kernelをスナッチす"
"ることも考えると、 RTSを頻繁に呼び出すような息継ぎをミューテターにさせるのは"
"ナンセンスとしか思えないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:91
msgid ""
"案Bに関して考えると思わぬメリットあり、 それはコンテキスト間でGC関連の処理を"
"完全に分離できるということでゲソ。 つまり並列にGCさせることももちろんできるで"
"ゲソ。 さらにHaskellヒープをどれぐらい汚すかはコンテキストによって決まるの"
"で、 ヒープを汚したコンテキストが自分でお掃除する責務を負うのでコンテキスト毎"
"のGC負荷が予測しやすいでゲソ。 kernelのほとんどの部分はイベントドリブンである"
"ことを考えると、 世代別GCを作らなくても乗り切れるかもしれないじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:99
msgid ""
"案Bの問題はコンテキスト間の状態共有でゲソが、 プリミティブ型へのPtr型を使う分"
"には何も問題にはならないでゲソ。 もちろんサンクが知らぬ間にコンテキスト間で共"
"有されてしまうケースも考えられるでゲソ。 さらにSTMような複雑な状態共有方法に"
"ついてはどうすれば解決するのか検討もつかないじゃなイカ。 しかし案Aより案Bの方"
"が実装コストが低いことは容易に想像できるので、 まずは案Bで実装してみなイカ？ "
"実装してみてgrinコードを眺めてみればまたアイデアがわくかもしれないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:101
msgid "というわけで設計方針はなんとなくイカに分解できそうでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "TimingDelay変数はPtr Word32型に"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "SysTick_Handler関数はforeign export ccall SysTick_Handler :: IO ()"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid ""
"foreign export ccallな関数は呼び出される度にGCスタックとヒープを割り当て"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "foreign export ccallな関数が終了したら自GCスタックとヒープを解放"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "GCスタック毎に別々のHaskellヒープを持つ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "s_alloc関数はコンテキストによって使うヒープを切り換え"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:109
msgid "GC関連関数の実行を排他するためのロックプリミティブ"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:111
msgid "それぞれについて実施できそうか調べてみようじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:113
msgid "## foreign export ccallは(A)jhcでも使えるか"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:117
msgid ""
"Main.main関数がないとコンパイルエラーになるでゲソが、いちおう使えるでゲソ。 "
"[SlimHaskell/FibHs_ajhc](https://github.com/master-q/SlimHaskell/tree/master/"
"FibHs_ajhc)  にソースコードとコンパイル済みバイナリを置いたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:137
#, no-wrap
msgid ""
"~~~\n"
"$ size */FibHs | sort -n -k 6\n"
"   text    data     bss     dec     hex filename\n"
"  13527    1224     712   15463    3c67 FibHs_ajhc/FibHs\n"
" 285321   11048   26088  322457   4eb99 FibHs13/FibHs\n"
" 303321   12416   26088  341825   53741 FibHs12/FibHs\n"
" 415297   27152   26080  468529   72631 FibHs11/FibHs\n"
" 719915   73896   26080  819891   c82b3 FibHs10/FibHs\n"
" 809675   81128   26080  916883   dfd93 FibHs9/FibHs\n"
"1102459  108864   26080 1237403  12e19b FibHs8/FibHs\n"
"1316273  128520   26496 1471289  167339 FibHs7/FibHs\n"
"1662383  134296   42880 1839559  1c11c7 FibHs6/FibHs\n"
"1704127  134856   44088 1883071  1cbbbf FibHs5/FibHs\n"
"2503048  266320   44088 2813456  2aee10 FibHs4/FibHs\n"
"2523847  266616   44088 2834551  2b4077 FibHs3/FibHs\n"
"2719976  282776   44088 3046840  2e7db8 FibHs2/FibHs\n"
"2780783  290568   45592 3116943  2f8f8f FibHs1/FibHs\n"
"2784294  290592   47960 3122846  2fa69e FibHs0/FibHs\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:142
msgid ""
"ところでjhcの威力はすごいでゲソ。 [簡約! λカ娘(4)](http://www.paraiso-lang."
"org/ikmsm/books/c83.html)  でGHCあれだけがんばったサイズ削減結果よりはるかに"
"小さいバイナリを吐くでゲソ。 すごいじゃなイカ!"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:144
msgid "## GCスタックとHaskellヒープのコンテキストへの割り当てと解放"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:146
msgid ""
"### コンパイルパイプラインを修正してforeign export ccallの入口/出口でGCスタッ"
"クとHaskellヒープの割り当て/解放"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:151
msgid ""
"foreign export ccallがgrinの中でどう扱われているのか気になったので、 foreign "
"export ccallを使うHaskellコードを[ダンプしてみた](https://github.com/ajhc/"
"ajhc-dumpyard/tree/master/use_foreign_export)でゲソ。 このダンプの中にある"
"grinコード [hs_main.c_final.grin](https://github.com/ajhc/ajhc-dumpyard/blob/"
"master/use_foreign_export/hs_main.c_final.grin)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:163
#, no-wrap
msgid ""
"~~~\n"
"fFE@.CCall.fib :: (bits32) -> (bits32)\n"
"fFE@.CCall.fib w8 = do\n"
"  h100016 <- 0 `Lte` w8\n"
"  nd68 <- case h100016 of\n"
"    0 -> return (CJhc.Type.Word.Int 0)\n"
"    1 -> do\n"
"      h100018 <- 40 `Gte` w8\n"
"      case h100018 of\n"
"        1 -> do\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:166
msgid ""
"と出力されたC言語コード [hs_main.c](https://github.com/ajhc/ajhc-dumpyard/"
"blob/master/use_foreign_export/hs_main.c)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:182
#, no-wrap
msgid ""
"~~~ {.c}\n"
"static uint32_t A_STD\n"
"fFE$__CCall_fib(gc_t gc,uint32_t v8)\n"
"{\n"
"        wptr_t v68;\n"
"        uint32_t v35;\n"
"        uint16_t v100016 = (((int32_t)0) <= ((int32_t)v8));\n"
"        if (0 == v100016) {\n"
"/* --snip-- */\n"
"int \n"
"fib(int x11)\n"
"{\n"
"        return (int)fFE$__CCall_fib(saved_gc,(uint32_t)x11);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:187
msgid ""
"を見比べると、どうやら\"fFE$__CCall_fib\"という関数がforeign export ccallした"
"関数のようでゲソ。 また [hs_main.c_final.datalog](https://github.com/ajhc/"
"ajhc-dumpyard/blob/master/use_foreign_export/hs_main.c_final.datalog)  を読む"
"とイカのように型の定義まであるじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:203
msgid ""
"~~~ % functions -- snip -- func('fFE@.CCall.fib',1).  "
"perform(assign,'v8','fFE@.CCall.fib@arg@0').  what('fFE@.CCall.fib@arg@0',"
"funarg).  typeof('fFE@.CCall.fib@arg@0','bits32').  typeof('v8','bits32').  "
"what('fFE@.CCall.fib@ret@0',funret).  typeof('fFE@.CCall."
"fib@ret@0','bits32').  -- snip -- subfunc('fW@.fR@.fJhc.List.243_sub','fFE@."
"CCall.fib').  -- snip -- perform(assign,'fFE@.CCall.fib@ret@0','v35').  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:207
msgid ""
"このforeign export ccallな関数はgrinの中ではそのまんまCCallという型で表現され"
"ているでゲソ。 ということはイカのconvertFunc関数を修正すれば、 GCスタックと"
"Haskellヒープの割り当て/解放処理をforeign export ccallな関数に注入できそう"
"じゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:229
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- ajhc/src/C/FFI.hs\n"
"data FfiExport = FfiExport {\n"
"    ffiExportCName    :: CName,\n"
"    ffiExportSafety   :: Safety,\n"
"    ffiExportCallConv :: CallConv,\n"
"    ffiExportArgTypes :: [ExtType],\n"
"    ffiExportRetType  :: ExtType\n"
"    }\n"
" deriving(Eq,Ord,Show,Typeable)\n"
"-- ajhc/src/C/Prims.hs\n"
"data CallConv = CCall | StdCall | CApi | Primitive | DotNet\n"
"    deriving(Eq,Ord,Show)\n"
"-- ajhc/src/C/FromGrin2.hs\n"
"convertFunc :: Maybe FfiExport -> (Atom,Lam) -> C [Function]\n"
"convertFunc ffie (n,as :-> body) = do\n"
"--snip--\n"
"        mstub <- case ffie of\n"
"                Nothing -> return []\n"
"                Just ~(FfiExport cn Safe CCall argTys retTy) -> do\n"
"                    newVars <- mapM (liftM (name . show) . newVar . basicType') argTys\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:233
#, no-wrap
msgid ""
"                    let fnname2 = name cn\n"
"                        as2 = zip (newVars) (map basicType' argTys)\n"
"                        fr2 = basicType' retTy\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:238
#, no-wrap
msgid ""
"                    return [function fnname2 fr2 as2 [Public]\n"
"                                     (creturn $ cast fr2 $ functionCall fnname $ (if fopts FO.Jgc then (variable (name \"saved_gc\"):) else id) $\n"
"                                      zipWith cast (map snd as')\n"
"                                                   (map variable newVars))]\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:241
#, no-wrap
msgid ""
"        return (function fnname fr (mgct as') ats s : mstub)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:243
msgid "### 使用済みGCスタックとHaskellヒープを次回確保用にプール"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:245
msgid ""
"今のAjhcは通常イカのようにGCスタックとHaskellヒープを管理しているでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:248
msgid "GCスタック: mallocで確保。サイズは1<<18エントリ"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:248
msgid "Haskellヒープ: 1MBずつmegablockが補給される"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:252
msgid ""
"\"_JHC_JGC_FIXED_MEGABLOCK\" defineが有効な場合、 GCスタックとHaskellヒープは"
"どちらも固定サイズで唯一一つだけ確保されるのだったでゲソ。 少し冗長になるでゲ"
"ソが、Cortex-M4に対応するにはイカのコンパイルフラグが必要になりそうでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:258
msgid "\"_JHC_JGC_GCSTACK_SIZE\": GCスタックのサイズ指定"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:258
msgid "\"_JHC_JGC_FIXEDNUM_GCSTACK\": GCスタックの個数(個数限定)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:258
msgid "\"_JHC_JGC_MEGABLOCK_SHIFT\": megablockのサイズ指定"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:258
msgid "\"_JHC_JGC_BLOCK_SHIFT\": blockのサイズ指定"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:258
msgid "\"_JHC_JGC_FIXEDNUM_MEGABLOCK\": megablockの個数(個数限定)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:260
msgid ""
"\"_JHC_JGC_FIXED_MEGABLOCK\"フラグは意味が変更になってしまうので撤廃するでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:266
msgid ""
"また、GCスタックとHaskellヒープを動的に確保する場合も固定で確保する場合も "
"Ajhcランタイム内部のリストにプールしておき、 要求された時にmallocを呼ばずに"
"ミューテターに渡せるようにしたいでゲソ。 GCスタックもmegablockも一つのエント"
"リは固定サイズなので、 見分けがつかないはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:268
msgid "### ランタイムのAPI修正"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:271
msgid ""
"今回の変更でstruct s_arenaを文脈毎に分割して持つことになるでゲソ。 そこで、"
"AjhcランタイムのAPIもそれに合わせて修正が必要になるでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:282
msgid ""
"struct s_arenaを全ての関数の第二引数でひきまわす (第一引数はGCスタックへのポ"
"インタ)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:282
msgid "struct s_arenaにgc_stack_baseメンバーを追加 (saved_gcメンバーも必要？)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:282
#, no-wrap
msgid ""
"* ミューテターから呼び出される関数の引数にstruct s_arenaを追加、そのような関数は...\n"
"    * eval\n"
"    * gc_add_root\n"
"    * gc_alloc\n"
"    * gc_array_alloc\n"
"    * gc_array_alloc_atomic\n"
"    * gc_perform_gc\n"
"    * s_alloc\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:284
msgid "gc_new_foreignptrとかは対応しなくていいんだろうかちょっと不安でゲソ"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:292
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/lib/jhc/Jhc/ForeignPtr.hs\n"
"foreign import safe ccall gc_malloc_foreignptr\n"
"    :: Word     -- alignment in words\n"
"    -> Word     -- size in words\n"
"    -> Bool     -- false for plain foreignptrs, true for ones with finalizers.\n"
"    -> UIO (Bang_ (ForeignPtr a))\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:295
#, no-wrap
msgid ""
"foreign import safe ccall gc_new_foreignptr ::\n"
"    Ptr a -> UIO (Bang_ (ForeignPtr a))\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:301
#, no-wrap
msgid ""
"foreign import unsafe ccall gc_add_foreignptr_finalizer\n"
"    :: Bang_ (ForeignPtr a)\n"
"    -> FinalizerPtr a\n"
"    -> IO ()\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:304
msgid ""
"と、GCスタックへのポインタを渡していないライブラリがあるでゲソ。 そしてランタ"
"イムのGC側ではグローバル変数saved_gcからGCスタックを取り出しているでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:315
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* File: ajhc/rts/rts/gc_jgc.c */\n"
"heap_t A_STD\n"
"gc_new_foreignptr(HsPtr ptr) {\n"
"        HsPtr *res = gc_array_alloc_atomic(saved_gc, 2, SLAB_FLAG_FINALIZER);\n"
"        res[0] = ptr;\n"
"        res[1] = NULL;\n"
"        return TO_SPTR(P_WHNF, res);\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:317
msgid ""
"このように一旦GCスタックへのポインタの受け渡しが途切れる箇所がいくつかあり、"
"それは"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:322
msgid "hs_perform_gc"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:322
msgid "jhc_alloc_init"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:326
msgid ""
"の4つのようでゲソ。これはまずいでゲソ...  なんとかstruct arenaとGCスタックへ"
"のポインタを渡せるようにすべきでゲソ。 もっと踏み込むと\"foreign import ccall"
"\"にGCスタックを渡すことを指定する修飾子が必要でゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:328
msgid "## Ajhcに求められる排他制御とは何か"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:332
msgid ""
"Cortex-M3ぐらいの小さなCPUではロックを作らなくても、割り込み禁止でいいんじゃ"
"なイカ？ とはいえユーザ空間でも動かせるように排他制御を抽象化しておいた方がい"
"いでゲソ。 現時点での排他したいモノは..."
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:335
msgid "mallocヒープへの操作"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:335
msgid "GCスタックとHaskellヒープの管理プールへの操作"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:337
msgid "排他の実現手段は..."
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:343
msgid ""
"[pthread_mutex_lock](http://netbsd.gw.com/cgi-bin/man-cgi?pthread_mutex_lock+"
"+NetBSD-current)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:343
msgid ""
"[NetBSD mutex_enter](http://netbsd.gw.com/cgi-bin/man-cgi?mutex_enter+"
"+NetBSD-current)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:343
msgid "CASを使ったシンプルなロック"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:343
msgid "割り込み禁止 (今はCortex-M3のみ)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:343
msgid "ノーガード戦法"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:351
msgid ""
"条件変数 ([pthread_cond_wait](http://netbsd.gw.com/cgi-bin/man-cgi?"
"pthread_cond_wait++NetBSD-current)  や [NetBSD cv_wait](http://netbsd.gw.com/"
"cgi-bin/man-cgi?condvar++NetBSD-current))  が将来必要になることはないのか"
"ちょっと予測しきれないでゲソ...  不要ということおそらくないのでAPIの名前空間"
"としては使用可能にした方がいいんじゃなイカ？ 具体的なインターフェイスはイカの"
"3つで今回のケースは充足するでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:355
msgid "ロックの初期化"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:355
msgid "lock"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:355
msgid "unlock"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:357
msgid ""
"ロックの解放はむつかしい問題でゲソが、今回はロックの解放はプロセスの終了と同"
"時で問題ないでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:359
msgid "### グローバルサンクの評価での排他とBLACKHOLE"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:362
msgid ""
"アドレスnh_startからnh_endまでの領域にはグローバルサンクが配置されているでゲ"
"ソ。 少なくともグローバルサンクは複数のコンテキストで共有するので、なにか排他"
"をするべきじゃなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:364
msgid "### シグナルハンドラはsigwaitで取り扱う"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:369
msgid ""
"mutex\\_enterはkernelの割り込みハンドラから使用可能でゲソが、 pthread\\_mutex"
"\\_lockはシグナルハンドラから使用することができないでゲソ。 そこで、POSIXの"
"mutexを使う場合にはシグナル処理専用のスレッドを起こして、 sigwaitループさせた"
"方が良さそうでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:371
msgid "## モジュール分割"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:377
msgid ""
"先に見た通り、ロックを提供する手段にはいろいろあるでゲソ。 どの手段が最適とい"
"うことはなく、Ajhcを適用するドメイン毎にロックの実現手段は選択できた方が良い"
"でゲソ。 そこで、ロック関連の機能を提供するモジュールをHaskellライブラリ化し"
"て、 そのモジュールのAPIをHaskell側とランタイム側双方から使うようにするでゲ"
"ソ。 そのライブラリの種別はイカの3つにするでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:381
msgid "空実装 (デフォルト)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:381
msgid "pthreadによる実装"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:381
msgid "実装なし (コンパイラ使用者が独自に実装)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:387
msgid ""
"このモジュールの公開APIを考えてみるでゲッソ! ところでajhc/src/StringTable/"
"StringTable\\_cbits.cにpthread\\_mutex\\_lock が入っているでゲソが、"
"USE_THREADSが0になっていて殺されているでゲソ...  今回コイツも復活させてやった"
"方がいいんじゃなイカ？ SelfTestがたまに失敗する原因はこいつなような気がしてき"
"たでゲッソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:389
msgid "### GHCで該当するAPI"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:391
msgid ""
"せっかくAPIを切るのだからGHCと同じ名前にしておいた方が後々楽ができるんじゃな"
"イカ？"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "type Signal = CInt"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid ""
"setHandler :: Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe "
"(HandlerFun, Dynamic))"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "int stg_sig_install(int sig, int spi, void *mask)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401 posts/2013-06-20-reentrant_jhc.md:409
msgid "forkOS :: IO () -> IO ThreadId"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "int forkOS_createThread ( HsStablePtr entry )"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "typedef pthread_mutex_t Mutex"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "void initMutex ( Mutex* pMut )"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "\\#define ACQUIRE_LOCK(mutex) foreign \"C\" pthread_mutex_lock(mutex)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:401
msgid "\\#define RELEASE_LOCK(mutex) foreign \"C\" pthread_mutex_unlock(mutex)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:404
msgid ""
"書きだしたけれど、とりあえず今はスレッドが扱えれば良いので、シグナルの抽象化"
"はやめておこうと思うでゲソ。 ということでこのGHCのAPIを真似てAjhcでの公開API"
"を決めるでゲソ〜。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:406
msgid "### Haskell側に公開するAPI"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:409
msgid "data ThreadId"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:411
msgid "### ランタイム側で準備するAPI"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "typedef pthread_t jhc_threadid_t"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "typedef pthread_mutex_t jhc_mutex_t"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_mutex_init(jhc_mutex_t *mutex)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_mutex_lock(jhc_mutex_t *mutex)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_mutex_unlock(jhc_mutex_t *mutex)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid ""
"jhc_threadid_t forkOS_createThread(void *(*wrapper) (void *), void *entry, "
"int *err);"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_conc_init(void);"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_rts_lock(void);"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-20-reentrant_jhc.md:421
msgid "void jhc_rts_unlock(void);"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:423
msgid "## あとは実装するだけじゃなイカ!"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:429
msgid ""
"これまではgcが全ての関数の第一引数になっていたじゃなイカ。 さらに [arenaを全"
"ての関数の第二引数に追加](https://github.com/ajhc/ajhc/"
"commit/4f8a185bace5562e16fb9fb803a8db9d43578d54)  したでゲソ。 この対応でgcと"
"arenaをコンテキスト毎に別々に取ることができ、GCをコンテキストローカルで実行で"
"きるようになったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:432
msgid ""
"またsaved_gcというグローバル変数でFFIによるC言語関数実行の前にgcの中断をメモ"
"していたでゲソが、 イカの3つの関数だけgcとarenaを直接RTSに渡すようにすればこ"
"のsaved_gcは不要になるはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:439
msgid ""
"~~~ $ git grep import lib|grep \" safe\" lib/jhc/Jhc/ForeignPtr.hs:foreign "
"import safe ccall gc_malloc_foreignptr lib/jhc/Jhc/ForeignPtr.hs:foreign "
"import safe ccall gc_new_foreignptr :: lib/jhc/System/Mem.hs:foreign import "
"ccall safe \"hs_perform_gc\" performGC :: IO ()  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:442
msgid ""
"[foreign import jhc_context ccall](https://github.com/ajhc/ajhc/"
"commit/889d2cf5d557b9d5b41a318efa8237d487de4142)  というAjhc専用のimport種別"
"を作成して、この種別が有効な場合にはC言語の関数にgcとarenaを引数渡しするよう"
"になったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:450
msgid ""
"ところで [Haskell 2010: 8 Foreign Function Interface](http://www.haskell.org/"
"onlinereport/haskell2010/haskellch8.html)  によると、hs\\_perform\\_gc関数に"
"は引数を取れない決まりでゲソ。 するとRTSをロックして次回s_alloc時にGCを実行す"
"るようなフラグをarenaに立ててやる必要がありそうでゲソ。 とりあえず生存してい"
"るコンテキストに対応するarenaに対して [次回s\\_alloc呼び出しの際に強制GC実行]"
"(https://github.com/ajhc/ajhc/commit/"
"fe31a9dd047ed0a564955a51ff51582f05f08b1f#L1L715)  するようにしてみたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:453
msgid ""
"さらにs\\_cacheがグローバル管理されているのもなんとかしたいでゲソ。 s\\_cache"
"の定義を新規structにまとめて、arenaの下にそのstructを配置すればなんとかなりそ"
"うじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:470
#, no-wrap
msgid ""
"~~~ {.c}\n"
"/* File: ajhc/rts/rts/gc_jgc_internal.h */\n"
"struct s_cache {\n"
"        SLIST_ENTRY(s_cache) next;\n"
"        SLIST_HEAD(,s_block) blocks;\n"
"        SLIST_HEAD(,s_block) full_blocks;\n"
"        unsigned char color;\n"
"        unsigned char size;\n"
"        unsigned char num_ptrs;\n"
"        unsigned char flags;\n"
"        unsigned short num_entries;\n"
"        struct s_arena *arena;\n"
"#if _JHC_PROFILE\n"
"        unsigned allocations;\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:489
#, no-wrap
msgid ""
"/* File: hs_main.c */\n"
"#include \"jhc_rts_header.h\"\n"
"static struct s_cache *cCJhc_Prim_Prim_$x3a;\n"
"static struct s_cache *cCJhc_Type_Basic_Just;\n"
"/* snip */\n"
"void \n"
"jhc_hs_init(void)\n"
"{\n"
"        find_cache(&cCJhc_Prim_Prim_$x3a,saved_arena,TO_BLOCKS(sizeof(struct sCJhc_Prim_Prim_$x3a)),2);\n"
"        find_cache(&cCJhc_Type_Basic_Just,saved_arena,TO_BLOCKS(sizeof(struct sCJhc_Type_Basic_Just)),1);\n"
"/* snip */\n"
"                    sptr_t v69834446 = MKLAZY(x6);\n"
"                    {   gc_frame0(gc,1,v69834446);\n"
"                        wptr_t x7 = s_alloc(gc,arena,cCJhc_Prim_Prim_$x3a);\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x7)->a1 = v106;\n"
"                        ((struct sCJhc_Prim_Prim_$x3a*)x7)->a2 = v69834446;\n"
"                        return x7;\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:493
msgid ""
"同様にランタイムにあるグローバルs\\_cacheも [arenaの下に移動](https://github."
"com/ajhc/ajhc/commit/2c898ff294f93a6bbd6ad58c7dc26ab2aa87d8d4)  したでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:499
msgid ""
"~~~ {.c} /* File: ajhc/rts/rts/gc_jgc.c */ // 7 to share caches with the "
"first 7 tuples #define GC_STATIC_ARRAY_NUM 7 #define GC_MAX_BLOCK_ENTRIES 150"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:503
msgid ""
"static struct s_cache *array_caches[GC_STATIC_ARRAY_NUM]; static struct "
"s_cache *array_caches_atomic[GC_STATIC_ARRAY_NUM]; ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:505
msgid "## 実験: pthreadを使ってTimingDelayをエミュレートしてみる"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:508
msgid ""
"ハードウェア割り込みのエミュレートなので、forkOSは使わないでゲソがとにかく"
"やってみるでゲソ。 ...んんーーー [完成でゲソー!](https://github.com/ajhc/"
"ajhc-dumpyard/tree/master/emulateTimingDelay)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:512
msgid ""
"このプログラムはTimingとDelayの2つのスレッドが動作して、 Delayスレッドの待ち"
"合わせをTimingスレッドが解除するでゲソ。 実行してみると3秒毎に経過時間がコン"
"ソールに印字されるはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:517
msgid ""
"まずC言語側から説明するでゲソ。 main関数はHaskellコードを実行する前に"
"run_timingDelayDecrement関数を新しいスレッドとして実行するでゲソ。 "
"run_timingDelayDecrement関数は100ミリ秒毎にHaskellのtimingDelayDecrement関数"
"を呼び出すでゲソ。 つまりこのスレッドはタイマー割り込みをエミュレーションして"
"いることになるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:521
msgid "~~~ {.c} // main.c static uint32_t TimingDelay = 0;"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:527
#, no-wrap
msgid ""
"uint32_t *\n"
"getTimingDelay()\n"
"{\n"
"        return &TimingDelay;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:538
#, no-wrap
msgid ""
"void *run_timingDelayDecrement(void *p)\n"
"{\n"
"\tfor (;;) {\n"
"#define MILLI_SEC(N)  ((N) * 1000)\n"
"\t\tusleep(MILLI_SEC(100));\n"
"\t\ttimingDelayDecrement();\n"
"\t}\n"
"\t/* NOTREACHED */\n"
"\treturn NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:543
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"\tint err;\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:555
#, no-wrap
msgid ""
"        hs_init(&argc,&argv);\n"
"        if (jhc_setjmp(&jhc_uncaught)) {\n"
"                jhc_error(\"Uncaught Exception\");\n"
"        } else {\n"
"\t\tforkOS_createThread(&run_timingDelayDecrement, NULL, &err);\n"
"                _amain();\n"
"\t}\n"
"        hs_exit();\n"
"        return 0;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:561
msgid ""
"今度はHaskell側でゲソ。 先のrun_timingDelayDecrementスレッドから呼び出される"
"timingDelayDecrement関数は単にポインタの先にある uint32_tの値を減算するだけで"
"ゲソ。 一方、Haskellのmain関数はmyDelay関数を繰り返し呼び出していて、 さっき"
"のuint32_tに待ち合わせ時間を書き込んだ後、その値が0になるのをループで待ち合わ"
"せるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:568
msgid ""
"~~~ {.haskell} {-# LANGUAGE ForeignFunctionInterface #-} import Data.Word "
"import Control.Monad import Foreign.Ptr import Foreign.Storable"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:571
msgid ""
"-- Timing foreign import ccall \"c_extern.h getTimingDelay\" "
"c_gettimingDelay :: IO (Ptr Word32)"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:577
#, no-wrap
msgid ""
"timingDelayDecrement :: IO ()\n"
"timingDelayDecrement = do\n"
"  p <- c_gettimingDelay\n"
"  i <- peek p\n"
"  when (i >= 0) $ poke p (i - 1)\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:579
msgid ""
"foreign export ccall \"timingDelayDecrement\" timingDelayDecrement :: IO ()"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:591
#, no-wrap
msgid ""
"-- Delay\n"
"myDelay :: Word32 -> IO ()\n"
"myDelay nTime = do\n"
"  p <- c_gettimingDelay\n"
"  poke p nTime\n"
"  let while :: IO ()\n"
"      while = do\n"
"        p' <- c_gettimingDelay\n"
"        i <- peek p'\n"
"        if (i > 0) then while else return ()\n"
"  while\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:594
msgid "foreign import ccall \"c_extern.h getTime\" c_getTime :: IO Word64 ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-20-reentrant_jhc.md:595
msgid "これでスレッドの波をすいーいすいーじゃなイカー。"
msgstr ""

#. type: Plain text
#: posts/2013-07-17-detail_of_jhc_parser.md:5
#, no-wrap
msgid ""
"title: (作成中) Detail of jhc's parser.\n"
"description: パーサを理解してコンパイルパイプライン上段を改造しまくるでゲソ!\n"
"tags: jhc, ajhc, parser\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-07-17-detail_of_jhc_parser.md:8
msgid "## 全体"
msgstr ""

#. type: Plain text
#: posts/2013-07-17-detail_of_jhc_parser.md:16
#, no-wrap
msgid ""
"~~~\n"
"loadModules\n"
"=> fetchSource :: Opt -> IORef Done -> [FilePath] -> Maybe (Module,SrcLoc) -> IO Module\n"
"   => parseHsSource :: Opt -> FilePath -> LBS.ByteString -> IO (HsModule,LBS.ByteString)\n"
"      => runParserWithMode :: ParseMode -> P a -> String -> ([Warning],ParseResult a)\n"
"         => parse :: P HsModule\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-07-17-detail_of_jhc_parser.md:18
msgid "このparseという関数は src/FrontEnd/HsParser.y で定義されていて、"
msgstr ""

#. type: Plain text
#: posts/2013-07-17-detail_of_jhc_parser.md:23
msgid ""
"## src/Ho/Build.hs ## src/Ho/ReadSource.hs ## src/FrontEnd/HsParser.y ## src/"
"FrontEnd/ParseUtils.hs"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第3回 議事録\n"
"description: オープンソースカンファレンス2013 Kansai@KyotoをAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:10
msgid ""
"Metasepi作戦会議 第3回を [オープンソースカンファレンス2013 Kansai@Kyoto]"
"(https://www.ospn.jp/osc2013-kyoto/)  で開催したでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:14
msgid ""
"今回の作戦会議はHaskellや組み込みマイコンに詳しくない人にもMetasepiプロジェク"
"トとAjhcコンパイラの意義について解説してみたでゲソ。 いろんな人にワシのことを"
"理解してもらえて嬉しかったゲソ! またアプリケーション例のアイデアももらったの"
"で、後で挑戦してみようと思うでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:18
msgid ""
"### 組込向けHaskellコンパイラAjhc / POSIX依存から脱出しよう編 - "
"@masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:20
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/24806018\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/master_q/20130802-osc-kyotoajhc\" title=\"組"
"込向けHaskellコンパイラAjhc / POSIX依存から脱出しよう編\" target=\"_blank\">"
"組込向けHaskellコンパイラAjhc / POSIX依存から脱出しよう編</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:22
msgid "### Ajhc Hacking Guide本の執筆環境 - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:24
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/24833172\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/master_q/reviewlibreofficeomake\" title="
"\"ReVIEWとLibreOfficeとOMakeで本を書きましょう！\" target=\"_blank\">ReVIEWと"
"LibreOfficeとOMakeで本を書きましょう！</a> </strong> from <strong><a href="
"\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></"
"strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-08-04-osckansai2013.md:29
msgid ""
"![](/img/20130804-desk.jpg)  ![](/img/20130804-hack.jpg)  ![](/img/20130804-"
"drop.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第8回 議事録\n"
"description: 九州をAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc, android\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:14
msgid ""
"Metasepi作戦会議 第8回を [オープンソースカンファレンス2013 Fukuoka](https://"
"www.ospn.jp/osc2013-fukuoka/)  と [オープンソースカンファレンス2013 Oita]"
"(https://www.ospn.jp/osc2013-oita/)  で開催したでゲソ。 今回はOS向けのAjhcコ"
"ンパイラという路線から少し脱線して、 Haskellで書かれたAndroid NDKアプリについ"
"て取り上げてみたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:20
msgid ""
"また福岡と大分のOSCの間に [GitHub Fukuoka Drinkup](http://www.zusaar.com/"
"event/1407003)  なんというイベントがあったので偵察にいってきたでゲソ。 GitHub"
"の中の人に今回のデモを見せたら興味を持ってくれたみたいでゲソ。 もっと大勢の人"
"にAjhcコンパイラに興味を持ってほしいじゃなイカ!"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:24 posts/2013-11-10-kof2013.md:21
msgid ""
"### Metasepi team meeting #7: Snatch application on tiny OS - "
"@masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:26
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/28293973\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20131116-osc-fukuokaajhcdroid\" title=\"Metasepi team meeting "
"#8&#x27;: Haskell apps on Android NDK\" target=\"_blank\">Metasepi team "
"meeting #8&#x27;: Haskell apps on Android NDK</a> </strong> from <strong><a "
"href=\"http://www.slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</"
"a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:28
msgid "## 旅の情報 (別府近辺)"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:37
msgid ""
"だんだんとカプセルホテル紹介コーナーと化してきたこの欄でゲソが、 今回はまずス"
"ターバックス情報についてでゲソ。 今回滞在したのは博多/別府/大分でゲソ。 まず"
"どの駅にもスターバックスは有り、電源も確保できるので原稿書きやもくもく場所に"
"困ることは(平日であれば)ないと思うでゲソ。 しかし、、、天神にだけは行ってはイ"
"カンでゲソ! あそこは九州の原宿でゲソ。アップルストアもあったり色々おしゃれな"
"のは良いのでゲソが、 イカんせんスタバも混んでいることが多いでゲソ。 博多近辺"
"であれば素直に博多駅近郊のスタバに行った方が空いているはずでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:44
msgid ""
"九州といえば温泉が数多くわいているでゲソ。 中でもおすすめは別府でゲソ。 海も"
"近くて、駅の西側には別府公園があってハイキングには最高じゃなイカ。 でも観光客"
"が減ったのか少しさびれつつあって残念でゲソ。 みんな別府の温泉に入ってお金を落"
"とそうじゃなイカ! 博多から別府へは高速バスが出ているので、3000円強ぐらいで移"
"動できるでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-11-24-osc-fukuoka-oita.md:52
msgid ""
"![](/img/20131124_desk.jpg)  ![](/img/20131124_matsuya.jpg)  ![](/"
"img/20131124_bitcoin.jpg)  ![](/img/20131124_nulab.jpg)  ![](/"
"img/20131124_aburaya.jpg)  ![](/img/20131124_hands.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第4回 議事録\n"
"description: OSC2013-Hokkaidoとmbed祭をAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:10
msgid ""
"Metasepi作戦会議 第4回を [オープンソースカンファレンス2013 Hokkaido](http://"
"www.ospn.jp/osc2013-do/) と [mbed祭り in Sapporo](http://atnd.org/"
"events/41585) で開催したでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:14
msgid ""
"今回の作戦会議はmbedマイコン上でのプログラミングにHaskell言語を使う方法を説明"
"してみたでゲソ。 mbedマイコンにはEthernetが付いているので、LCDパネルと組み合"
"わせてRSSリーダーをデモとして作ってみたでゲソ。 このデモは http://www.reddit."
"com/ のRSSを読んで、その一番目の記事のタイトルをLCDにスクロール表示するでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:17
msgid ""
"ARM社のmbedチームの人とクラウドコンパイラについて話を聞けたので、大変有意義な"
"会だったんじゃなイカ？ もっといろんなプラットフォームを侵略してみたいでゲッ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:19
msgid "## 動画"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:21
msgid "### RSSリーダーデモ - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:23
msgid ""
"<iframe width=\"480\" height=\"360\" src=\"//www.youtube.com/embed/"
"C9JsJXWyajQ\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:25 posts/2013-09-16-osc2013-do.md:39
msgid "### mbedではじめる組み込みHaskellプログラミング - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:27
#, no-wrap
msgid "<iframe width=\"480\" height=\"299\" src=\"http://www.ustream.tv/embed/recorded/38841699/highlight/412401?ub=ff720a&amp;lc=ff720a&amp;oc=ffffff&amp;uc=ffffff&amp;v=3&amp;wmode=direct\" scrolling=\"no\" frameborder=\"0\" style=\"border: 0px none transparent;\">    </iframe>\n"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:31
msgid ""
"### 組込向けHaskellコンパイラAjhc / mbedマイコンどうでしょう編 - "
"@masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:33
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/26164495\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"https://www.slideshare.net/master_q/haskellajhc-mbed\" title=\"組込向"
"けHaskellコンパイラAjhc / mbedマイコンどうでしょう編\" target=\"_blank\">組込"
"向けHaskellコンパイラAjhc / mbedマイコンどうでしょう編</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:35
msgid "### mbed+Haskellどうでしょう - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:37
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/26201541\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"https://www.slideshare.net/master_q/mbedhaskell\" title=\"mbed+Haskell"
"どうでしょう\" target=\"_blank\">mbed+Haskellどうでしょう</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:41
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/26206318\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"https://www.slideshare.net/master_q/20130916-mbed-fest\" title=\"mbed"
"ではじめる組み込みHaskellプログラミング\" target=\"_blank\">mbedではじめる組"
"み込みHaskellプログラミング</a> </strong> from <strong><a href=\"http://www."
"slideshare.net/master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:43
msgid "## Togetter"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:45
msgid "[mbed祭り in Sapporo - Togetter](http://togetter.com/li/565348)"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:47
msgid "## 旅の情報 (札幌)"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:50
msgid ""
"宿はいつもカプセルホテルに安く泊っていたので、すすきの近辺のカプセルホテルを3"
"つほど別々に泊って比較してみたでゲソ。 結論としては [ニコーリフレ](http://"
"www.nikoh.info/) が一番いごごちがよかったでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:56
msgid "wifiが使える"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:56
msgid "ベッドに電源がある"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:56
msgid "チェックインから24時間滞在できる"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:56
msgid "お風呂が広い"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:56
msgid "朝食セットにするとかなり豪華なバイキングが食べられる"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:59
msgid ""
"札幌滞在中のハック机は [スターバックス コーヒー 札幌南一条店](http://www."
"starbucks.co.jp/store/search/detail.php?id=373)  で確保したでゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:63
msgid "店内が広い"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:63
msgid "比較的空いている"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:63
msgid "電源の使える席が多め"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:66
msgid ""
"というメリットがあったようじゃなイカ。 大通りから少し離れているからかもしれな"
"いでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:68
msgid "## 関連リンク"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-09-16-osc2013-do.md:70
msgid ""
"[mbed祭り 2013 秋のキャラバン | mbed](https://mbed.org/users/MACRUM/notebook/"
"mbed-fest-2013-autumn-jp/)"
msgstr ""

#. type: Plain text
#: posts/2013-09-16-osc2013-do.md:78
msgid ""
"![](/img/2013-09-16-booth1.jpg)  ![](/img/2013-09-16-booth2.jpg)  ![](/"
"img/2013-09-16-booth3.jpg)  ![](/img/2013-09-16-geza.jpg)  ![](/"
"img/2013-09-16-gift.jpg)  ![](/img/2013-09-16-ooarai.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:5
#, no-wrap
msgid ""
"title: (作成中) Jhc compile pipeline: Grin => C\n"
"description: jhcコンパイルパイプラインの最後段をソースコードから理解してみるでゲソ\n"
"tags: compiler, jhc, c, grin\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:12
msgid ""
"[Jhc compile pipeline: Grin => C (code example)](2013-05-16-jhc_grin_to_c."
"html)  ではjhcのgrinコードのダンプとコンパイル結果のC言語コードを比較すること"
"で、 Grin=>Cの変換を理解した気になっていたでゲソ。 しかし、Ajhcを再入可能にす"
"るためにはコンパイルパイプラインの吐き出すC言語コードの生成ルールそのものに修"
"正を加える必要があるでゲソ。 まずは落ち着いてjhcのGrin=>Cの変換エンジンを読ん"
"でみなイカ？"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:14
msgid "## Grin => C変換の最上位層"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:18
msgid ""
"ズバリ [compileGrin](http://hackage.haskell.org/packages/archive/"
"ajhc/0.8.0.6/doc/html/C-FromGrin2.html#v:compileGrin)  という関数が用意されて"
"いるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:42
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/C/FromGrin2.hs\n"
"compileGrin :: Grin -> (LBS.ByteString,Requires)\n"
"compileGrin grin = (LBS.fromChunks code, req)  where\n"
"    code = [\n"
"        BS.fromString \"#include \\\"jhc_rts_header.h\\\"\\n\",\n"
"        BS.fromString $ P.render ans,\n"
"        BS.fromString \"\\n\"\n"
"        ]\n"
"    ans = vcat [\n"
"        vcat jgcs,\n"
"        vcat includes,\n"
"        text \"\",\n"
"        enum_tag_t,\n"
"        header,\n"
"        cafs,\n"
"        buildConstants cpr grin finalHcHash,\n"
"        text \"\",\n"
"        nh_stuff,\n"
"        text \"\",\n"
"        body\n"
"        ]\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:47
msgid ""
"Grinという型をC言語のByteStringに変換するというそのまんまの型がcompileGrin関"
"数でゲソ。 ansというのが出力するC言語コードの構造で、 [jhc禅](2013-02-19-"
"jhc_zen.html)  で調べた最小のHaskellコードをコンパイルした結果と見比べると何"
"がどこに対応するのかすぐにわかるでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:49
msgid "## Grin型"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:51
msgid "注目すべきはイカの型でゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[Grin型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/html/"
"Grin-Grin.html#t:Grin)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[FuncDef型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/"
"html/Grin-Grin.html#t:FuncDef)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[Lam型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/html/"
"Grin-Grin.html#t:Lam)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[Val型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/html/"
"Grin-Grin.html#t:Val)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[Exp型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/html/"
"Grin-Grin.html#t:Exp)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:58
msgid ""
"[Ty型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/html/"
"Grin-Grin.html#t:Ty)"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:171
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/Grin/Grin.hs\n"
"data Grin = Grin {\n"
"    grinEntryPoints :: GMap Atom FfiExport,\n"
"    grinPhase :: !Phase,\n"
"    grinTypeEnv :: TyEnv,\n"
"    grinFunctions :: [FuncDef],\n"
"    grinSuspFunctions :: Set.Set Atom,\n"
"    grinPartFunctions :: Set.Set Atom,\n"
"    grinStats :: !Stats.Stat,\n"
"    grinCafs :: [(Var,Val)]\n"
"}\n"
"data Phase = PhaseInit | PostInlineEval | PostAeOptimize | PostDevolve\n"
"data FuncDef = FuncDef {\n"
"    funcDefName  :: Atom,\n"
"    funcDefBody  :: Lam,\n"
"    funcDefCall  :: Val,\n"
"    funcDefProps :: FuncProps\n"
"    } deriving(Eq,Ord,Show)\n"
"data Lam = [Val] :-> Exp\n"
"data Val =\n"
"    NodeC !Tag [Val]          -- ^ Complete node, of type TyNode\n"
"    | Const Val               -- ^ constant data, only Lit, Const and NodeC may be children. of type TyINode\n"
"    | Lit !Number Ty          -- ^ Literal\n"
"    | Var !Var Ty             -- ^ Variable\n"
"    | Unit                    -- ^ Empty value used as placeholder\n"
"    | ValPrim Prim [Val] Ty   -- ^ Primitive value\n"
"    | Index Val Val           -- ^ A pointer incremented some number of values (Index v 0) == v\n"
"    | Item Atom Ty            -- ^ Specific named thing. function, global, region, etc..\n"
"    | ValUnknown Ty           -- ^ Unknown or unimportant value\n"
"data FuncProps = FuncProps {\n"
"    funcInfo    :: Info.Info,\n"
"    funcFreeVars :: Set.Set Var,\n"
"    funcTags    :: Set.Set Tag,\n"
"    funcType    :: ([Ty],[Ty]),\n"
"    funcExits   :: Perhaps,      -- ^ function quits the program\n"
"    funcCuts    :: Perhaps,      -- ^ function cuts to a value\n"
"    funcAllocs  :: Perhaps,      -- ^ function allocates memory\n"
"    funcCreates :: Perhaps,      -- ^ function allocates memory and stores or returns it\n"
"    funcLoops   :: Perhaps       -- ^ function may loop\n"
"    }\n"
"data Exp =\n"
"     Exp :>>= Lam                                                         -- ^ Sequencing - the same as >>= for monads.\n"
"    | BaseOp    { expBaseOp :: BaseOp,\n"
"                  expArgs :: [Val]\n"
"                }\n"
"    | App       { expFunction  :: Atom,\n"
"                  expArgs :: [Val],\n"
"                  expType :: [Ty] }                                       -- ^ Application of functions and builtins\n"
"    | Prim      { expPrimitive :: Prim,\n"
"                  expArgs :: [Val],\n"
"                  expType :: [Ty] }                                       -- ^ Primitive operation\n"
"    | Case      { expValue :: Val, expAlts :: [Lam] }                     -- ^ Case statement\n"
"    | Return    { expValues :: [Val] }                                    -- ^ Return a value\n"
"    | Error     { expError :: String, expType :: [Ty] }                   -- ^ Abort with an error message, non recoverably.\n"
"    | Call      { expValue :: Val,\n"
"                  expArgs :: [Val],\n"
"                  expType :: [Ty],\n"
"                  expJump :: Bool,                                        -- ^ Jump is equivalent to a call except it deallocates the region it resides in before transfering control\n"
"                  expFuncProps :: FuncProps,\n"
"                  expInfo :: Info.Info }                                  -- ^ Call or jump to a callable\n"
"    | NewRegion { expLam :: Lam, expInfo :: Info.Info }                   -- ^ create a new region and pass it to its argument\n"
"    | Alloc     { expValue :: Val,\n"
"                  expCount :: Val,\n"
"                  expRegion :: Val,\n"
"                  expInfo :: Info.Info }                                  -- ^ allocate space for a number of values in the given region\n"
"    | Let       { expDefs :: [FuncDef],\n"
"                  expBody :: Exp,\n"
"                  expFuncCalls :: (Set.Set Atom,Set.Set Atom),            -- ^ cache\n"
"                  expIsNormal :: Bool,                                    -- ^ cache, True = definitely normal, False = maybe normal\n"
"                  expNonNormal :: Set.Set Atom,                           -- ^ cache, a superset of functions called in non-tail call position.\n"
"                  expInfo :: Info.Info }                                  -- ^ A let of local functions\n"
"    | MkClosure { expValue :: Val,\n"
"                  expArgs :: [Val],\n"
"                  expRegion :: Val,\n"
"                  expType :: [Ty],\n"
"                  expInfo :: Info.Info }                   -- ^ create a closure\n"
"    | MkCont    { expCont :: Lam,                          -- ^ the continuation routine\n"
"                  expLam :: Lam,                           -- ^ the computation that is passed the newly created computation\n"
"                  expInfo :: Info.Info }                   -- ^ Make a continuation, always allocated on region encompasing expLam\n"
"    | GcRoots   { expValues :: [Val],                  -- ^ add some new variables to the GC roots for a subcomputation\n"
"                  expBody :: Exp }\n"
"data Ty =\n"
"    TyPtr Ty                     -- ^ pointer to a memory location which contains its argument\n"
"    | TyNode                     -- ^ a whole node\n"
"    | TyINode                    -- ^ a whole possibly indirect node\n"
"    | TyAttr Ty Ty               -- ^ attach an attribute to a type\n"
"    | TyAnd Ty Ty                -- ^ boolean conjunction of types\n"
"    | TyOr  Ty Ty                -- ^ boolean disjunction of types\n"
"    | TyPrim Op.Ty               -- ^ a basic type\n"
"    | TyUnit                     -- ^ type of Unit\n"
"    | TyCall Callable [Ty] [Ty]  -- ^ something call,jump, or cut-to-able\n"
"    | TyRegion                   -- ^ a region\n"
"    | TyGcContext                -- ^ the context for garbage collection\n"
"    | TyRegister Ty              -- ^ a register contains a mutable value, the register itself cannot be addressed,\n"
"                                 --   hence they may not be returned from functions or passed as arguments.\n"
"    | TyComplex Ty               -- ^ A complex version of a basic type\n"
"    | TyVector !Int Ty           -- ^ A vector of a basic type\n"
"    | TyUnknown                  -- ^ an unknown possibly undefined type, All of these must be eliminated by code generation\n"
"data Callable = Continuation | Function | Closure | LocalFunction | Primitive'\n"
"data TyThunk\n"
"    = TyNotThunk               -- ^ not the thunk\n"
"    | TyPApp (Maybe Ty) Atom   -- ^ can be applied to (possibly) an argument, and what results\n"
"    | TySusp Atom              -- ^ can be evaluated and calls what function\n"
"data TyTy = TyTy {\n"
"    tySlots :: [Ty],\n"
"    tyReturn :: [Ty],\n"
"    tyThunk :: TyThunk,\n"
"    tySiblings :: Maybe [Atom]\n"
"}\n"
"newtype TyEnv = TyEnv (GMap Atom TyTy)\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:176
msgid ""
"~~~ {.haskell} -- File: ajhc/src/StringTable/Atom.hsc newtype Atom = Atom "
"(#type atom_t)  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:181
msgid ""
"~~~ {.c} /* File: ajhc/src/StringTable/StringTable_cbits.h */ typedef "
"uint32_t atom_t; ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:197
#, no-wrap
msgid ""
"~~~ {.haskell}\n"
"-- File: ajhc/src/C/FFI.hs\n"
"data FfiExport = FfiExport {\n"
"    ffiExportCName    :: CName,\n"
"    ffiExportSafety   :: Safety,\n"
"    ffiExportCallConv :: CallConv,\n"
"    ffiExportArgTypes :: [ExtType],\n"
"    ffiExportRetType  :: ExtType\n"
"    }\n"
"type CName = String\n"
"-- File: ajhc/src/C/Prims.hs\n"
"data Safety = Safe | Unsafe deriving(Eq,Ord,Show)\n"
"data CallConv = CCall | StdCall | CApi | Primitive | DotNet\n"
"newtype ExtType = ExtType PackedString\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:199
msgid "xxx Op.Ty"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:201
msgid "## Cモナド?"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:203
msgid "ここでも注目すべきはイカの型でゲソ。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:207
msgid ""
"[Expression型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/"
"html/C-Generate.html#t:Expression)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:207
msgid ""
"[Statement型](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/doc/"
"html/C-Generate.html#t:Statement)"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:207
msgid ""
"[functionCall関数](http://hackage.haskell.org/packages/archive/ajhc/0.8.0.6/"
"doc/html/C-Generate.html#v:functionCall)"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:209
msgid "## ユーティリティ関数"
msgstr ""

#. type: Plain text
#: posts/2013-06-07-jhc_grin_to_c_withsrc.md:218
msgid ""
"~~~ {.haskell} -- File: ajhc/src/C/FromGrin2.hs runC :: Grin -> C a -> ((a,"
"HcHash,Written),Map.Map Atom TyRep)  convertBody :: Exp -> C Statement "
"convertConst :: Val -> C (Maybe Expression)  compileGrin :: Grin -> (LBS."
"ByteString,Requires)  castFunc :: Op.ConvOp -> Op.Ty -> Op.Ty -> Expression -"
"> Expression convertPrim p vs ty ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:5
#, no-wrap
msgid ""
"title: jhc禅\n"
"description: \"main = return ()\"をjhcでコンパイルしてみるでゲソ!\n"
"tags: haskell, compiler, jhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:11
msgid ""
"jhcのコンパイルパイプラインの調査にちょっと疲れたでゲソ。 なんかで遊んでみた"
"いでゲソ! 一番簡単なHaskellコードをjhcコンパイラに書けるとどんなC言語が吐かれ"
"るでゲソ？ 思い付いたら気になってきたじゃなイカ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:17
msgid "~~~ {.haskell} -- Zen.hs main :: IO ()  main = return ()  ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:19
msgid ""
"このHaskellコードをC言語へjhcを使って変換するにはイカのコマンドだったでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:23
msgid "~~~ $ jhc -C -o Zen.c Zen.hs ~~~"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:25
msgid "さてさてどんなC言語になったでゲソか..."
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:30
msgid ""
"~~~ {.c} char jhc_c_compile[] = \"gcc /tmp/jhc_E8ju7C/rts/profile.c /tmp/"
"jhc_E8ju7C/rts/rts_support.c /tmp/jhc_E8ju7C/rts/gc_none.c /tmp/jhc_E8ju7C/"
"rts/jhc_rts.c /tmp/jhc_E8ju7C/lib/lib_cbits.c /tmp/jhc_E8ju7C/rts/gc_jgc.c /"
"tmp/jhc_E8ju7C/rts/stableptr.c -I/tmp/jhc_E8ju7C/cbits -I/tmp/jhc_E8ju7C Zen."
"c -o Zen.c '-std=gnu99' -D_GNU_SOURCE '-falign-functions=4' -ffast-math -"
"Wextra -Wall -Wno-unused-parameter -fno-strict-aliasing -DNDEBUG -O3 '-"
"D_JHC_GC=_JHC_GC_JGC'\"; char jhc_command[] = \"jhc -C -o Zen.c Zen.hs\"; "
"char jhc_version[] = \"jhc 0.8.1 (-0)\";"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:32
msgid "#include \"jhc_rts_header.h\""
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:39
msgid ""
"void jhc_hs_init(void) ; void _amain(void) ; static void b__main(gc_t gc) "
"A_STD; static void ftheMain(gc_t gc) A_STD; /* CAFS */"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:43
msgid "const void * const nh_stuff[] = { NULL };"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:49
msgid "void jhc_hs_init(void)  { }"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:55
#, no-wrap
msgid ""
"void \n"
"_amain(void)\n"
"{\n"
"        return (void)b__main(saved_gc);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:61
#, no-wrap
msgid ""
"static void A_STD\n"
"b__main(gc_t gc)\n"
"{\n"
"        return ftheMain(gc);\n"
"}\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:68
#, no-wrap
msgid ""
"static void A_STD\n"
"ftheMain(gc_t gc)\n"
"{\n"
"        return;\n"
"}\n"
"~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-19-jhc_zen.md:71
msgid ""
"この基本となるC言語コードの形に対して、 様々なHaskellコードが落されることなん"
"でゲソね。 なにか禅の世界を感じたでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2014-01-10-prosym55.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第10回 議事録\n"
"description: プロシンで宣伝しまくるでゲソー\n"
"tags: meeting, ajhc, mbed, android\n"
"---\n"
msgstr ""
"title: Metasepi team meeting #10\n"
"description: Let's promote Metasepi at the programming symposium!\n"
"tags: meeting, ajhc, mbed, android\n"
"---\n"

#. type: Plain text
#: posts/2014-01-10-prosym55.md:10
msgid ""
"Metasepi作戦会議 第10回を [「第55回プログラミング・シンポジウム」](http://"
"www.ipsj.or.jp/prosym/55/55CFA.html)  にて開催したでゲソ。"
msgstr ""
"We had \"Metasepi team meeting #10\" at\n"
"[Programming Symposium #55](http://www.ipsj.or.jp/prosym/55/55CFA.html)."

#. type: Plain text
#: posts/2014-01-10-prosym55.md:14
msgid ""
"ワシはこれまでソフトウェア開発者にはプロジェクトの宣伝をしてきたでゲソが、 ソ"
"フトウェア研究者には宣伝してこなかったでゲソ。 今年は研究ドメインへの宣伝を増"
"やすためにまずはプロシンに行ってみたのでゲソ。"
msgstr ""
"In the past, we have promoted Metasepi for software developers.\n"
"However, not for software researchers.\n"
"Then, I tried to join Programming Symposium for it."

#. type: Plain text
#: posts/2014-01-10-prosym55.md:19
msgid ""
"論文を2ページだけ書いたのでゲソ。 できればこのページにPDFへのリンクを貼りたい"
"のでゲソがまだ許可がおりていないでゲソ。。。 この論文は [\\@mzp](https://"
"twitter.com/mzp) 殿にかなり念入りな推敲をしてもらったじゃなイカ。 この場を通"
"じで感謝でゲッソ!"
msgstr ""
"I wrote a paper with only 2 pages.\n"
"This paper is reviewed by [\\@mzp](https://twitter.com/mzp) with meticulous care.\n"
"Thank's a lot, mzp!"

#. type: Plain text
#: posts/2014-01-10-prosym55.md:21
msgid "## 論文"
msgstr "## Paper (in Japanese)"

#. type: Plain text
#: posts/2014-01-10-prosym55.md:23
msgid "[「強い型によるOSの開発手法の提案」(pdf)](/doc/20140110_prosym55.pdf)"
msgstr ""

#. type: Plain text
#: posts/2014-01-10-prosym55.md:28
msgid ""
"![](/img/20140110_poster3.jpg)  ![](/img/20140110_poster2.jpg)  ![](/"
"img/20140110_poster1.jpg)"
msgstr "![](/img/20140110_poster3.jpg)  ![](/img/20140110_poster2.jpg)  ![](/img/20140110_poster1.jpg)"

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:5
#, no-wrap
msgid ""
"title: jhcユーザーズマニュアル日本語訳 (2013/03/16更新)\n"
"description: jhcの使い方を理解するでゲッソ!\n"
"tags: haskell, jhc, specification, translation\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:9
msgid ""
"アラフラで採用する予定のjhc、おおざっぱな使い方はわかっているのでゲソが細かい"
"ところは知らんでゲソ。 気になるのはGHCとの違いでゲソが、内部解析のための足掛"
"かりになるかもしれないので、使い方はしっかりマスターしておきたいでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:19
msgid ""
"しかし前々回の記事で紹介した [Jhc User's Manual](http://repetae.net/computer/"
"jhc/manual.html)  は当然のごとく英語...自然言語さえ苦手なワシには読めんでゲ"
"ソ。 そこで根性で日本語訳してみたでゲッソ! ^[後半の\"jhcコア型システム\"の章"
"の翻訳は [differential_engine (dif_engine)](https://twitter.com/dif_engine)  "
"さんに手伝ってもらったでゲッソ。感謝でゲソー] ざんねんながらワシには専門知識"
"が圧倒的に欠如しているので、用語のミスや根本的な間違いなどを見つけたら是非教"
"えて欲しいでゲソ。 この記事は翻訳の修正をするたびに随時更新するつもりでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:25
msgid ""
"この翻訳には [po4a](http://po4a.alioth.debian.org/)  を使っていて、gettextの"
"翻訳データは [po/ja.po - jhc-arafura in Metasepi - Gitorious](https://"
"gitorious.org/metasepi/jhc-arafura/blobs/feature/po4a/po/ja.po)  にあるので、"
"po4aとgitを使える人はpull requestを送ってくれるのも歓迎でゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:33
msgid ""
"_2013/03/16追記:_ Metasepi向けのjhcの開発は [Ajhc](http://ajhc.metasepi."
"org/)  で行なうことになったでゲソ。 Ajhcで追加された機能は [Ajhc User's "
"Manual](http://ajhc.metasepi.org/manual.html)  ([日本語訳](http://ajhc."
"metasepi.org/manual_ja.html))  を参照のこと、でゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:37
msgid "# Jhcユーザーズマニュアル - John Meacham"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:39
msgid "# 使い方"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:42
msgid "## プロジェクトをビルドする"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:46
msgid ""
"Jhcはソースコードの依存関係を独自に解析してくれるため、 コマンドラインか"
"ら'main'関数を含んだファイルを指定するだけでソースコード全体をコンパイルでき"
"る。 例えばソースコード'HelloWorld.hs'をコンパイルしたければ、次のようにコン"
"パイルすれば'hello'という名前の実行バイナリが生成される。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:48
#, no-wrap
msgid "    ; jhc HelloWorld.hs -o hello\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:55
msgid ""
"Jhcはサーチパスからモジュールを探す。 そのサーチパスは既定値ではカレントディ"
"レクトリである。 モジュールは名前にもとづいて検索される。 例えばData.Fooモ"
"ジュールは'Data/Foo.hs'もしくは'Data.Foo.hs'のパスから探されることになる。 こ"
"のサーチパスは'-i'コマンドラインオプションを使って指定できる。 ま"
"た、'JHC_PATH'環境変数を使って指定することもできる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:57
msgid "## ライブラリを使う"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:64
msgid ""
"jhcライブラリは、例えば'base-1.0.hl'のような、'hl'という拡張子を持つ単一の"
"ファイルである。 何かHaskellライブラリを使うためには、jhcの検索するディレクト"
"リにこのファイルを置くだけで良い。 例えば $HOME/lib/jhc などだ。 "
"JHC_LIBRARY_PATH環境変数を定義することで、別の位置をライブラリのサーチパスと"
"して指定することができる。 また、-Lコマンドラインオプションを使ってもサーチパ"
"スを指定できる。 さらに-L-オプションを使えばサーチパスの設定を既定値に戻すこ"
"とさえできる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:67
msgid ""
"'hl'ファイルが適切な位置に置かれていれば、'-p'コマンドラインオプションを使っ"
"て使用するライブラリを指定することができる。 例えば'mylibrary-1.0.hl'を既に"
"サーチパスに配置済みであれば、以下のように使うことができる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:69
#, no-wrap
msgid "    ; jhc -p mylibrary MyProgram.hs -o myprogram\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:73
msgid ""
"--list-librariesオプションを使えば全ての使用可能なライブラリのリストを得られ"
"る。 さらに'-v'オプションを追加することで、各ライブラリに関する詳細な情報を得"
"ることもできる。 これらの情報はYAMLフォーマットを使って生成されたものである。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:75
msgid "## 環境変数"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:77
msgid "Jhcの挙動はいくつかの環境変数によって制御される。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:79
msgid "JHC_OPTS : jhcのコマンドライン直後に挿入されるオプション群"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:81
msgid "JHC_PATH : モジュールの検索パス"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:83
msgid "JHC_LIBRARY_PATH : ライブラリの検索パス"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:86
msgid ""
"JHC_CACHE : jhcがキャッシュとして使用するディレクトリ。キャッシュはjhcのパ"
"フォーマンス向上にはかかせない。既定値は~/.jhc/cache。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:88
msgid "## Haskellライブラリをビルドする"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:91
msgid ""
"ライブラリは--build-hlオプションで指定されたライブラリファイルの内容にもとづ"
"いてビルドされる。 このライブラリファイルのフォーマットはYAMLである。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:93
#, no-wrap
msgid "    ; jhc --build-hl mylibrary.yaml\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:95
msgid "### ライブラリファイルのフォーマット"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:97
msgid ""
"ライブラリファイルはYAMLフォーマットで、jhcは自分の理解できるフィールドだけを"
"解釈し、残りは無視する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:99
msgid "Name : ライブラリの名前"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:102
msgid ""
"Version : ライブラリのバージョン。バージョン番号は'-p'コマンドラインオプショ"
"ンを使う際に区別するために使われる。しかし、それ以外の用途にはjhcは使わない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:105
msgid ""
"Exposed-Modules : ライブラリに含まれ、ライブラリの利用者への公開インターフェ"
"イスとなる一連のモジュール。この欄が他のライブラリ内のモジュールを含んでいた"
"場合、再度このライブラリでも公開インターフェイス扱いされることになる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:108
msgid ""
"Hidden-Modules : ライブラリ内部で使用されるかもしれないが、公開インターフェイ"
"スにはならない一連のモジュール。jhcはこの情報を元にして最適化を行なう。このリ"
"ストがライブラリのビルドに網羅的でなければ、jhcはワーニングメッセージを出力す"
"る。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:110
msgid ""
"Extensions : このモジュールをコンパイルするのに必要な拡張のリスト。jhcはでき"
"うるかぎりghc拡張と似た拡張を提供するつもりである。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:112
msgid "Options : ライブラリビルド時に使うその他のコマンドラインオプション"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:114
msgid ""
"Build-Depends : ビルドに必要になるライブラリ。'-p'コマンドラインオプションと"
"同じフォーマットで指定する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:117
msgid ""
"Hs-Source-Dirs : Haskellソースコードを探すディレクトリ。'-i'コマンドラインオ"
"プションと異なり、この欄にはライブラリ詳細を記載した.yamlファイルからの相対パ"
"スを記載する。'-i'オプションを使う際にはカレントワーキングディレクトリからの"
"相対パスを記載すること。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:120
msgid ""
"Include-Dirs : プリプロセッサが'-I'オプションで検索するディレクトリ。このディ"
"レクトリもyamlファイルが置かれたディレクトリからの相対パスとして指定するこ"
"と。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:122
msgid ""
"C-Sources : このライブラリを使うプログラムにリンクされるべきC言語ソースコード"
"ファイル群。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:125
msgid ""
"Include-Sources : このライブラリを使ったプログラムのビルドに必要なC言語のヘッ"
"ダを指定する。これらのヘッダはビルド時にincludeされることはあっても、実行ファ"
"イルにリンクされることはない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:127
msgid ""
"ライブラリファイルの例としてlib/jhc/jhc.yamlとlib/base/base.yamlを参考のこ"
"と。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:130
msgid "## 依存情報"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:135
msgid ""
"jhcは依存情報を出力できる。 この依存情報はソースコードとライブラリがコンパイ"
"ル時にその他の要素にどのように依存しているかを表現している。 依存情報は--"
"deps name.yamlオプションをjhcに入力するとname.yamlファイルに出力される。 この"
"依存情報もまたYAMLフォーマットで、各項目な以下のような意味を持っている。"
msgstr ""

#. type: Bullet: '  - '
#: posts/2013-01-12-jhc_manual_ja.md:140
msgid ""
"LibraryDeps: 依存しているライブラリ。使用しているライブラリのファイル名と同時"
"にハッシュ値も列挙する。"
msgstr ""

#. type: Bullet: '  - '
#: posts/2013-01-12-jhc_manual_ja.md:140
msgid ""
"LibraryDesc: ライブラリをビルドした際、この項目は使っているライブラリファイル"
"の名前を含む。"
msgstr ""

#. type: Bullet: '  - '
#: posts/2013-01-12-jhc_manual_ja.md:140
msgid "ModuleDeps: 直接依存しているモジュール名のリスト"
msgstr ""

#. type: Bullet: '  - '
#: posts/2013-01-12-jhc_manual_ja.md:140
msgid "ModuleSouce: 使用しているソースコードファイル名に対応するモジュール名"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:142
msgid "deps.yamlを扱うサンプルとして'utils/deps_to_make.prl'を参照のこと。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:144
msgid "# オプション"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:186
#, no-wrap
msgid ""
"    Usage: jhc [OPTION...] Main.hs\n"
"      -V                --version                 バージョン表示\n"
"                        --version-context         バージョン履歴表示\n"
"                        --help                    ヘルプメッセージ表示\n"
"                        --info                    コンパイラ設定表示\n"
"                        --purge-cache             コンパイルキャッッシュの削除\n"
"      -v                --verbose                 stderrに冗長なメッセージ表示\n"
"      -z                                          冗長な統計情報を表示\n"
"      -d [no-]flag                                コンパイルパイプラインの特定の情報をダンプ\n"
"      -f [no-]flag                                コンパイルフラグの有効/無効\n"
"      -X ExtensionName                            言語拡張の有効化\n"
"      -o FILE           --output=FILE             出力ファイル名を指定\n"
"      -i DIR            --include=DIR             ソースファイル検索パス\n"
"      -I DIR                                      プリプロセッサのインクルードパスを追加\n"
"      -D NAME=VALUE                               プリプロセッサに渡すdefineを追加\n"
"                        --optc=option             Cコンパイラに渡すその他のオプション\n"
"      -c                                          モジュールを単体でコンパイル\n"
"      -C                                          C言語コードへコンパイル\n"
"      -E                                          ソースコードをプリプロセッサにかけてstdoutへ出力\n"
"      -k                --keepgoing               エラーを無視してコンパイルを続行\n"
"                        --cross                   クロスコンパイルを有効に、-mオプションでターゲットを指定すること\n"
"                        --stop=parse/typecheck/c  parse/typecheck/cの直後で停止する\n"
"                        --width=COLUMNS           デバッグ出力のスクリーン幅を変更\n"
"                        --main=Main.main          mainエントリポイントを指定\n"
"      -m arch           --arch=arch               クロスコンパイルターゲットを指定\n"
"                        --entry=<expr>            mainエントリポイントを式を使って指定\n"
"                        --show-ho=file.ho         hoファイルの概要をダンプ\n"
"                        --noauto                  haskell98パッケージを自動的に読み込まない\n"
"      -p package                                  指定したライブラリを使用する\n"
"      -L path                                     ライブラリを指定したパスから検索する\n"
"                        --build-hl=desc.yaml      指定したライブラリファイルからHaskellライブラリをビルド\n"
"                        --annotate-source=<dir>   指定したディレクトリにプリプロセス済みソースコードを出力\n"
"                        --deps=<file.yaml>        依存情報を指定したファイルに書き込む\n"
"                        --interactive             インタラクティブ実行                                                     (デバッグ用途)\n"
"                        --ignore-cache            コンパイルキャッシュを無視する\n"
"                        --readonly-cache          コンパイルキャッシュに追加情報を書き込まない\n"
"                        --no-cache                コンパイルキャッシュを使わず、書き込みも行なわない\n"
"                        --cache-dir=JHC_CACHE     指定したディレクトリをコンパイルキャッシュとして使う\n"
"                        --stale=Module            指定したモジュールがコンパイルキャッシュにあっても古い情報として扱う\n"
"                        --list-libraries          インストール済みライブラリを表示\n"
"                        --tdir=dir/               中間生成物を出力するディレクトリを指定する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:195
#, no-wrap
msgid ""
"    -dオプションの引数: '-d help'オプションで詳細\n"
"        all-types, aspats, atom, bindgroups, boxy-steps, c, class, class-summary, core, core-afterlift\n"
"        core-beforelift, core-initial, core-mangled, core-mini, core-pass, core-steps, datatable\n"
"        datatable-builtin, dcons, decls, defs, derived, e-alias, e-info, e-size, e-verbose, exports, grin\n"
"        grin-datalog, grin-final, grin-graph, grin-initial, grin-normalized, grin-posteval, grin-preeval\n"
"        imports, ini, instance, kind, kind-steps, optimization-stats, parsed, preprocessed, program\n"
"        progress, renamed, rules, rules-spec, scc-modules, sigenv, srcsigs, stats, steps, tags, the\n"
"        types, verbose, veryverbose\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:201
#, no-wrap
msgid ""
"    -fオプションの引数: '-f help'オプションで詳細\n"
"        bang-patterns, boehm, controlled, cpp, debug, default, defaulting, exists, ffi, forall, full-int\n"
"        glasgow-exts, global-optimize, inline-pragmas, jgc, lint, m4, monomorphism-restriction, negate\n"
"        prelude, profile, raw, rules, standalone, type-analysis, type-families, unboxed-tuples\n"
"        unboxed-values, user-kinds, wrapper\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:205
msgid "## コードオプション"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:208
msgid ""
"jhcの解釈やコンパイルは'-f'フラグでコントロールできる。 これらのオプションを"
"以下に列挙する。また、その効力は'no-'をフラグ名に付けることで無効化できる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:223
#, no-wrap
msgid ""
"コードオプション\n"
"------                    ---------------------------------------------------------------------------\n"
"_bang-patterns_           - バン！パターン(強制正格評価パターン)\n"
"_cpp_                     HaskellコードをCプリプロセッサにかけてからコンパイル\n"
"_exists_                  - existsキーワードを存在型の解釈に使う\n"
"_ffi_                     他言語関数インタフェース(FFI)を使う\n"
"_forall_                  - forallキーワードをランクN多相と明白な量化に用いる\n"
"_m4_                      Haskellコードをm4プリプロセッサにかけてからコンパイル\n"
"_prelude_                 Preludeを暗黙の内にimportする\n"
"_type-families_           Type Families(型族)を使う\n"
"_unboxed-tuples_          アンボックス化タプル文法を許容する\n"
"_unboxed-values_          アンボックス化値文法を許容する\n"
"_user-kinds_              ユーザ定義の種を使う\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:228
#, no-wrap
msgid ""
"型検査\n"
"------                    ---------------------------------------------------------------------------\n"
"_defaulting_              型のデフォルト化を行なう\n"
"_monomorphism-restriction_ 単相性制限を強制する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:232
#, no-wrap
msgid ""
"デバッグ\n"
"------                    ---------------------------------------------------------------------------\n"
"_lint_                    より多くの型検査を行なう\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:239
#, no-wrap
msgid ""
"最適化オプション\n"
"------                    ---------------------------------------------------------------------------\n"
"_global-optimize_         Eによってプログラム全体を最適化する\n"
"_inline-pragmas_          inlineプラグマを使う\n"
"_rules_                   rulesプラグマを使う\n"
"_type-analysis_           メソッド生成直後に型に対する基本的なpoints-to analysisを適用する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:250
#, no-wrap
msgid ""
"コード生成\n"
"------                    ---------------------------------------------------------------------------\n"
"_boehm_                   Boehm GCを使う\n"
"_debug_                   実行バイナリ中のデバッグコードを有効に\n"
"_full-int_                32bitマシンでIntとWordを32bitに拡張する\n"
"_jgc_                     jgcガーベッジコレクタを使う\n"
"_profile_                 実行バイナリ中のプロファイルコードを有効に\n"
"_raw_                     main関数をWHNFとして評価する\n"
"_standalone_              単独実行可能にコンパイル\n"
"_wrapper_                 main関数を例外ハンドラで包む\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:255
#, no-wrap
msgid ""
"設定既定値\n"
"------                    ---------------------------------------------------------------------------\n"
"_default_                 inline-pragmas rules wrapper defaulting type-analysis monomorphism-restriction global-optimize full-int prelude\n"
"_glasgow-exts_            forall ffi unboxed-tuples\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:258
msgid "## デバッグ情報のダンプ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:261
msgid ""
"'-d'フラグ付きでjhcを起動することで各種パラメータを出力できる。 次に挙げるの"
"は'-d'フラグに渡すことができるパラメータのリストである。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:274
#, no-wrap
msgid ""
"フロントエンド\n"
"------                    ---------------------------------------------------------------------------\n"
"_defs_                    モジュール内で定義された名前を列挙する(?)\n"
"_derived_                 自動導出されたインスタンスを表示する\n"
"_exports_                 モジュールからエクスポートされている名前を列挙する\n"
"_imports_                 モジュールがインポートしている名前を列挙する\n"
"_ini_                     iniファイルのオプションを表示\n"
"_parsed_                  パース済みコードを出力\n"
"_preprocessed_            プリプロセス後のコードを出力\n"
"_renamed_                 renaming後のコードを出力\n"
"_scc-modules_             強結合したモジュールを依存度順に表示\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:292
#, no-wrap
msgid ""
"型検査\n"
"------                    ---------------------------------------------------------------------------\n"
"_all-types_               型検査完了後に型テーブルを表示\n"
"_aspats_                  アズパターンを表示\n"
"_bindgroups_              束縛グループを表示\n"
"_boxy-steps_              型推論の挙動をステップバイステップで表示\n"
"_class_                   個々の型クラスの詳細情報を表示\n"
"_class-summary_           型クラス群の概要を表示\n"
"_dcons_                   データコンストラクタを表示\n"
"_decls_                   処理済みの宣言を表示\n"
"_instance_                インスタンスを表示\n"
"_kind_                    モジュールへの種推論の結果を表示\n"
"_kind-steps_              種推論のステップを表示\n"
"_program_                 プログラム全体の構造\n"
"_sigenv_                  型シグニチャ初期状態の表示\n"
"_srcsigs_                 renaming後の型シグニチャを表示\n"
"_types_                   定義された全ての名前を含んでいる型テーブルを表示\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:312
#, no-wrap
msgid ""
"中間コード\n"
"------                    ---------------------------------------------------------------------------\n"
"_core_                    core言語コードを表示\n"
"_core-afterlift_          hoファイルに書き込む直前のcoreコードを表示\n"
"_core-beforelift_         lambda lifting直前のcoreコードを表示\n"
"_core-initial_            E.FromHs転換直前のcoreコードを表示\n"
"_core-mangled_            grinにかける前の型なしcoreコードを表示\n"
"_core-mini_               個々の関数の最適化の詳細を表示\n"
"_core-pass_               コード変形の経過を表示\n"
"_core-steps_              コンパイルパスそれぞれのステップについて表示\n"
"_datatable_               コンストラクタのデータテーブルを表示\n"
"_datatable-builtin_       ビルドイン型のデータテーブルを表示\n"
"_e-alias_                 展開済みエイリアスを表示\n"
"_e-info_                  束縛された値のタグ情報を表示\n"
"_e-size_                  コンパイルパスそれぞれでのEのサイズを表示\n"
"_e-verbose_               Eコードに冗長なメッセージを表示させる\n"
"_optimization-stats_      最適化パスのスタティクスを表示\n"
"_rules_                   ユーザ定義の書き換え規則を表示する\n"
"_rules-spec_              特殊化書き換え規則を表示する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:325
#, no-wrap
msgid ""
"Grinコード\n"
"------                    ---------------------------------------------------------------------------\n"
"_grin_                    grinコードを表示する\n"
"_grin-datalog_            データベースに適したフォーマットでgrinの情報を印字する\n"
"_grin-final_              C言語への変換直前のgrinコードを表示\n"
"_grin-graph_              最終的なgrinコードをdotファイルをoutputname_grin.dotに出力する\n"
"_grin-initial_            core言語から変換された直後のgrinコード\n"
"_grin-normalized_         最初の正規化を行なった直後のgrinコード\n"
"_grin-posteval_           eval/applyインライン化直後のgrinコード\n"
"_grin-preeval_            eval/applyインライン化直前のgrinコード\n"
"_steps_                   インタープリタの実行を表示\n"
"_tags_                    タグと型を列挙する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:329
#, no-wrap
msgid ""
"バックエンドコード\n"
"------                    ---------------------------------------------------------------------------\n"
"_c_                       コンパイル時に生成したC言語ソースファイルを削除しない\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:333
#, no-wrap
msgid ""
"内部\n"
"------                    ---------------------------------------------------------------------------\n"
"_atom_                    終了時にatomテーブルをダンプする\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:340
#, no-wrap
msgid ""
"一般\n"
"------                    ---------------------------------------------------------------------------\n"
"_progress_                通常のプログレス表示を行なう\n"
"_stats_                   その他の情報を表示する\n"
"_verbose_                 冗長なプログレス表示\n"
"_veryverbose_             スタティクスを含む冗長なプログレス表示\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:342
msgid "# プラグマ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:348
msgid ""
"プラグマは特別なコンパイラへの指示で、コンパイラの挙動に特定の影響を与える。 "
"一般的には、コンパイラは自由に独自のプラグを定義できる。 しかしjhcでは他のコ"
"ンパイラでも使われているものを実装しようと努めている。 プラグマはソースコード"
"中で {-# PRAGMANAME ... #-} のような形式で使われる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:350
msgid "## 関数の属性"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:354
msgid ""
"これらのプラグマは関数定義のあるファイルと同じファイル中に記述すべき。 インス"
"タンスやクラスの関数に適用するためには、 これらのプラグマをインスタンスやクラ"
"スの宣言の節に配置しなければならない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:361
#, no-wrap
msgid ""
"プラグマ\n"
"------             ----------------------------------------------------\n"
"_NOINLINE_         core変形中のインライン化を抑制する。当該関数はgrin変形中にインライン化される _かもしれない_ 。\n"
"_INLINE_           可能であれば関数をインライン化する\n"
"_SUPERINLINE_      関数本体を単に複製することになったとしても、とにかくインライン化を行なう\n"
"_VCONSTRUCTOR_     関数を仮想コンストラクタとして扱う。CPR解析とworker/wrapper変換は関数をコンストラクタとして扱うことがある。これは'NOINLINE'で実装される。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:363
msgid "## クラスプラグマ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:367
#, no-wrap
msgid ""
"プラグマ\n"
"------             ---------------------------------------------------\n"
"_NOETA_            デフォルトではjhcは最適化のために全てのクラスメソッドをイータ変換する。このプラグマはこの挙動を無効化する\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:369
msgid "## 書き換え規則と特殊化"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:376
#, no-wrap
msgid ""
"プラグマ\n"
"------              ---------------------------------------------------\n"
"_RULES_             書き換え規則。GHCの書き換え規則と同様の構文で同様の振舞いをする。ただし、'phase'を使うことはできない。\n"
"_CATALYST_          特殊な書き換え規則で、他のRULESの使用中でのみ発火する。そのためCATALYSTは最良でない中間ステージを要求する最適化を許す。\n"
"_SPECIALIZE_        指定された型で特殊化された関数を生成する\n"
"_SUPERSPECIALIZE_   SPECIALIZEと同じ効力がある。しかし一般化された関数にて特殊化された呼び出しかどうかランタイムでの検査を行なう。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:378
msgid "## 型プラグマ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:387
#, no-wrap
msgid ""
"プラグマ\n"
"------             ---------------------------------------------------\n"
"_CTYPE_            FFIでdataもしくはnewtypeを使うたえに、外部の型を指定する。\n"
"                   この型はnewtypeかforeign宣言された型の単項コンストラクタでなければならない。\n"
"                   例えば\n"
"                   ~~~\n"
"                   data {-# CTYPE \"unsigned short\" #-} CUShort = CUShort Word16\n"
"                   ~~~\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:389
msgid "## ヘッダプラグマ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:394
msgid ""
"これらのプラグマはファイルの'先頭'でのみ有効である。 つまりこれらは最初"
"の'module'宣言の前に置かれなければならず、 ファイルの先頭4096バイト以内に配置"
"されねばらなず、 そしてASCII文字セットのみしか使ってはならない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:398
msgid ""
"OPTIONS_JHC : その他のオプションを指定する。これらのオプションはコマンドライ"
"ンオプションとしても利用できるが、単一のファイルにのみ影響を与えたい場合に重"
"宝する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:400
msgid "LANGUAGE : 言語拡張のオプションを指定する"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:402
msgid "# 拡張"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:405
msgid "## モジュールのサーチパス"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:409
msgid ""
"他のHaskellコンパイラと同じように、jhcでのモジュールはその名前にもとづいて検"
"索される。 'Data.Foo'モジュールを検索するとjhcは'Data/Foo.hs'ファイルも検索す"
"るが、 'Data.Foo.hs'も同じく検索対象になる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:412
msgid "## FFIへの拡張"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:414
msgid "### 複数の返値をともなうforeign import"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:420
msgid ""
"foreign C importは複数の値を返すことがある。 このような場合、アンボックス化タ"
"プルを返値として使う。 最初の返値は関数から直接返された値であり、 残りは関数"
"の引数リストの終端へのポインタが返ってくる。 純粋な(IOではない)関数でのみ複数"
"の値を返値として使うことができる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:427
msgid ""
"~~~~ -- frexpはC言語のプロトタイプ宣言として -- double frexp(double x, int "
"*exp); -- を持つ。そのため、IOとして通常のimportをすることができ、 -- 他の純"
"粋な関数へ渡すにはStorableを使うことになる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:430
msgid ""
"foreign import ccall \"math.h frexp\" c_frexp :: Double -> Ptr CInt -> IO "
"Double"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:433
msgid ""
"-- この拡張を使うと以下のように宣言できる。 foreign import ccall \"math.h "
"frexp\" c_frexp2 :: Double -> (# Double, CInt #)"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:437
msgid ""
"-- 二番目の返値は最後の'exp'パラメータによって追加されて、アロケートされた "
"-- メモリから読み出される。関数に渡されるメモリの内容は未定義である。 ~~~~"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:439
msgid "### 呼び出し規約'capi'"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:445
msgid ""
"呼び出し規約'capi'は'ccall'を使ってたimportのかわりに使われる。 この規約を使"
"うことで、foreignする対象はアドレス空間に実体がなくても良い。 マクロやビルド"
"イン関数もしくはその他コンパイラ独自の機能であっても良い。 jhcはルーチンが決"
"してポインタとしては使用されないこと、依存するヘッダをインクルードすること保"
"証する。 これは'ccall'と異なる。ccallはヘッダがスコープに入っているか、正しい"
"名前のリンカのためのシンボルがエクスポートされているか、なんの保証もしない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:447
msgid "### パッケージに関連した依存"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:451
msgid ""
"p:foo.c や p:foo.h と書かれたforeign importはそのファイルがパッケージ内部実装"
"の一部として解釈されることを意味している。 jhcはそれらのファイルが同じ名前を"
"持っていても他のパッケージと衝突しないことを保証する。 それらのファイルはライ"
"ブラリファイルのc-filesとc-headersの項目に列挙されるべきである。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:453
msgid "## import/exportされる名前空間"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:456
msgid ""
"jhcはimportやexportする際の名前空間を持つ。 これらはimport/export宣言によって"
"制限されたり修正されたりする。"
msgstr ""

#. type: Bullet: '    * '
#: posts/2013-01-12-jhc_manual_ja.md:461
msgid ""
"'type' - 名前が型シノニムであり、'type'や'newtype','data',種宣言のコンストラ"
"クタで定義されている"
msgstr ""

#. type: Bullet: '    * '
#: posts/2013-01-12-jhc_manual_ja.md:461
msgid "'class' - 名前がクラスであることを指定"
msgstr ""

#. type: Bullet: '    * '
#: posts/2013-01-12-jhc_manual_ja.md:461
msgid "'data' - 名前がデータコンストラクタであることを指定"
msgstr ""

#. type: Bullet: '    * '
#: posts/2013-01-12-jhc_manual_ja.md:461
msgid "'kind' - 名前がユーザ定義の種であることを指定"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:464
msgid ""
"型クラスと型シノニムは独立した名前空間にあるので、 同じ名前の型シノニムと型ク"
"ラスが同じスコープに存在しても問題ない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:466
msgid "## ユーザ定義された種"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:469
msgid ""
"-fuser-kindsオプションが有効な場合、jhcはユーザ定義の種を使用可能にする。 そ"
"の文法は:"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:473
msgid "~~~~ data kind Nat = Z | S Nat ~~~~"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:477
msgid ""
"ここでは新しい種'Nat'と、その種に存在する2つの型'Zと'S'を定義している。 これ"
"らの型は値を持たないアンボックス化された値として表現された種の宣言によって定"
"義されている。 そのためこれらはランタイムでの表現を持たない。(当然、⊥でさえな"
"い)"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:479
msgid "## 独立deriving"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:481
msgid "jhcはある環境下にて独立derivingをサポートする。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:483
msgid "## ランクN多相性"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:487
msgid ""
"jhcは高ランク多相性をサポートする。 文脈が高ランク多相型を明確に指定しても、"
"jhcは高ランクの型推論を行なわない。 例えば、型注釈と多相として定義されたデー"
"タコンストラクタへの引数を与えれば、正しい多相型が手に入る。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:489
msgid "## 存在型"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:493
msgid ""
"jhcはファーストスラスの存在型をサポートする。 それは'exists'キーワードで使用"
"できる。 また存在データ型はghcと似た方法でサポートしている。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:495
msgid "## アンボックス化された値"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:503
msgid ""
"jhcでのアンボックス化された値はGHCと同様に指定できる。 ただし、# をその識別子"
"としては使用しない。 各種アンボックス化されたコンストラクタのための構文とし"
"て # はまだ使われているが、 通常のHaskellのルールをがHaskellの識別子に使われ"
"る。 コンベンションとして'_'の接尾辞の付いた型はアンボックス化された状態にあ"
"ることを示している。 アンボックス化タプル以外の全てのアンボックス化された値"
"は、-funboxed-valueフラグによって有効になる。 GHCとの互換性のため、MagicHash"
"拡張でもアンボックス化型を有効にできる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:505
msgid "### アンボックス化タプル"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:510
msgid ""
"jhcはGHCと同じ文法でアンボックス化タプルをサポートする。(# 2, 4 #) は2つの数"
"値を持つアンボックス化タプルである。 アンボックス化タプルは-funboxed-tuplesオ"
"プションによって有効にできる。 アンボックス化タプルは種多相であり、ボックス化"
"とアンボックス化の両方おん値を保持することができる。 (しかし他のアンボックス"
"化タプルを保持することはできない)"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:512
msgid "### アンボックス化文字列"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:516
msgid ""
"アンボックス化文字列は-funboxed-valuesフラグによって有効になる。 通常の文字列"
"と異なり、その名前は'#'で終わる。 アンボックス化文字列は'BitsPtr_'型である。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:518
msgid "### アンボックス化文字"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:521
msgid ""
"アンボックス化文字は通常の文字リテラルの後に # を付けて表現する。 アンボック"
"ス化文字はChar_型であり、さらにJhc.Prim.Bitsに定義のあるBits32_のnewtypeでも"
"ある。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:523
msgid "### アンボックス化数値"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:532
msgid ""
"アンボックス化数値は-funboxed-valuesフラグによって有効になる。 それらは 3# "
"や 4# のように'#'を付けて表現する。 もし型が環境によって完全に指定されてて、"
"かつそれが適切なアンボックス化数値型であるなら、jhcは型推論を限定的にサポート"
"する。 そうでない場合にはInt__をデフォルトとして使用する。 型が完全に指定され"
"ているかどうかにかかわらず、ランクN型として同じルールが適用される。 アンボッ"
"クス化数値は列挙可能である。 そのため 0# はアンボックス化されたFalse値として"
"使うことができる。 そして型推論も行なわれる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:534
msgid "### アンボックス化された値の取り扱い"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:545
msgid ""
"アンボックス化値を取り扱うために、適切なプリミティブの演算子をスコープ内に用"
"意する必要がある。 プリミティブのimportのために特殊なFFI宣言を使うことができ"
"る。 全てのC--プリミティブはユーティリティ関数と同様にimportできる。 プリミ"
"ティブimportはのしくみは'スマート'で、newtype宣言を通りぬけ、ボックス化/アン"
"ボックス化値が必要か面倒をみてくれる。 だからあなたがプリミティブをCharに"
"importしたなら、 それが'Char'コンストラクタをボックス化されていると認識し、 "
"Char_がBits32_のnewtypeであることも認識してくれる。 そして遂には正しいBits32_"
"プリミティブを選択してくれるのだ。 importされたプリミティブは通常のHaskell宣"
"言である。 だからモジュールからexport/importできるし、通常の高階関数としても"
"扱える。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:548
msgid "## Foreignプリミティブ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:554
msgid ""
"FFIの仕様であるforeign importに加えてjhcは'primitive' importをサポートしてい"
"て、 あなたはこれを用いてコンパイラと直接通信することができる。 一般的にこれ"
"らは基盤ライブラリの実装以外の用途に使われるべきではない。 一般にこれらは少な"
"いエラーチェックしか行なわない。 jhc内では、すべてのHaskellのエントリは"
"foreign宣言によって形づくられている。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:556
msgid "それらは以下の形を取る。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:558
#, no-wrap
msgid "    foreign import primitive \"specification\" haskell_name :: type\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:560
msgid "\"specification\"には以下を選択できる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:562
msgid "seq : 最初の引数をWHNFとして評価し、二番目の引数を返す"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:564
msgid "zero,one : 0か1の値をプリミティブ型に使う"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:566
msgid ""
"const.C_CONSTANT : constに続くテキストをコンパイル結果のC言語ソースコードに直"
"接埋め込む"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:568
msgid "peek.TYPE : TYPE型の値の読み込みプリミティブ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:570
msgid "poke.TYPE : TYPE型の値の書き込みプリミティブ"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:573
msgid ""
"sizeOf.TYPE, alignmentOf.TYPE, minBound.TYPE, maxBound.TYPE, umaxBound."
"TYPE : 内部型TYPEの各種属性"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:575
msgid "error.MESSAGE : results in an error with constant message MESSAGE."
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:577
msgid ""
"constPeekByte : 指定したバイト数、定数値を読み込み、Jhc.Stringとして使う"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:579
msgid ""
"box : アンボックス化値を取り、それをボックス化する。ボックス化された形は"
"importされた型によって決まる"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:581
msgid ""
"unbox : ボックス化値を取り、アンボックス化する。ボックスの形はimportされた型"
"によいって決まる"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:583
msgid "increment, decrement : 整数のプリミティブ値を増減させる"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:585
msgid "fincrement, fdecrement : 浮動小数点のプリミティブ値を増減させる"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:587
msgid "exitFailure__ : プログラムを即時abortさせる"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:589
msgid "C-- Primitive : C--プリミティブはこの作法でimportする"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:592
msgid "# 差異"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:595
msgid "## Haskell 98との違い"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:597
msgid "### 言語差分"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-01-12-jhc_manual_ja.md:599
msgid "データタイプ内のクラス文脈は単に無視される。"
msgstr ""

#. type: Bullet: '* '
#: posts/2013-01-12-jhc_manual_ja.md:603
msgid ""
"クラスメソッドはイータ変換されて引数の数は型によって指定される。 部分適用する"
"ことがめったにないインスタンスではこれはしばしば有益だ。 この挙動はNOETAプラ"
"グマによって無効にできる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:605
msgid "### ライブラリへの変更"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:609
msgid ""
"GHCのbaseにおおざっぱに沿ったbaseライブラリに加えて、 jhcはいくつかの拡張とマ"
"イナーな修正を標準ライブラリに施している。 これらは大部分は後方互換性とクラス"
"システムのためにデザインされている。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:616
#, no-wrap
msgid ""
"* Data.Bits\n"
"    * NumはData.Bitsのスーパークラスではない。\n"
"    * logicalShiftRとarithmeticShiftR関数を追加した。それぞれ論理的、算術的なシフトを行なう。\n"
"    * shiftRとshiftL関数は負の引数をチェックしない。\n"
"      もし負の引数を使うならば一般的な'shift'ルーチンを使うこと。\n"
"      'shift'にはまた論理的と算術的なバリエーションがある。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:619
msgid "### ライブラリの追加"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:622
msgid ""
"jhcはその他多くの追加ライブラリを提供している。 ここではHaskell98もしくはFFI"
"の仕様で定義されているモジュールに影響する変更だけを挙げるにとどめる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:625
#, no-wrap
msgid ""
"* Data.IntとData.Wordは左記を提供するWordPtr, WordMax, IntPtr, IntMax。\n"
"   これらはそれぞれC言語のuintptr_t, uintmax_t, intptr_t, intmax_t型に該当する。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:628
#, no-wrap
msgid ""
"* IntegerとRationalクラスの実装近くのにfromInt,toInt,fromDouble,toDouble\n"
"   が追加された。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:632
#, no-wrap
msgid ""
"* 浮動小数点の切り捨てと丸める関数に相違がある。\n"
"   それらは整数型を返さず、引数と同じ型をかわりに返す。\n"
"   これらの関数名には'f'という接尾辞が付いている。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:634
msgid "## GHCとの注目すべき差異"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:636
msgid "jhcはHaskell 98には準拠しているがGHCとの差異がある。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:640
msgid ""
"Intは30ビットしか保持せず、切り捨ては検知できない。 もし数値にビット幅とバイ"
"ナリの意味論が必要な場合、Data.IntかData.Wordの型を使用すること。 IntやWordが"
"あふれた場合の結果は未定義である。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:643
msgid ""
"文字はUnicode幅の値しか保持できない。 そのため0x10FFFFより多きな保存されてい"
"る値は未定義な結果をもたらす。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:645
msgid ""
"例え64ビットアーキティクチャ上でもIntとWord型は最大でも32ビット幅である。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:650
msgid ""
"テキストベースのIOは現在のロケールで実行される。 つまりUnicodeについてはうま"
"く使用できるが、 IOが8ビット文字を仮定する古いプログラムは異常なふるまいにな"
"る。 もしバイナリのIOが必要であれば、バイナリのルーチンを明示的に使うこと。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:653
msgid "## 仕様の欠陥"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:655
msgid "これらの仕様の欠陥は将来修正される予定である。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:658
msgid ""
"Integer型は任意精度型ではなく、IntMax型と同じ精度である。 適切な任意精度ライ"
"ブラリが見つかれば、この問題は修正されるだろう。"
msgstr ""

#. type: Bullet: ' * '
#: posts/2013-01-12-jhc_manual_ja.md:660
msgid "Ix型は自動導出できない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:663
msgid "# クロスコンパイル"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:666
msgid "## 基本"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:673
msgid ""
"他の多くのコンパイラと異なり、jhcは生来のクロスコンパイラである。 これが意味"
"することは、jhcによるコンパイルによって、どんなターゲットシステムのためのコー"
"ドも生成できるということである。 これにより、jhcを利用したクロスコンパイルが"
"非常に簡単になる。 基本的には、クロスコンパイルを行うためにはjhcに '--cross' "
"フラグと、 ターゲットマシンを指定するオプション '-m'を渡せば良い。 以下がその"
"例である。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:675
#, no-wrap
msgid "    ; jhc --cross -mwin32 test/HelloWorld.hs\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:677
msgid ""
"targets.iniファイルに以下のような表記を追加すれば、ターゲットのリストを拡張で"
"きる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:679
msgid "## targets.ini"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:682
msgid ""
"このファイルは利用可能なターゲットを列挙する。 フォーマットは以下のエントリか"
"ら成り立っている。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:688
#, no-wrap
msgid ""
"    [targetname]\n"
"    key1=value\n"
"    key2=value\n"
"    key3+=value\n"
"    merge=targetname2\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:692
msgid ""
"mergeは特別なキーで他のターゲットから現在のターゲットへ内容をマージしているこ"
"とを意味する。 設定ファイルは先頭から順に読み込まれ、 与えられたキーに対応す"
"る最後の値が実際に使われる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:694
msgid "次に示すのはWindowsクロスコンパイルの例である:"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:700
#, no-wrap
msgid ""
"    [win32]\n"
"    cc=i386-mingw32-gcc\n"
"    cflags+=-mwindows -mno-cygwin\n"
"    executable_extension=.exe\n"
"    merge=i686\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:706
msgid ""
"上記は一般のi686設定を使って少々の他のオプションをコンパイラに設定している。 "
"特別なターゲットである[default]は常に他のターゲットより先に読み込まれる。 も"
"しコマンドラインから'--cross'が指定されたら暗黙にこの設定を読み込む。 さもな"
"ければjhcは現アーキティクチャをコンパイル対象としてみなして、 defaultに追加し"
"て適切なターゲットを選択する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:709
msgid ""
"jhcは複数のtargets.iniファイルを順に読み込もう試みる。 それらのファイルは以下"
"である。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:712
msgid ""
"$PREFIX/etc/jhc-\\$VERSION/targets.ini : このtargets.iniファイルはjhcによって"
"読み込まれ、既定のオプションを含む。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:715
msgid ""
"$PREFIX/etc/jhc-\\$VERSION/targets-local.ini : jhcは存在すればこのファイルを"
"読み込む。このファイルはローカルのコンパイラのようなシステムグローバルのカス"
"タム設定を含む。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:717
msgid "$HOME/.jhc/targets.ini : ユーザローカルの設定"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:719
msgid ""
"$HOME/etc/jhc/targets.ini : このファイルは隠し属性のディレクトリを嫌う人向け"
"のものである"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:723
msgid ""
"オプションについて有効とみなされるのは最後の値である。 ユーザ定義のローカル設"
"定はシステムグローバルのローカル設定を上書きする。 またシステムグローバルの"
"ローカル設定は組み込みのオプションを上書きする。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:725
msgid "## 利用可能なオプション"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:741
#, no-wrap
msgid ""
"オプション                意味\n"
"------                    ---------------------------------------------------------------------------\n"
"_cc_                      Cコンパイラを指定。一般に手元でのコンパイルにはgccを指定し、クロスコンパイルには$ARCH-$HOST-gccを指定する。\n"
"_byteorder_               リトル/ビッグエンディアンのために *le* もしくは *be* を指定する\n"
"_gc_                      GCを使う。*static* もしくは *boehm* を指定する。\n"
"_cflags_                  Cコンパイラに渡すオプション\n"
"_cflags\\_debug_           デバッグが有効な場合のにみCコンパイラに渡すオプション\n"
"_cflags\\_nodebug_         デバッグが無効な場合のにみCコンパイラに渡すオプション\n"
"_profile_                 プロファイルコードを実行バイナリに出力する\n"
"_autoload_                自動読み込みされるHaskellライブラリを指定。コンマで区切る。\n"
"_executable\\_extension_   実行バイナリファイルの拡張子を指定する (すなわちWindowsでは.EXEとなる)\n"
"_merge_                   他の設定ターゲットの内容を現ターゲットにマージする特別なオプション\n"
"_bits_                    このアーキティクチャでポインタが保有するビット数\n"
"_bits\\_max_               整数型の最大値が保有するビット数。これは'intmax_t'のC言語型と同じビット数でなければならない。\n"
"_arch_                    gccに渡すアーキティクチャ名\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:744
msgid "# 内部設計"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:747
msgid "## ランタイムシステム"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:753
msgid ""
"jhcは強いミニマリストであり、あらかじめコンパイルされたランタイムを持たな"
"い。 ランタイムはコンパイル時に必要になった際に生成される。 けれどもバックエ"
"ンドは、GCの選択のように、ランタイム特定のデータ表現を持つ。 C言語ベースの"
"バックエンドのための一般レイアウトを次に示す。 しかしGC種別のようなコンパイラ"
"オプションやプログラム全体解析は、どの機能が使われて、最適化されたレイアウト"
"が使用できるかに影響を及ぼす。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:760
msgid ""
"アンボックス化値はターゲットの言語の値に直接翻訳される。 アンボックス化Intは"
"引数として直接'int'に翻訳される。 またアンボックス化ポインタは生のポインタに"
"なる。 アンボックス化値は特別な解釈を持たず、 _GCは面倒をみてくれない_ 。 も"
"しターゲットの言語が複数返値のような機能をサポートしていない場合、シミュレー"
"ションする必要がある。 grinコードが複数返値が補強されたC--もしくはCへの同型と"
"してのみアンボックス化値を取り扱うのは悪い考えではない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:767
msgid ""
"ボックス化された値は標準の表現を持っている。 他の実装と異なり、ボックス化され"
"ることがオブジェクトがヒープに配置されることを意味しない。 それはスタックや"
"ヒープに確保されるかもしれない。 さらにはスマートポインタの中に組み込まれてい"
"るかもしれない。 ボックス化されていることはオブジェクトがスマートポインタに"
"よって表現されているか、 実際には伝統的なポインタであるかもしれないのだ。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:772
msgid ""
"jhcにおけるボックス化された値はC言語型のsptr_tという'スマートポインタ'であ"
"る。 スマートポインタは通常のポインタと同じサイズを持つが、 1つのペアのタグ"
"ビットで表わされる別の役割もおっている。 それはptypeと呼ばれる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:774
msgid "スマートポインタは一般に以下の形をしている:"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:778
#, no-wrap
msgid ""
"    -------------------------\n"
"    |    payload        | GL|\n"
"    -------------------------\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:781
#, no-wrap
msgid ""
"      G - セットされると、GCは値をポインタとして取り扱わない\n"
"      L - 遅延。このビットがセットされると値はWHNFではないことを示す\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:783
msgid "sptr_tは以下の形の内どれか一つの状態にある:"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:787
#, no-wrap
msgid ""
"    -------------------------\n"
"    |    whnf raw value | 10|\n"
"    -------------------------\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:791
#, no-wrap
msgid ""
"    -------------------------\n"
"    |    whnf location  | 00|\n"
"    -------------------------\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:798
msgid ""
"WHNFは'Weak Head Normal Form'を表わしている。 さらにその値は中断された関数で"
"はなく、それゆえサンクへのポインタでもない。 それは直接検査されるかもしれず、"
"また評価される必要がないかもしれない。 wptr_tはsptr_tの別名で、上記の形式を"
"取っていることを保証するためにある。 これは安全性を向上させるために使われ、 "
"値がWHNFであり高価な'eval'をスキップできるかどうかを静的に知ることができる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:803
msgid ""
"生の値とWHNF配置の違いは、 前者は未解釈のビットを保持しているが、 後者はヒー"
"プやスタックへのポインターであるためにGCが回収する必要があるということだ。 "
"WHNF配置によって指し示されたメモリのフォーマットは実際の型表現に依存していて"
"いちがいに決まってはいない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:807
msgid ""
"部分適用された関数は通常のWHNF値である。 'eval'されたか更新された全適用された"
"関数はサンクと呼ばれ、WHNFのポインタから指示されない。 これらの表現は以下であ"
"る。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:811
#, no-wrap
msgid ""
"    -------------------------\n"
"    |   lazy location   | 01|\n"
"    -------------------------\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:818
msgid ""
"遅延配置はサンクもしくはWHNFへのリダイレクトトを指し示す。 遅延配置は必ずアロ"
"ケートされたメモリ領域を差し、 その領域の先頭は制限されたスマートポインタであ"
"る。 この制限されたスマートポインタはC言語の'fptr_t'型で表現される。 fptr_tは"
"遅延配置の先頭エントリのためだけに存在し、 それらはオブジェクトとして流通する"
"ことはない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:823
msgid ""
"fptr_tはWHNF値もしくはコードへのポインタである可能性がある。 もしfptr_tが(上"
"図2種類の内の一つのような)WHNF値ならそれはリダイレクションと呼ばれる。 遅延配"
"置はそれがWHNFによるものだと厳密に取り扱わなければならない。 これは評価済みサ"
"ンクへのリダイレクトとして使われる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:829
msgid ""
"fptr_tはまた'コードポインタ'である可能性があり、 この場合遅延配置はサンクと呼"
"ばれる。 コードポインタは実行可能な機械語へのポインタで、それはクロージャを評"
"価してwptr_tを返す。 返却されたwptr_tは通常、サンクをリダイレクションに変更す"
"るために、コードポインタを書きつぶす。 指示されたコードはこのリダイレクション"
"を実行する責任がある。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:834
#, no-wrap
msgid ""
"    -------------------------\n"
"    |    code pointer   | 11|\n"
"    -------------------------\n"
"    |     data ...          |\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:837
msgid ""
"デバッグ時には特殊なコードポインタBLACK_HOLEが時々fptr_tに格納されている。 こ"
"れはある種のランタイムエラーを検出する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:841
msgid ""
"他の実装と異なりfptr_tは遅延配置の別の形では _ない_ ことに注意すること。 あな"
"たはリダイレクションをチェーンしてはいけない。 リダイレクションは常にWHNF値へ"
"のリダイレクションでなければならない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:845
#, no-wrap
msgid ""
"    sptr_t - タグ付けされたスマートポインタ。WHNF値か遅延配置を保持する。\n"
"    wptr_t - タグ付けされたスマートポインタ。生か配置情報のWNHF値を保持する。\n"
"    fptr_t - タグ付けされたスマートポインタ。リダイレクションを示すWHNF値かサンクを示すコードポインタを保持する。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:849
msgid "## jhcコア型システム"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:853
msgid ""
"jhcのコアは純粋なpure type systemにもとづいている。 pure type system (PTS)は"
"型システムのパラメータ化されたセットである。 jhcのPTSについて以下で解説する。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:856
#, no-wrap
msgid ""
"    種類 = (*, !, **, #, (#), ##, □)\n"
"    公理 = (*:**, #:##, !:**, **:□, ##:□)\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:867
#, no-wrap
msgid ""
"    -- 種類kind(種)\n"
"    *   ボックス化値の種\n"
"    !   ボックス化された正格値の種\n"
"    #   アンボックス化された種\n"
"    (#) アンボックス化タプルの種\n"
"    -- 種類superkind\n"
"    **  全てのボックス化値のsuperkind\n"
"    ##  全てのアンボックス化値のsuperkind\n"
"    -- 種類box\n"
"    □   superkindの存在位置\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:869
#, no-wrap
msgid "    ユーザ定義の種の存在に加えて、supersort ##が存在する。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:873
msgid ""
"次に示すルール表は抽象の種類を表現している。 (A,B,C)の形をもつルールは種類Aか"
"ら種類Bへの関数で結果が種類Cであることを意味している。 この文脈での _関数_ は"
"項と型レベルの抽象を含んでいる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:878
msgid ""
"アンボックス化タプルを引数に取り正格であるかもしれないが、 関数はいつもボック"
"ス化されていることに注意すること。 コードを直接指示するポインタによって表現さ"
"れ、関数が正格であるなら、 関数の評価が中断された値であることはありえない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:883
msgid ""
"これらの型システムのルールはλ抽象に適用される。 これらのルールによって、与え"
"られた型を取れないデータコンストラクタが存在してしまうかもしれないが、それは"
"許容できる。 例としてはアンボックス化タプルがある。 部分適用された関数であっ"
"たとしてもそれらのコンストラクタが型エラーであることを正しく推論するのは困難"
"ではない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:886
#, no-wrap
msgid ""
"    ショートカットとしてここでは *# を * と # の組み合わせをとして使う。\n"
"    例えば、 (*#,*#,*) は (*,*,*) (#,*,*) (*,#,*) (#,#,*) のセットを意味している。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:898
#, no-wrap
msgid ""
"    ルール =\n"
"       (*#!,*#!,*)  -- 値から値への関数で、ボックス化されていて非正格\n"
"       (*#!,(#),*)  -- 値からアンボックス化タプルへの関数で、ボックス化されていて非正格\n"
"       ((#),*#!,!)  -- アンボックス化タプルから値への関数で、ボックス化されていて正格\n"
"       ((#),(#),!)  -- アンボックス化タプルからアンボックス化タプルへの関数で、ボックス化されていて正格\n"
"       (**,*,*)     -- アンボックス化型から値への関数を保持している可能性がある\n"
"       (**,#,*)\n"
"       (**,!,*)\n"
"       (**,**,**)  -- 型から型への関数を持てる\n"
"       (**,##,##)  -- MutArray_ :: * -> #\n"
"       (##,##,##)  -- Complex_ :: # -> #\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:900
#, no-wrap
msgid "    ボックス化値の定義は以下である。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:902
#, no-wrap
msgid "    _|_ :: t iff t::*\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:904
#, no-wrap
msgid "    このPTSは関数的であるが単射ではない。\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:906
msgid "このPTSは次のレベルに階層化されている。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:912
#, no-wrap
msgid ""
"    □               - 種類box\n"
"    **,##,           - 種類superkind\n"
"    *,#,(#),!        - 種類kind(種)\n"
"    Int,Bits32_,Char - 種類type(型)\n"
"    3,True,\"bob\"     - 種類value(値)\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:914
msgid "### ボックス化kind(種)について"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:918
msgid ""
"ボックス化kind(* や !)は同型のランタイム表現を持つ型を表現する。 このため、関"
"数はこれらのkindの型で多相的に記述することができる。 (**,?,?)という形のルール"
"があるため、ボックス化されたkindの型を引数として取ることができる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:921
msgid ""
"アンボックス化されたkind # は独自のランタイム表現を持つ型に存在する。 アン"
"ボックス化型を多相的に使う関数を書くことはできない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:923
msgid "### 種類box、アンボックス化タプルとその同類について"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:930
msgid ""
"種類boxはコード中に現われないけれど、アンボックス化タプルのようなある種の型に"
"ついて理論的な視点から有用である。 アンボックス化タプルはボックス化/アンボッ"
"クス化どちらの引数も取れる。 これを表現することは種類boxなしにそれは不可能"
"だ。 なぜならsuperkind多相でなければならないから。 種類boxは次のような表現を"
"許す。 (これはアンボックス化2タプルのケースである)"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:932
#, no-wrap
msgid "    ∀s1:□ ∀s2:□ ∀k1:s1 ∀k2:s2 ∀t1:k1 ∀t2:k2 . (# t1, t2 #)\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:936
msgid ""
"たとえアンボックス化タプルが部分適用されることが妥当な型付けでも (##,?,?) も"
"しくは (□,?,?) の形のルールは許容しないのだから、 この型は明らかに型検査され"
"ない。 アンボックス化タプルがいつも全適用されるという不変条件が強制されるなら"
"種類boxのコード表現もまた不要になる。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:938
msgid "#### superboxは必要か？"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:940
msgid ""
"種類の公理を見て接続の不足したグラフになっていることに、あなたは気付くかもし"
"れない。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:946
#, no-wrap
msgid ""
"             □            - box\n"
"            / \\\n"
"          **   ##          - superkind\n"
"          /\\     \\\n"
"         *  !     #   (#)  - kind(種)\n"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:950
msgid ""
"これは単に、それらのsuper-sort(種類)は本来不要であるが、kind (#) のアンボック"
"ス化タプルが多相性を欠如していることにに起因する。 このギャップを埋めるために"
"(##)と(□)、□□の種類を導入できる。 これらの種類は決してコードや論文には現われ"
"ないが、気にしないことにする。"
msgstr ""

#. type: Plain text
#: posts/2013-01-12-jhc_manual_ja.md:958
#, no-wrap
msgid ""
"               □□          - 種類superbox\n"
"              /  \\\n"
"             □    (□)      - 種類box\n"
"            / \\      \\\n"
"          **   ##     (##)   - 種類superkind\n"
"          /\\     \\    |\n"
"         *  !     #   (#)    - 種類kind(種)\n"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第2回 議事録\n"
"description: Ajhcコンパイラのセールスウーマンに変身でゲッソ!\n"
"tags: meeting\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:10
msgid ""
"Metasepi作戦会議 第2回を [名古屋にある大学](http://partake.in/"
"events/1f049014-8e93-4da3-a97d-23eb7243d6a1)  と京都にある大学で開催したでゲ"
"ソ。"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:22
msgid ""
"今回の作戦会議はMetassepiプロジェクト全体ではなく [Ajhcコンパイラ](http://"
"ajhc.metasepi.org/)  に焦点をしぼって、AjhcコンパイラとMetasepiプロジェクトの"
"宣伝に行脚したんでゲソ。 Cortex-M3マイコンでのアプリケーション事例があるの"
"で、Ajhcのユーザーや開発者を増やせるのではないか？と思ったのでゲソ。 Haskell"
"コンパイラとしては [jhc](http://repetae.net/computer/jhc/)  よりも [GHC]"
"(http://www.haskell.org/ghc/)  の方が圧倒的にメジャーなので、皆マイコンのよう"
"なメモリ資源がとぼしい環境では動かせないものと思っているんじゃなイカ？ そんな"
"中Ajhcを使ってRAMを40kBしか使わずに簡単なアプリケーションを作れることを知ると"
"やはりビックリするようでゲソ。 Metasepiプロジェクトの良いアピールになったでゲ"
"ソ!"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:27
msgid ""
"今回は名古屋と京都でAjhcの宣伝をしたでゲソが、他の場所にも是非営業にいってみ"
"たいゲソ。 ワシから直にAjhcコンパイラのプレゼンを聴いてみたい方はお気軽に "
"[\\@metasepi](https://twitter.com/metasepi)  まで連絡が欲しいでゲソ!"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:31
msgid "### Ajhcコンパイラの解説 - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:33
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/19008326\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/master_q/20130422-ajhc-igarashi\" title="
"\"Ajhcコンパイラの押売りに来ました\" target=\"_blank\">Ajhcコンパイラの押売り"
"に来ました</a> </strong> from <strong><a href=\"http://www.slideshare.net/"
"master_q\" target=\"_blank\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:35
msgid "## 会議の雰囲気@名古屋"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:39
msgid ""
"![](/img/20130422-nagoya2.jpg)  ![](/img/20130422-nagoya3.jpg)  ![](/"
"img/20130422-nagoya4.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:41
msgid "## 会議の雰囲気@京都"
msgstr ""

#. type: Plain text
#: posts/2013-04-22-travel_in_kyoto-u.md:44
msgid ""
"![](/img/20130422-kyoto1.jpg)  ![](/img/20130422-kyoto3.jpg)  ![](/"
"img/20130422-kyoto4.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第7回 議事録\n"
"description: KOF2013をAjhcで侵略でゲソ!\n"
"tags: meeting, ajhc\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:12
msgid ""
"Metasepi作戦会議 第7回を [KOF2013：関西オープンフォーラム2013](https://k-of."
"jp/2013/)  で開催したでゲソ。 今回はマイコンをAjhcコンパイラで開発するまとめ"
"として [ChibiOS/RT](http://www.chibios.org/) のスレッドをHaskellで置き換える"
"話をトピックとして取り上げてみたでゲソ。"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:17
msgid ""
"またAjhcコンパイラのMac OS Xでの継続的インテグレーションを [Travis CI]"
"(https://travis-ci.org/ajhc/ajhc)  で実行しているので、Mac OS Xアプリを"
"Travis CIでビルドする手順を説明してみたでゲソ。 他のプロジェクトのお役に立て"
"ればうれしいでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:23
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/27832522\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/metasepi-team-meeting-7-snatch-application-on-tiny-os\" title="
"\"Metasepi team meeting #7: Snatch application on tiny OS\" target=\"_blank"
"\">Metasepi team meeting #7: Snatch application on tiny OS</a> </strong> "
"from <strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:25
msgid "### Build OS X Apps on Travis CI - @masterq_teokure"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:27
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/27832511\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen> </iframe> <div style="
"\"margin-bottom:5px\"> <strong> <a href=\"https://www.slideshare.net/"
"master_q/20131109-kof2013-travisciosx\" title=\"Build OS X Apps on Travis CI"
"\" target=\"_blank\">Build OS X Apps on Travis CI</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:31
msgid "### Build OS X Apps on Travis CI"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:33
msgid ""
"<iframe width=\"420\" height=\"315\" src=\"//www.youtube.com/embed/"
"X_2khIBzolM\" frameborder=\"0\" allowfullscreen></iframe>"
msgstr ""

#. type: Plain text
#: posts/2013-11-10-kof2013.md:40
msgid ""
"![](/img/20131110_1.jpg)  ![](/img/20131110_3.jpg)  ![](/img/20131110_4."
"jpg)  ![](/img/20131110_5.jpg)  ![](/img/20131110_2.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:5
#, no-wrap
msgid ""
"title: Metasepi作戦会議 第1回 議事録\n"
"description: 10人集まってkernelを侵略開始でゲッソ!\n"
"tags: meeting\n"
"---\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:13
msgid ""
"[Metasepi作戦会議 第1回](http://partake.in/events/7a65b671-1b43-473e-9639-"
"b9a01ec127de)  を開催したでゲソ。 今回ははじめてのオフラインミーティングなの"
"で、プロジェクトの方向性の共有と各人のやりたいことの宣言に重点をしぼったでゲ"
"ソ。 ワシとしてはこのプロジェクトでは作業分担や納期のようなものはもうけず、"
"各々やりたいことを自由にやってほしいと思っているでゲソ。 ワシは他のメンバーが"
"手をつけてない領域を重点的に見れば、自然と作業分担ができるはずじゃなイカ。 "
"Easy come. Easy go. 気楽にいこうでゲッソ!"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:19
msgid ""
"作戦会議 第2回はメンバーが手を動かした結果まとまった内容が集まった時点で開催"
"することにするでゲソ。 なにか面白い調査結果や、面白い実装をした場合には "
"[Mailing list (en)](http://groups.google.com/group/metasepi)  に投げてみて欲"
"しいでゲソ。 またWikiが欲しいなどのプロジェクト運用面についての相談/提案も上"
"記メーリングリストどうぞでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:21
msgid "## 発表"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:23
msgid "### プロジェクト説明 - @masterq_hentai"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:25
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/16134739\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/master_q/what-is-metasepi\" title=\"What is "
"Metasepi?\" target=\"_blank\">What is Metasepi?</a> </strong> from "
"<strong><a href=\"http://www.slideshare.net/master_q\" target=\"_blank"
"\">Kiwamu Okabe</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:27
msgid "### jhcのGCについて - @dec9ue"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:31
msgid "### 再入とは - @takeoka"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:33
msgid ""
"<iframe src=\"http://www.slideshare.net/slideshow/embed_code/16333875\" "
"width=\"427\" height=\"356\" frameborder=\"0\" marginwidth=\"0\" "
"marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-"
"width:1px 1px 0;margin-bottom:5px\" allowfullscreen webkitallowfullscreen "
"mozallowfullscreen> </iframe> <div style=\"margin-bottom:5px\"> <strong> <a "
"href=\"http://www.slideshare.net/takeoka1/interrupt-jhc\" title=\"Interrupt "
"jhc\" target=\"_blank\">Interrupt jhc</a> </strong> from <strong><a href="
"\"http://www.slideshare.net/takeoka1\" target=\"_blank\">たけおか しょうぞう"
"</a></strong> </div>"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:35
msgid "### Metasepiブログエントリの解説 - @masterq_hentai"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:37
msgid "[Metasepi Logbook](/posts.html)"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:39
msgid "### メンバー各々の興味範囲ヒアリング + 自己紹介"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:41
msgid "![](http://farm9.staticflickr.com/8373/8438427272_9883d620d5_z.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:66
#, no-wrap
msgid ""
"* リクルート=>教育=>コンパイラ=>readxhc\n"
"    * @khibino\n"
"    * @yuga\n"
"    * @1to100pen\n"
"* jhc=>GC\n"
"    * @dec9ue\n"
"* jhc=>GC=>リージョン推論\n"
"    * @tanimocchi\n"
"* jhc=>GHCコンパチ\n"
"    * @khibino\n"
"* jhc=>RTS\n"
"    * @yuga\n"
"* NetBSD\n"
"    * @yshigeru\n"
"* NetBSD=>Haskell化\n"
"    * @kei_q\n"
"    * @yuga\n"
"* デザイン=>picokernel\n"
"    * @takeoka\n"
"* ビジネス=>jhcコンサル\n"
"    * @masterq_hentai\n"
"* 組み込みHaskell\n"
"    * @takeoka\n"
"    * @tanimocchi\n"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:72
msgid ""
"![](/img/20130203-meeting1.jpg)  ![](/img/20130203-meeting2.jpg)  ![](/"
"img/20130203-meeting_q.jpg)"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:76
msgid ""
"その他の写真は [koie blog](http://blog.livedoor.jp/hkoie/archives/54372728."
"html)  で見れるでゲソ。koieさんありがとうでゲソー。"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:78
msgid "## 議題リスト"
msgstr ""

#. type: Plain text
#: posts/2013-02-03-kickoff_meeting.md:79
msgid "![](http://farm9.staticflickr.com/8044/8438426772_9947a6ac06.jpg)"
msgstr ""
