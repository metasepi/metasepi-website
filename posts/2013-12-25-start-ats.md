---
title: "ML programmer's guide to ATS" 日本語訳
description: Haskell以外の言語処理系でスナッチ設計してみたいでゲソ!
tags: ats, translation
---

この記事は
[Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/advent-calendar/2013/theorem_prover)
の12/25(水曜)分じゃなイカ。

[ML programmer's guide to ATS - liulk @ cs-people](http://cs.likai.org/ats/ml-programmers-guide-to-ats)
を翻訳してATS言語の使い方をマスターするでゲソ!

## MLプログラマ向けATS言語ガイド

このガイドではATS (Applied Type System) でのプログラミング作法を解説はしません。
それでも、熟練のMLプログラマであればすぐにATSの用語を理解してATSのコードを読み始めることができると思います。

## ATSのすばらしき世界

ATSでは、3つの世界でプログラミングをすることを覚えておくと良いでしょう。

* Dynamics(動的な世界): プログラムを実行した時に評価される部分です。これはプログラミング言語に馴染んだプログラマにとってもっとも親しみ深い部分でしょう。
* Proofs(証明): 動的な特性を静的な特性に結びつけます。Proofs(証明)はプログラムの動的な部分と考えることができます。しかし証明はコンパイル後では消滅してしまい、実行時には存在しません。コンパイラはあなたが書いた証明を検査し、動作可能なコードを生成する前に削除するのです。
* Statics(静的な世界): 型検査時にコンパイラによって評価される部分です。静的な部分では静的な式の評価は常に終了しなければなりません。そのため型検査は決定可能です。

ATSの前身であるDependent MLでは、静的な世界からは依存型を通してしか動的な世界を見るしかありませんでした。
動的なそれぞれの式は静的な式によって指定された型を持っています。
静的な制約は静的な式の集合によって形成され、
型検査はそれらの制約が充足可能であるかどうか調べます。

ATSは依存型に加えて証明を使うことができ、
静的な世界をより強く動的な世界に関与させることができます。
プログラマが動的な式と対応する証明の項を混じり合って書くことができるのです。
証明はpropsと呼ばれるclassical propositions(古典論理)や、
viewsと呼ばれるlinear propositions(linear logic)(線形論理)
のどちらかを取ります。

Prologとその派生にとって、propsを定義するのはPrologの述語を定義することとよく似ています。
しかし、型検査は自動的にその述語の検査をしてくれません。
プログラムを記述するのと同じように、証明も手動で書き下す必要があります。
証明の記述によってATSを証明器として使うことができます。

最後に、動的な世界と静的な世界の分離については
「動的な項の種は静的な種によって特徴づけられる」
と考えることもできます。

* プログラムの項は型によって特徴づけられる
* 線形論理による証明の項はviewsによて特徴づけられる
* 古典論理による証明の項はpropsによって特徴づけられる

## 拡張子

ATSで用いられるファイルはいくつかの拡張子を持っています。

* .datsファイルは動的と静的な宣言を格納します。これはSMLにおけるモジュールシステムのstructureやOCamlの.mlファイルに似ています。
* .satsファイルは静的な宣言を格納します。これはSMLにおけるモジュールシステムのsignatureやOCamlの.mliファイルに似ています。
* .catsファイルは.satsファイルから使われるC言語コードを格納します。
* .hatsファイルは動的もしくは静的なATSコードを格納します。これらは.satsもしくは.datsファイルからインクルードすることができます。

.datsファイルと.satsファイルの特筆すべき違いは、関数と値のシグニチャ宣言です。

~~~ {.ocaml}
(* .datsファイル *)
extern val c: int
extern fun foo (x:int): int
fun bar (x: int): int = ...
~~~

~~~ {.ocaml}
(* .satsファイル *)
val c: int
fun foo (x:int): int
(* foo関数の実体を宣言できません *)
~~~

けれども典型的には.satsファイルでは関数の型を定義して、.datsファイルに実装を書きます。
そのような場合、.datsファイルの実装には型注釈は不要です。

~~~ {.ocaml}
(* .datsファイル *)
implement baz (x) = ...
~~~

~~~ {.ocaml}
(* .satsファイル *)
fun baz (x:int): int
~~~

重要なことですが、MLと異なり、ATSの型検査器はとても限定された型推論しか行ないません。
あなたは明示的に十分な型注釈を与える必要があります。
そうすればATSは型の導出できるようになるでしょう。

## 静の恍惚

ATSはMLに少し似ています。
型とデータ型を定義することができます。

~~~ {.ocaml}
(* ATS *)
typedef t = int
typedef pair (a:type, b:type) = '(a, b)
datatype option (a:type) =
  | Some(a) of a
  | None(a)
~~~

~~~ {.ocaml}
(* SML *)
type t = int
type ('a, 'b) pair = 'a * 'b
datatype 'a option =
    Some of 'a
  | None
~~~

上記のSMLコードでは、定義済みのint型があったとき、
新しいtという名前の型をint型の別名として定義しています。
また、いくつかの型変数をパラメータとして取るような型を別名として定義できます。
さらに型変数aをパラメータとして取るoptionというデータ型も定義しています。
これらの識別子はすべて静的な識別子です。
対して、動的な識別子というのは実行時の値になります。

一方ATSでは、データ型のコンストラクタに型変数を明示的に適用してやる必要があることに注意してください。
データ型に関する詳細な情報は
[Datatypes in the ATS tutorial](http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/datatypes.html)
を参照してくだっさい。
しかし、まずはこの章の残りを読んでからでも良いでしょう。

型宣言は静的な識別子を"type"という種の静的な式に割り付けます。
つまりtypedefはstadefの特殊形です。
次に示す2つの静的な宣言はほぼ同じです。

~~~ {.ocaml}
(* ATS (1) *)
(* sta t:type *)
typedef t = int
typedef pair (a:type, b:type) =
  '(a, b)
~~~

~~~ {.ocaml}
(* ATS (2) *)
(* sta t:_ *)
stadef t = int
stadef pair (a:type, b:type) =
  '(a, b)
~~~

## 線形論理(Linear Logic)について

xxx

Linear logic distincts itself from classical logic in the sense that weakening and contraction structural rules are disallowed. Weakening says you cannot be given a fact and leave it unused, and contraction says you cannot designate a fact for multiple uses. Therefore, a fact must be used exactly once.

Views are linear in that sense, and view proofs are typically used to track resource ownership or to update states of a resource.
