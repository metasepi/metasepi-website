---
title: "ML programmer's guide to ATS" 日本語訳
description: Haskell以外の言語処理系でスナッチ設計してみたいでゲソ!
tags: ats, translation
---

この記事は
[Theorem Prover Advent Calendar 2013 - Qiita [キータ]](http://qiita.com/advent-calendar/2013/theorem_prover)
の12/25(水曜)分じゃなイカ。

[ML programmer's guide to ATS - liulk @ cs-people](http://cs.likai.org/ats/ml-programmers-guide-to-ats)
を翻訳してATS言語の使い方をマスターするでゲソ!

## MLプログラマ向けATS言語ガイド

このガイドではATS (Applied Type System) でのプログラミング作法を解説はしません。
それでも、熟練のMLプログラマであればすぐにATSの用語を理解してATSのコードを読み始めることができると思います。

## ATSのすばらしき世界

ATSでは、3つの世界でプログラミングをすることを覚えておくと良いでしょう。

* Dynamics(動的な世界): プログラムを実行した時に評価される部分です。これはプログラミング言語に馴染んだプログラマにとってもっとも親しみ深い部分でしょう。
* Proofs(証明): 動的な特性を静的な特性に結びつけます。Proofs(証明)はプログラムの動的な部分と考えることができます。しかし証明はコンパイル後では消滅してしまい、実行時には存在しません。コンパイラはあなたが書いた証明を検査し、動作可能なコードを生成する前に削除するのです。
* Statics(静的な世界): 型検査時にコンパイラによって評価される部分です。静的な部分では静的な式の評価は常に終了しなければなりません。そのため型検査は決定可能です。

ATSの前身であるDependent MLでは、静的な世界からは依存型を通してしか動的な世界を見るしかありませんでした。
動的なそれぞれの式は静的な式によって指定された型を持っています。
静的な制約は静的な式の集合によって形成され、
型検査はそれらの制約が充足可能であるかどうか調べます。

ATSは依存型に加えて証明を使うことができ、
静的な世界をより強く動的な世界に関与させることができます。
プログラマが動的な式と対応する証明の項を混じり合って書くことができるのです。
証明はpropsと呼ばれるclassical propositions(古典論理)や、
viewsと呼ばれるlinear propositions(linear logic)(線形論理)
のどちらかを取ります。

Prologとその派生にとって、propsを定義するのはPrologの述語を定義することとよく似ています。
しかし、型検査は自動的にその述語の検査をしてくれません。
プログラムを記述するのと同じように、証明も手動で書き下す必要があります。
証明の記述によってATSを証明器として使うことができます。

最後に、動的な世界と静的な世界の分離については
「動的な項の種は静的な種によって特徴づけられる」
と考えることもできます。

* プログラムの項は型によって特徴づけられる
* 線形論理による証明の項はviewsによて特徴づけられる
* 古典論理による証明の項はpropsによって特徴づけられる

## 拡張子

ATSで用いられるファイルはいくつかの拡張子を持っています。

* .datsファイルは動的と静的な宣言を格納します。これはSMLにおけるモジュールシステムのstructureやOCamlの.mlファイルに似ています。
* .satsファイルは静的な宣言を格納します。これはSMLにおけるモジュールシステムのsignatureやOCamlの.mliファイルに似ています。
* .catsファイルは.satsファイルから使われるC言語コードを格納します。
* .hatsファイルは動的もしくは静的なATSコードを格納します。これらは.satsもしくは.datsファイルからインクルードすることができます。

.datsファイルと.satsファイルの特筆すべき違いは、関数と値のシグニチャ宣言です。

~~~ {.ocaml}
(* .datsファイル *)
extern val c: int
extern fun foo (x:int): int
fun bar (x: int): int = ...
~~~

~~~ {.ocaml}
(* .satsファイル *)
val c: int
fun foo (x:int): int
(* foo関数の実体を宣言できません *)
~~~

けれども典型的には.satsファイルでは関数の型を定義して、.datsファイルに実装を書きます。
そのような場合、.datsファイルの実装には型注釈は不要です。

~~~ {.ocaml}
(* .datsファイル *)
implement baz (x) = ...
~~~

~~~ {.ocaml}
(* .satsファイル *)
fun baz (x:int): int
~~~

重要なことですが、MLと異なり、ATSの型検査器はとても限定された型推論しか行ないません。
あなたは明示的に十分な型注釈を与える必要があります。
そうすればATSは型の導出できるようになるでしょう。

## 恍惚の静

ATSはMLに少し似ています。
型とデータ型を定義することができます。

~~~ {.ocaml}
(* ATS *)
typedef t = int
typedef pair (a:type, b:type) = '(a, b)
datatype option (a:type) =
  | Some(a) of a
  | None(a)
~~~

~~~ {.ocaml}
(* SML *)
type t = int
type ('a, 'b) pair = 'a * 'b
datatype 'a option =
    Some of 'a
  | None
~~~

上記のSMLコードでは、定義済みのint型があったとき、
新しいtという名前の型をint型の別名として定義しています。
また、いくつかの型変数をパラメータとして取るような型を別名として定義できます。
さらに型変数aをパラメータとして取るoptionというデータ型も定義しています。
これらの識別子はすべて静的な識別子です。
対して、動的な識別子というのは実行時の値になります。

一方ATSでは、データ型のコンストラクタに型変数を明示的に適用してやる必要があることに注意してください。
データ型に関する詳細な情報は
[Datatypes in the ATS tutorial](http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/datatypes.html)
を参照してくだっさい。
しかし、まずはこの章の残りを読んでからでも良いでしょう。

型宣言は静的な識別子を"type"という種の静的な式に割り付けます。
つまりtypedefはstadefの特殊形です。
次に示す2つの静的な宣言はほぼ同じです。

~~~ {.ocaml}
(* ATS (1) *)
(* sta t:type *)
typedef t = int
typedef pair (a:type, b:type) =
  '(a, b)
~~~

~~~ {.ocaml}
(* ATS (2) *)
(* sta t:_ *)
stadef t = int
stadef pair (a:type, b:type) =
  '(a, b)
~~~

この2つが違うのはtypedefがtが種"type"であることを保証するのに対して、
stadefは何も保証しないという点です。

型は、静的な式や静的な識別子が取り得る数多くの種の内の一つです。
他の種としては以下が挙げられます。

* Ground種: int, bool, char, addrです。これらは依存型の土台になります。
* View種: 線形論理の命題です。
* Prop種: 古典論理の命題です。
* Viewtype種: 線形型です。これはType種とView種が結合したものに見えるかもしれません。

datasortを使うことで新しい種を定義できます。
[sllist.dats](http://www.cs.bu.edu/~hwxi/academic/courses/CS520/Fall08/assignments/05/sllst_dats.html)
の最初の数行はリストに似た種を定義する方法を示しています。
またsortdefを使えば種の別名を定義できます。
これはサブセット種と呼ばれる種にpiggy-backな制約をつけます。
[prelude/sortdef.sats](https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/prelude/sortdef.sats)
はその例です。
制約はシンプルなboolean種の式です。

type, view, propの種について、別名定義、abstract quantityの宣言、代数的データのコンストラクタの宣言をすることができます。

<table border="1" bordercolor="#888888" cellspacing="0" style="border-color:rgb(136,136,136);border-width:1px;border-collapse:collapse">
<tbody>
<tr>
<td style="width:60px"> </td>
<td style="width:60px">Static</td>
<td style="width:60px">Type</td>
<td style="width:60px">View</td>
<td style="width:60px">Prop</td>
<td style="width:60px">Viewtype</td>
</tr>
<tr>
<td>別名定義</td>
<td>stadef</td>
<td style="width:60px">typedef</td>
<td>viewdef</td>
<td>propdef</td>
<td>viewtypedef</td>
</tr>
<tr>
<td>Abstract</td>
<td>sta</td>
<td>abstype</td>
<td>absview</td>
<td>absprop</td>
<td>absviewtype</td>
</tr>
<tr>
<td style="width:60px">代数的</td>
<td style="width:60px">(N/A)</td>
<td style="width:60px">datatype</td>
<td style="width:60px"><a href="http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataviews.html">dataview</a></td>
<td style="width:60px"><a href="http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataprops.html">dataprop</a></td>
<td style="width:60px"><a href="http://www.ats-lang.org/htdocs-old/TUTORIAL/contents/dataviewtypes.html">dataviewtype</a></td>
</tr>
</tbody>
</table>

type, view, prop, viewtypeはstatics(静的)の特殊形です。
つまり、typedef, viewdef, propdef, viewtypedefの代わりに単にstadefを使うことができます。
同様にabstractの宣言においてもabstype, absview, absprop, absviewtypeの代わりにstaを使うことができます。
けれどもdatasort, datatype, dataview, dataprop, dataviewtypeの間は交換することができません。
これらは新しい何かに対する代数的なコンストラクタを定義します。
(例: datatypeは新しい型のコンストラクタです。dataviewは新しいviewのコンストラクタです。などなど)

view, prop, viewtypeについて、ここでは取り上げません。
ここでは型とシンプルな静的な式について注目しましょう。

静的な式は種によって検査される第一級の言語です。
いくつかの例を見てみましょう。

* 静的な式として書かれた数値は、種"int"の静的な数値になります
* ビルトインされた数値比較の述語があります。<, <=, >, >=, ==, <>は静的なシグニチャ"(int, int) -> bool"を持っています
* ビルトインされた論理積と論理和である&&, ||は静的なシグニチャ"(bool, bool) -> bool"を持っています
* 0 <= 4 && 4 < 10 は種"bool"の静的な式です
* 一般的に、静的なnat_lt関数は次のように定義できます

~~~ {.ocaml}
(* ATS *)
stadef nat_lt (i: int, limit: int) =
  0 <= i && i < limit
~~~

静的な関数であるnat_ltは、種boolが要求されればいつでも使うことができます。
例えば、実行時に数値の引数の範囲に制約をつけたい場合を考えましょう。

* ビルトインの静的な識別子intはオーバーロードされています。 種"type"と種"int -> type"の2つの定義を持っています。二次的なintは依存型の数値で静的な式によって指示されています。
* int(3) は種"type"の静的な式です
* ガードを使った存在記号を用いて、数値型を指定した範囲に制限することができます。

~~~ {.ocaml}
(* ATS *)
typedef NatLt (n: int) =
  [i: int | nat_lt (i, n)] int(i)
~~~

Which defines a static function NatLt: int -> type.
Given a static integer n, NatLt gives you a type that is a subset of integers from 0 to n - 1.
The body of NatLt reads, "there exists i, which is of the int sort and that nat_lt(i, n) is true, yields a type int(i)."

We can then use the type NatLt(n) to write a function:

~~~ {.ocaml}
(* ATS *)
fun digit_of_num (i: NatLt(10)): char = ...
~~~

You can look at
[prelude/basics_sta.sats](https://svn.code.sf.net/p/ats-lang/code/trunk/prelude/basics_sta.sats),
which is part of ATS/Anariats, for the signatures of many built-in static operators.
Notice that stadef allows many such operators to be overloaded.
The fixity of many infix binary operators are defined in
[prelude/fixity.sats](https://ats-lang.svn.sourceforge.net/svnroot/ats-lang/trunk/prelude/fixity.ats).

## 線形論理(Linear Logic)について

xxx

Linear logic distincts itself from classical logic in the sense that weakening and contraction structural rules are disallowed. Weakening says you cannot be given a fact and leave it unused, and contraction says you cannot designate a fact for multiple uses. Therefore, a fact must be used exactly once.

Views are linear in that sense, and view proofs are typically used to track resource ownership or to update states of a resource.
