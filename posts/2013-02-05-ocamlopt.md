---
title: (作成中) ocamloptの全体像
description: ocamloptのランタイムとコンパイルパイプラインを知らべてみたでゲソ!
tags: ocaml, internal
---

## 発端

[ocamloptを読むことになりました。 - Togetter](http://togetter.com/li/450580)

Camlp4だけはこわいんでゲソ...
逃げるしかないでゲソ。
[簡単なプログラム](https://github.com/master-q/read_ocamlopt/)
を作ってみて、コンパイル結果とocamloptを比較すればだいたいわかるんじゃなイカ？

## 起動

~~~
$ pwd
/home/kiwamu/src/read_ocamlopt/helloworld
$ gdb helloworld
(gdb) b camlHelloworld__hello_1030
Breakpoint 1 at 0x403560
(gdb) run
Starting program: /home/kiwamu/src/read_ocamlopt/helloworld/helloworld
warning: Could not load shared library symbols for linux-vdso.so.1.
Do you need "set solib-search-path" or "set sysroot"?

Breakpoint 1, 0x0000000000403560 in camlHelloworld__hello_1030 ()
(gdb) bt
#0  0x0000000000403560 in camlHelloworld__hello_1030 ()
#1  0x0000000000403591 in camlHelloworld__entry ()
#2  0x00000000000003e8 in ?? ()
#3  0x0000000000403229 in caml_program ()
#4  0x000000000002950d in ?? ()
#5  0x0000000000411a52 in caml_start_program ()
#6  0x0000000000000000 in ?? ()
~~~

スタックが小細工されているけれど、
caml_start_program関数を呼び出すのはasmrun/startup.cなので、
以下のようなコールグラフになるはず。

~~~
caml_main (asmrun/startup.c)
=> caml_start_program (asmrun/amd64.S) <= %r12にentry_pointを取りcall
   => caml_program (helloworld.startup.s) <= コンパイル時生成
      => camlHelloworld__entry <= OCamlコードから生成
~~~

このhelloworld.startup.sというファイルは自動生成されていて、
通常はコンパイル終了直前に削除されるが、
ocamlopt -dstartup hoge.ml のようにすれば、startupファイルが残る。
今回作った簡単なプログラムの
[startupファイル](https://github.com/master-q/read_ocamlopt/blob/master/helloworld/helloworld.startup.s)
をgithubにおいた。

実際の初期化内容はちゃんと調査しないと。

xxxxxxxxxxxxxxx

## ランタイム

xxxxxxxxxxxxxxx

## コンパイルパイプライン

ocaml-4.00.1/driver/optmain.ml の

~~~
Asmlink.link ppf (List.rev !objfiles) target;
~~~

から開始。
ocaml-4.00.1/asmcomp/asmgen.ml がアセンブラ生成の末端？

~~~
main
Arg.parse (Arch.command_line_options @ Options.list) anonymous usage;
=> process_file Format.err_formatter
   => process_implementation_file ppf name
      => Optcompile.implementation ppf name opref # <= コンパイルパイプライン本体
         let (++) x f = f x in
         let (+++) (x, y) f = (x, f y) in
         let inputfile = Pparse.preprocess sourcefile in
         Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
             # :: Parsetree.structure
         ++ print_if ppf Clflags.dump_parsetree Printast.implementation
             # :: Parsetree.structure -> Parsetree.structure
         ++ Typemod.type_implementation sourcefile outputprefix modulename env
             # :: Parsetree.structure -> Typedtree.structure * Typedtree.module_coercion
         ++ Translmod.transl_store_implementation modulename
             # :: Typedtree.structure * Typedtree.module_coercion -> int * Lambda.lambda
         +++ print_if ppf Clflags.dump_rawlambda Printlambda.lambda
             # :: Lambda.lambda -> Lambda.lambda
         +++ Simplif.simplify_lambda
             # :: Lambda.lambda -> Lambda.lambda
         +++ print_if ppf Clflags.dump_lambda Printlambda.lambda
             # :: Lambda.lambda -> Lambda.lambda
         ++ Asmgen.compile_implementation outputprefix ppf;
             # :: int * Lambda.lambda -> unit
         Compilenv.save_unit_info cmxfile; # <= コンパイル済みcurrent_unitをファイル書き込み
=> Asmlink.link ppf (List.rev !objfiles) target;
   make_startup_file ppf startup units_tolink; # <= helloworld.startup.sファイル生成
   => Proc.assemble_file startup startup_obj
      Ccomp.command (Config.asm ^ " -o " ^
        Filename.quote outfile ^ " " ^ Filename.quote infile)
      # gasでオブジェクトファイルに
   call_linker (List.map object_file_name objfiles) startup_obj output_name;
   => Ccomp.call_linker mode output_name files c_lib;
~~~

[標準ライブラリArgモジュール](http://ocaml.jp/Arg) にある通りArgモジュールはanonymous関数を引数を適用する。

Optcompile.implementation関数がコンパイルパイプラインの本体で、
Haskellのモナドと比較すると、++が>>で、+++が>>=みたいな感じ。
つまり内側から外側に向かって処理が進む。
print_ifは無視できるので、、、

~~~ {.ocaml}
let inputfile = Pparse.preprocess sourcefile in
Pparse.file ppf inputfile Parse.implementation ast_impl_magic_number
    (* :: Parsetree.structure *)
++ Typemod.type_implementation sourcefile outputprefix modulename env
    (* :: Parsetree.structure -> Typedtree.structure * Typedtree.module_coercion *)
++ Translmod.transl_store_implementation modulename
    (* :: Typedtree.structure * Typedtree.module_coercion -> int * Lambda.lambda *)
+++ Simplif.simplify_lambda
    (* :: Lambda.lambda -> Lambda.lambda *)
++ Asmgen.compile_implementation outputprefix ppf;
    (* :: int * Lambda.lambda -> unit *)
~~~

cmxファイルはocamloptでコンパイルすると生成されるオブジェクトファイル。
cmxaファイルはocamloptが使うライブラリファイル。
^[参考: [Chapter 11 ネイティブコードコンパイラ (ocamlopt) - OCaml.jp](http://ocaml.jp/Chapter%2011%20%E3%83%8D%E3%82%A4%E3%83%86%E3%82%A3%E3%83%96%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%20(ocamlopt))]

最終的なリンクは以下のように行なわれるみたい。
OCamlに
[リンク時のコマンドを調べるpatch](https://github.com/master-q/read_ocamlopt/blob/master/ocaml4.00.1_show_linker.patch)
をあてて調べた。

~~~
$ gcc -o 'helloworld/helloworld'   '-L/usr/local/lib/ocaml'  '/tmp/camlstartup8038e6.o' '/usr/local/lib/ocaml/std_exit.o' 'helloworld/helloworld.o' '/usr/local/lib/ocaml/stdlib.a' '/usr/local/lib/ocaml/libasmrun.a' -lm  -ldl
~~~

helloworld/helloworld.oファイルはどこでコンパイルされたんだろうか？

xxxxxxxxxxxxxx
